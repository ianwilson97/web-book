<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Technical Interviews - My Docs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Technical Interviews";
        var mkdocs_page_input_path = "2.Interviews/a_technical_interviews.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> My Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Fundamentals</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../1.Fundamentals/a_object_oriented_programming/">Object Oriented Programming</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../1.Fundamentals/b_data_structures/">Data Structures</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../1.Fundamentals/c_algorithms/">Algorithms</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../1.Fundamentals/d_python/">Python</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Interviews</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Technical Interviews</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">📘 Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#why-this-guide">🎯 Why This Guide?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#how-this-guide-is-different">🎨 How This Guide is Different</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#guide-structure">🗺️ Guide Structure</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-foundation-building">1️⃣ Foundation Building</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-pattern-recognition">2️⃣ Pattern Recognition</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-interview-strategy">3️⃣ Interview Strategy</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#good-references">Good References</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#before-we-begin-python-essentials">💻 Before We Begin: Python Essentials</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#key-python-tools-for-interviews">🔧 Key Python Tools for Interviews</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#python-specific-pro-tips">🛠️ Python-Specific Pro Tips</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#how-to-use-this-guide">🎯 How to Use This Guide</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#learning-path">📚 Learning Path</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#time-management">⏰ Time Management</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lets-get-started">🎮 Let's Get Started!</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#your-first-steps">🎯 Your First Steps</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#remember">💡 Remember</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#common-interview-mistakes-to-avoid">🚨 Common Interview Mistakes to Avoid</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#success-tips">🌟 Success Tips</a>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">My Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Interviews</li>
      <li class="breadcrumb-item active">Technical Interviews</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="the-ultimate-python-technical-interview-guide">🚀 The Ultimate Python Technical Interview Guide<a class="headerlink" href="#the-ultimate-python-technical-interview-guide" title="Permanent link">&para;</a></h1>
<p><img alt="Software Engineer Interview" src="https://i.postimg.cc/BnTvjL3t/temp-Imageb-Xdn-Pv.avif" /></p>
<h2 id="introduction">📘 Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Welcome to your comprehensive companion for mastering technical interviews! Whether you're aiming for FAANG companies or preparing for your first technical interview, this guide will help you tackle coding challenges with confidence.</p>
<h3 id="why-this-guide">🎯 Why This Guide?<a class="headerlink" href="#why-this-guide" title="Permanent link">&para;</a></h3>
<ul>
<li>🐍  <strong>Python-Focused</strong>: All solutions and examples in Python (the most popular interview language!)</li>
<li>🧠  <strong>Pattern Recognition</strong>: Learn to spot and solve common problem patterns</li>
<li>⚡  <strong>Optimization Skills</strong>: Master the art of writing efficient code</li>
<li>🎓  <strong>Interview Strategy</strong>: Learn not just what to code, but how to approach problems</li>
<li>💪  <strong>Practical Examples</strong>: Real interview problems with detailed solutions</li>
</ul>
<h3 id="how-this-guide-is-different">🎨 How This Guide is Different<a class="headerlink" href="#how-this-guide-is-different" title="Permanent link">&para;</a></h3>
<p>We believe learning should be fun! You'll find:</p>
<ul>
<li>🎮 Interactive examples</li>
<li>🎯 Pattern-based learning</li>
<li>🧩 Visual explanations</li>
<li>💡 "Aha!" moment highlights</li>
<li>🚫 Common pitfall warnings</li>
</ul>
<h2 id="guide-structure">🗺️ Guide Structure<a class="headerlink" href="#guide-structure" title="Permanent link">&para;</a></h2>
<h3 id="1-foundation-building">1️⃣ Foundation Building<a class="headerlink" href="#1-foundation-building" title="Permanent link">&para;</a></h3>
<ul>
<li>Big-O Notation and Complexity Analysis</li>
<li>Python-specific optimizations</li>
<li>Core data structures in Python</li>
<li>Essential algorithms and their implementations</li>
</ul>
<h3 id="2-pattern-recognition">2️⃣ Pattern Recognition<a class="headerlink" href="#2-pattern-recognition" title="Permanent link">&para;</a></h3>
<ul>
<li>Common interview patterns</li>
<li>When to use which approach</li>
<li>Pattern-specific optimizations</li>
<li>Real interview problem mappings</li>
</ul>
<h3 id="3-interview-strategy">3️⃣ Interview Strategy<a class="headerlink" href="#3-interview-strategy" title="Permanent link">&para;</a></h3>
<ul>
<li>Problem-solving framework</li>
<li>Communication tips</li>
<li>Code organization</li>
<li>Testing approaches</li>
</ul>
<h3 id="good-references">Good References<a class="headerlink" href="#good-references" title="Permanent link">&para;</a></h3>
<p><a href="https://github.com/ashishps1/awesome-leetcode-resources?tab=readme-ov-file">Technical Interview Github Repo</a></p>
<h2 id="before-we-begin-python-essentials">💻 Before We Begin: Python Essentials<a class="headerlink" href="#before-we-begin-python-essentials" title="Permanent link">&para;</a></h2>
<h3 id="key-python-tools-for-interviews">🔧 Key Python Tools for Interviews<a class="headerlink" href="#key-python-tools-for-interviews" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Common imports you'll need
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from typing import List, Dict, Set</code></pre>
<h3 id="python-specific-pro-tips">🛠️ Python-Specific Pro Tips<a class="headerlink" href="#python-specific-pro-tips" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># 1. List comprehension for cleaner code
squares = [x*x for x in range(10)]

# 2. Default dictionaries for counting
counter = defaultdict(int)

# 3. Built-in sort with custom key
items.sort(key=lambda x: x.value)

# 4. Multiple assignment
x, y = y, x  # Swap values</code></pre>
<h2 id="how-to-use-this-guide">🎯 How to Use This Guide<a class="headerlink" href="#how-to-use-this-guide" title="Permanent link">&para;</a></h2>
<h3 id="learning-path">📚 Learning Path<a class="headerlink" href="#learning-path" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Build the Foundation</strong><ul>
<li>Master Python basics</li>
<li>Understand complexity analysis</li>
<li>Learn core data structures</li>
</ul>
</li>
<li><strong>Pattern Recognition</strong><ul>
<li>Study common patterns</li>
<li>Practice similar problems</li>
<li>Learn pattern variations</li>
</ul>
</li>
<li><strong>Problem Solving</strong><ul>
<li>Apply patterns to new problems</li>
<li>Practice optimization</li>
<li>Work on communication</li>
</ul>
</li>
</ol>
<h3 id="time-management">⏰ Time Management<a class="headerlink" href="#time-management" title="Permanent link">&para;</a></h3>
<ul>
<li>🌱  <strong>Beginner</strong>: 2-3 months of preparation</li>
<li>🌿  <strong>Intermediate</strong>: 1-2 months of focused practice</li>
<li>🌳  <strong>Advanced</strong>: 2-3 weeks of revision</li>
</ul>
<h2 id="lets-get-started">🎮 Let's Get Started!<a class="headerlink" href="#lets-get-started" title="Permanent link">&para;</a></h2>
<h3 id="your-first-steps">🎯 Your First Steps<a class="headerlink" href="#your-first-steps" title="Permanent link">&para;</a></h3>
<ol>
<li>Review Python fundamentals</li>
<li>Start with easy problems</li>
<li>Focus on problem-solving process</li>
<li>Practice explaining your thought process</li>
</ol>
<h3 id="remember">💡 Remember<a class="headerlink" href="#remember" title="Permanent link">&para;</a></h3>
<ul>
<li>Understanding patterns &gt; Memorizing solutions</li>
<li>Practice regularly &gt; Cramming</li>
<li>Clear communication &gt; Perfect code</li>
<li>Learning from mistakes &gt; Getting it right first time</li>
</ul>
<h2 id="common-interview-mistakes-to-avoid">🚨 Common Interview Mistakes to Avoid<a class="headerlink" href="#common-interview-mistakes-to-avoid" title="Permanent link">&para;</a></h2>
<ul>
<li>Jumping into coding without planning</li>
<li>Not clarifying requirements</li>
<li>Ignoring edge cases</li>
<li>Writing unclear/messy code</li>
<li>Not testing your solution</li>
</ul>
<h2 id="success-tips">🌟 Success Tips<a class="headerlink" href="#success-tips" title="Permanent link">&para;</a></h2>
<ul>
<li>Think aloud while solving</li>
<li>Start with brute force, then optimize</li>
<li>Use meaningful variable names</li>
<li>Write clean, modular code</li>
<li>Test with edge cases</li>
</ul>
<p>Ready to begin your journey to interview success? Let's dive into our first topic: Algorithmic Complexity and Big-O Notation! 🚀</p>
<h1 id="algorithmic-complexity-big-o-guide">🎯 Algorithmic Complexity &amp; Big-O Guide<a class="headerlink" href="#algorithmic-complexity-big-o-guide" title="Permanent link">&para;</a></h1>
<h2 id="visual-complexity-chart">🎨 Visual Complexity Chart<a class="headerlink" href="#visual-complexity-chart" title="Permanent link">&para;</a></h2>
<p>Excellent  O(1) ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
Good      O(log n) ▁▁▁▁▂▂▂▂▂▂▂▂▂▂▂▂
Fair      O(n) ▁▁▁▂▂▂▃▃▃▄▄▄▅▅▅▆▆▆
Bad       O(n²) ▁▂▃▄▅▆▇█████████████
Horrible  O(2ⁿ) ▁▂▅█████████████████</p>
<p><img alt="Big-O CheatSheet" src="https://i.postimg.cc/wjrdT9y3/temp-Image-Qsq7-Dm.avif" />
<a href="https://blog.algomaster.io/p/57bd4963-462f-4294-a972-4012691fc729">blog.algomaster.io</a></p>
<h2 id="what-is-algorithmic-complexity">🎮 What is Algorithmic Complexity?<a class="headerlink" href="#what-is-algorithmic-complexity" title="Permanent link">&para;</a></h2>
<p>Think of algorithmic complexity as your code's "price tag" in terms of:</p>
<ul>
<li>⏱️ Time (how long it takes to run)</li>
<li>💾 Space (how much memory it needs)</li>
</ul>
<h3 id="why-should-you-care">🎯 Why Should You Care?<a class="headerlink" href="#why-should-you-care" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Example 1: O(n) - Linear Time
def find_max_linear(arr):  # 😊 Good for small lists
    return max(arr)

# Example 2: O(n²) - Quadratic Time
def find_max_nested(arr):  # 😰 Terrible for large lists
    max_val = arr[0]
    for i in arr:
        for j in arr:  # Unnecessary nested loop!
            if i &gt; max_val:
                max_val = i
    return max_val</code></pre>
<h2 id="understanding-big-o-notation">🚀 Understanding Big-O Notation<a class="headerlink" href="#understanding-big-o-notation" title="Permanent link">&para;</a></h2>
<h3 id="common-time-complexities-from-best-to-worst">📊 Common Time Complexities (From Best to Worst)<a class="headerlink" href="#common-time-complexities-from-best-to-worst" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>O(1) - Constant Time</strong>  🌟
<pre class="highlight"><code class="language-python">def get_first(arr):
    return arr[0] if arr else None</code></pre></li>
<li>Like finding a book when you know exactly where it is</li>
<li>
<p>Examples: Hash table access, array index access</p>
</li>
<li>
<p><strong>O(log n) - Logarithmic Time</strong> ✨
<pre class="highlight"><code class="language-python">def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left &lt;= right:
        mid = (left + right) // 2
        if arr[mid] == target: return mid
        if arr[mid] &lt; target: left = mid + 1
        else: right = mid - 1
    return -1</code></pre></p>
</li>
<li>Like finding a word in a dictionary</li>
<li>Examples: Binary search, balanced BST operations</li>
<li><strong>O(n) - Linear Time</strong> 👍
<pre class="highlight"><code class="language-python">def linear_search(arr, target):
    return any(x == target for x in arr)</code></pre></li>
<li>Like reading every page in a book</li>
<li>Examples: Array traversal, linear search</li>
<li><strong>O(n log n) - Log-Linear Time</strong> 🆗
<pre class="highlight"><code class="language-python">def merge_sort(arr):
    if len(arr) &lt;= 1: return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), 
                merge_sort(arr[mid:]))</code></pre></li>
<li>Like sorting a deck of cards efficiently</li>
<li>Examples: Merge sort, quick sort (average case)</li>
<li><strong>O(n²) - Quadratic Time</strong> 😰
<pre class="highlight"><code class="language-python">def bubble_sort(arr):
    for i in range(len(arr)):
        for j in range(len(arr) - 1):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]</code></pre></li>
<li>Like comparing every page with every other page</li>
<li>Examples: Nested loops, bubble sort</li>
<li><strong>O(2ⁿ) - Exponential Time</strong> 😱
<pre class="highlight"><code class="language-python">def fibonacci_recursive(n):
    if n &lt;= 1: return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)</code></pre></li>
<li>Like trying every possible combination</li>
<li>Examples: Recursive Fibonacci, power set</li>
</ol>
<h3 id="common-space-complexities">🎮 Common Space Complexities<a class="headerlink" href="#common-space-complexities" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>O(1) - Constant Space</strong><ul>
<li>Fixed amount of extra space</li>
<li>Example: Simple variables, fixed-size arrays</li>
</ul>
</li>
<li><strong>O(n) - Linear Space</strong><ul>
<li>Space grows linearly with input</li>
<li>Example: Creating a new array of size n</li>
</ul>
</li>
<li><strong>O(n²) - Quadratic Space</strong><ul>
<li>Space grows quadratically</li>
<li>Example: 2D array/matrix of size n×n</li>
</ul>
</li>
</ol>
<h2 id="big-o-cheat-sheet-for-common-data-structures">🎯 Big-O Cheat Sheet for Common Data Structures<a class="headerlink" href="#big-o-cheat-sheet-for-common-data-structures" title="Permanent link">&para;</a></h2>
<h3 id="array-operations">Array Operations<a class="headerlink" href="#array-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Access: O(1)
arr[5]  # Direct access by index

# Search: O(n)
target in arr  # Linear search

# Insertion/Deletion at end: O(1)
arr.append(item)  # Add to end
arr.pop()  # Remove from end

# Insertion/Deletion at middle: O(n)
arr.insert(2, item)  # Need to shift elements</code></pre>
<h3 id="dictionaryhash-table-operations">Dictionary/Hash Table Operations<a class="headerlink" href="#dictionaryhash-table-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Access/Insert/Delete: O(1) average
dict_example = {}
dict_example['key'] = 'value'  # O(1)
value = dict_example['key']    # O(1)
del dict_example['key']        # O(1)</code></pre>
<h2 id="pro-tips-for-optimization">🎮 Pro Tips for Optimization<a class="headerlink" href="#pro-tips-for-optimization" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Avoid Nested Loops When Possible</strong>
<pre class="highlight"><code class="language-python"># Bad: O(n²)
for i in range(n):
    for j in range(n):
        # do something

# Better: O(n)
seen = set()
for i in range(n):
    if i in seen:
        # do something</code></pre></li>
<li><strong>Use Built-in Data Structures Wisely</strong>
<pre class="highlight"><code class="language-python"># Lists vs Sets for lookups
numbers = [1, 2, 3, 4, 5]
number_set = set(numbers)

# Bad: O(n)
5 in numbers

# Good: O(1)
5 in number_set</code></pre></li>
<li><strong>Cache Results When Possible</strong>
<pre class="highlight"><code class="language-python">from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n &lt; 2: return n
    return fibonacci(n-1) + fibonacci(n-2)</code></pre></li>
</ol>
<h2 id="practice-problems">🎯 Practice Problems<a class="headerlink" href="#practice-problems" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p><strong>Identify the Time Complexity</strong>
<pre class="highlight"><code class="language-python">def mystery_function(n):
    result = 0
    for i in range(n):
        for j in range(i, n):
            result += 1
    return result

# What's the time complexity? 
# (Answer: O(n²))</code></pre>
Remember: The best algorithm is often a balance between:</p>
</li>
<li>
<p>⏱️ Time complexity</p>
</li>
<li>💾 Space complexity</li>
<li>🎯 Code readability</li>
<li>🔧 Maintainability</li>
</ol>
<h1 id="bit-manipulation-sorting-algorithms">🧮 Bit Manipulation &amp; Sorting Algorithms<a class="headerlink" href="#bit-manipulation-sorting-algorithms" title="Permanent link">&para;</a></h1>
<h2 id="part-1-bit-manipulation">Part 1: 🔢 Bit Manipulation<a class="headerlink" href="#part-1-bit-manipulation" title="Permanent link">&para;</a></h2>
<h3 id="why-bit-manipulation">🎯 Why Bit Manipulation?<a class="headerlink" href="#why-bit-manipulation" title="Permanent link">&para;</a></h3>
<ul>
<li>⚡ More efficient than arithmetic operations</li>
<li>🚀 Essential for optimization problems</li>
<li>💻 Crucial for low-level programming</li>
<li>📝 Common in technical interviews</li>
</ul>
<h3 id="basic-operators">🛠️ Basic Operators<a class="headerlink" href="#basic-operators" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># AND (&amp;): 1 if both bits are 1
print(5 &amp; 3)  # 5(101) &amp; 3(011) = 1(001)

# OR (|): 1 if either bit is 1
print(5 | 3)  # 5(101) | 3(011) = 7(111)

# XOR (^): 1 if bits are different
print(5 ^ 3)  # 5(101) ^ 3(011) = 6(110)

# NOT (~): Inverts all bits
print(~5)     # 5(101) -&gt; -(110)

# Left Shift (&lt;&lt;): Multiply by 2^n
print(5 &lt;&lt; 1) # 5(101) &lt;&lt; 1 = 10(1010)

# Right Shift (&gt;&gt;): Divide by 2^n
print(5 &gt;&gt; 1) # 5(101) &gt;&gt; 1 = 2(010)</code></pre>
<h3 id="common-bit-manipulation-tricks">🎮 Common Bit Manipulation Tricks<a class="headerlink" href="#common-bit-manipulation-tricks" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Check if Number is Even/Odd</strong>
<pre class="highlight"><code class="language-python">def is_even(n: int) -&gt; bool:
    return not (n &amp; 1)  # Last bit is 0 for even numbers</code></pre></li>
<li><strong>Multiply/Divide by Powers of 2</strong>
<pre class="highlight"><code class="language-python">def multiply_by_2(n: int) -&gt; int:
    return n &lt;&lt; 1  # Left shift = multiply by 2

def divide_by_2(n: int) -&gt; int:
    return n &gt;&gt; 1  # Right shift = divide by 2</code></pre></li>
<li><strong>Set/Clear/Toggle Bits</strong>
<pre class="highlight"><code class="language-python">def set_bit(n: int, pos: int) -&gt; int:
    return n | (1 &lt;&lt; pos)

def clear_bit(n: int, pos: int) -&gt; int:
    return n &amp; ~(1 &lt;&lt; pos)

def toggle_bit(n: int, pos: int) -&gt; int:
    return n ^ (1 &lt;&lt; pos)</code></pre></li>
<li><strong>Check if Bit is Set</strong>
<pre class="highlight"><code class="language-python">def is_bit_set(n: int, pos: int) -&gt; bool:
    return bool(n &amp; (1 &lt;&lt; pos))</code></pre></li>
</ol>
<h3 id="interview-tips-for-bit-manipulation">🎯 Interview Tips for Bit Manipulation<a class="headerlink" href="#interview-tips-for-bit-manipulation" title="Permanent link">&para;</a></h3>
<ol>
<li>Always visualize bits on paper</li>
<li>Test with small numbers first</li>
<li>Consider edge cases (negatives, zero)</li>
<li>Explain your logic step by step</li>
</ol>
<h2 id="part-2-sorting-algorithms">Part 2: 🔄 Sorting Algorithms<a class="headerlink" href="#part-2-sorting-algorithms" title="Permanent link">&para;</a></h2>
<h3 id="comparison-overview">📊 Comparison Overview<a class="headerlink" href="#comparison-overview" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">sorting_algos = {
    'Bubble Sort':    {'Time': 'O(n²)', 'Space': 'O(1)', 'Stable': True},
    'Selection Sort': {'Time': 'O(n²)', 'Space': 'O(1)', 'Stable': False},
    'Insertion Sort': {'Time': 'O(n²)', 'Space': 'O(1)', 'Stable': True},
    'Merge Sort':     {'Time': 'O(n log n)', 'Space': 'O(n)', 'Stable': True},
    'Quick Sort':     {'Time': 'O(n log n)', 'Space': 'O(log n)', 'Stable': False},
    'Heap Sort':      {'Time': 'O(n log n)', 'Space': 'O(1)', 'Stable': False}
}</code></pre>
<h3 id="simple-sorting-algorithms">🎯 Simple Sorting Algorithms<a class="headerlink" href="#simple-sorting-algorithms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Bubble Sort</strong>  (The Beginner's Sort)
<pre class="highlight"><code class="language-python">def bubble_sort(arr: list) -&gt; list:
    n = len(arr)
    for i in range(n):
        # Flag for optimization
        swapped = False

        # Last i elements are already sorted
        for j in range(0, n-i-1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True

        # If no swaps occurred, array is sorted
        if not swapped:
            break
    return arr

# When to use: Small arrays or nearly sorted data
# Pros: Simple to implement, in-place sorting
# Cons: Very inefficient for large datasets</code></pre></li>
<li><strong>Selection Sort</strong> (The Minimalist's Sort)
<pre class="highlight"><code class="language-python">def selection_sort(arr: list) -&gt; list:
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] &lt; arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# When to use: Small arrays with expensive writes
# Pros: Minimum number of swaps
# Cons: Always makes O(n²) comparisons</code></pre></li>
<li><strong>Insertion Sort</strong> (The Adaptive Sort)
<pre class="highlight"><code class="language-python">def insertion_sort(arr: list) -&gt; list:
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j &gt;= 0 and arr[j] &gt; key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

# When to use: Small datasets or nearly sorted arrays
# Pros: Adaptive, stable, and great for small data
# Cons: Still O(n²) in worst case</code></pre></li>
</ol>
<h3 id="advanced-sorting-algorithms">🚀 Advanced Sorting Algorithms<a class="headerlink" href="#advanced-sorting-algorithms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Merge Sort</strong> (The Reliable Sort)
<pre class="highlight"><code class="language-python">def merge_sort(arr: list) -&gt; list:
    if len(arr) &lt;= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left: list, right: list) -&gt; list:
    result = []
    i = j = 0

    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# When to use: Large datasets where stability matters
# Pros: Stable, predictable O(n log n)
# Cons: Requires O(n) extra space</code></pre></li>
<li><strong>Quick Sort</strong> (The Practical Sort)
<pre class="highlight"><code class="language-python">def quick_sort(arr: list) -&gt; list:
    if len(arr) &lt;= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]

    return quick_sort(left) + middle + quick_sort(right)

# When to use: General-purpose sorting
# Pros: Usually fastest in practice
# Cons: Unstable, bad worst-case O(n²)</code></pre></li>
<li><strong>Heap Sort</strong> (The Memory-Efficient Sort)
<pre class="highlight"><code class="language-python">def heapify(arr: list, n: int, i: int):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left &lt; n and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; n and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr: list) -&gt; list:
    n = len(arr)

    # Build max heap
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements from heap
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

    return arr

# When to use: When space is a premium
# Pros: In-place, O(n log n) guaranteed
# Cons: Unstable, poor cache performance</code></pre></li>
</ol>
<h3 id="special-purpose-sorting-algorithms">🎨 Special Purpose Sorting Algorithms<a class="headerlink" href="#special-purpose-sorting-algorithms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Shell Sort</strong>  (The Gap Sort)
<pre class="highlight"><code class="language-python">def shell_sort(arr: list) -&gt; list:
    n = len(arr)
    gap = n // 2

    while gap &gt; 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            while j &gt;= gap and arr[j-gap] &gt; temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2

    return arr

# When to use: Medium-sized arrays
# Pros: Adaptive, handles partially sorted arrays well
# Cons: Complex gap sequence selection</code></pre></li>
<li><strong>Counting Sort</strong> (The Integer Sort)
<pre class="highlight"><code class="language-python">def counting_sort(arr: list) -&gt; list:
    if not arr:
        return arr

    # Find range of array elements
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    # Create counting array and output array
    count = [0] * range_val
    output = [0] * len(arr)

    # Store count of each element
    for num in arr:
        count[num - min_val] += 1

    # Modify count array to store actual positions
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Build output array
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

# When to use: Integer arrays with known range
# Pros: O(n) for known range integers
# Cons: Requires extra space proportional to range</code></pre></li>
<li><strong>Radix Sort</strong> (The Digit Sort)
<pre class="highlight"><code class="language-python">def counting_sort_for_radix(arr: list, exp: int) -&gt; list:
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # Store count of occurrences
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    # Change count[i] to contain actual position
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build output array
    i = n - 1
    while i &gt;= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # Copy output array to arr
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr: list) -&gt; list:
    if not arr:
        return arr

    # Find maximum number to know number of digits
    max_val = max(arr)

    # Do counting sort for every digit
    exp = 1
    while max_val // exp &gt; 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10

    return arr

# When to use: Integer arrays with fixed number of digits
# Pros: Linear time possible for fixed-length integers
# Cons: Only works with integers, uses extra space</code></pre></li>
<li><strong>Bucket Sort</strong> (The Distribution Sort)
<pre class="highlight"><code class="language-python">def bucket_sort(arr: list, num_buckets: int = 10) -&gt; list:
    if not arr:
        return arr

    # Find range of values
    max_val, min_val = max(arr), min(arr)

    # Create buckets
    range_val = (max_val - min_val) / num_buckets
    buckets = [[] for _ in range(num_buckets)]

    # Put elements in buckets
    for num in arr:
        if num == max_val:
            bucket_idx = num_buckets - 1
        else:
            bucket_idx = int((num - min_val) / range_val)
        buckets[bucket_idx].append(num)

    # Sort individual buckets
    for bucket in buckets:
        bucket.sort()  # Using TimSort internally in Python

    # Concatenate all buckets into arr
    return [num for bucket in buckets for num in bucket]

# When to use: Uniformly distributed data over a range
# Pros: Linear time possible for uniform distribution
# Cons: Requires uniform distribution for efficiency</code></pre></li>
<li><strong>Tim Sort</strong> (Python's Built-in Sort)
<pre class="highlight"><code class="language-python"># Python's built-in sort uses TimSort
def tim_sort_example(arr: list) -&gt; list:
    return sorted(arr)  # Uses TimSort internally

# When to use: General purpose sorting
# Pros: Excellent performance on real-world data
# Cons: Complex implementation, requires extra space</code></pre></li>
</ol>
<h3 id="best-practices-for-each-algorithm">🎯 Best Practices for Each Algorithm<a class="headerlink" href="#best-practices-for-each-algorithm" title="Permanent link">&para;</a></h3>
<h2 id="simple-sorts-on2">Simple Sorts (O(n²))<a class="headerlink" href="#simple-sorts-on2" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Bubble Sort</strong>: Nearly sorted data, teaching purposes</li>
<li><strong>Selection Sort</strong>: Small arrays, minimizing swaps</li>
<li><strong>Insertion Sort</strong>: Small arrays, online sorting</li>
</ul>
<h2 id="efficient-sorts-on-log-n">Efficient Sorts (O(n log n))<a class="headerlink" href="#efficient-sorts-on-log-n" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Merge Sort</strong>: Stable sorting needed, linked lists</li>
<li><strong>Quick Sort</strong>: General purpose, arrays</li>
<li><strong>Heap Sort</strong>: Memory constrained, guaranteed O(n log n)</li>
</ul>
<h2 id="special-purpose-sorts">Special Purpose Sorts<a class="headerlink" href="#special-purpose-sorts" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Shell Sort</strong>: Medium-sized arrays, partially sorted data</li>
<li><strong>Counting Sort</strong>: Small range integers</li>
<li><strong>Radix Sort</strong>: Fixed-length integers, like phone numbers</li>
<li><strong>Bucket Sort</strong>: Uniformly distributed floating-point numbers</li>
<li><strong>Tim Sort</strong>: When you need the best of both worlds (stable &amp; efficient)</li>
</ul>
<h3 id="choosing-the-right-sort">🎮 Choosing the Right Sort<a class="headerlink" href="#choosing-the-right-sort" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Consider Your Data</strong><ul>
<li>Size of dataset</li>
<li>Data type (integers, floating-point, strings)</li>
<li>Data distribution</li>
<li>Range of values</li>
</ul>
</li>
<li><strong>Consider Your Constraints</strong><ul>
<li>Memory limitations</li>
<li>Stability requirements</li>
<li>Whether data is streaming (online)</li>
<li>Performance requirements</li>
</ul>
</li>
<li><strong>General Guidelines</strong><ul>
<li>Small dataset (n &lt; 50): Insertion Sort</li>
<li>Memory constrained: Heap Sort</li>
<li>Stability required: Merge Sort</li>
<li>General purpose: Quick Sort or Tim Sort</li>
<li>Integer data: Counting Sort or Radix Sort</li>
</ul>
</li>
</ol>
<p>Remember: In Python, use the built-in  <code>sort()</code>  or  <code>sorted()</code>  for best performance! They use TimSort, which is optimized for real-world data patterns. 🚀</p>
<h1 id="linked-lists-dummy-node-technique-guide">🔗 Linked Lists &amp; Dummy Node Technique Guide<a class="headerlink" href="#linked-lists-dummy-node-technique-guide" title="Permanent link">&para;</a></h1>
<h2 id="understanding-linked-lists">📘 Understanding Linked Lists<a class="headerlink" href="#understanding-linked-lists" title="Permanent link">&para;</a></h2>
<h3 id="what-is-a-linked-list">🎯 What is a Linked List?<a class="headerlink" href="#what-is-a-linked-list" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next</code></pre>
<h3 id="types-of-linked-lists">📊 Types of Linked Lists<a class="headerlink" href="#types-of-linked-lists" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Singly Linked List</strong>
<pre class="highlight"><code class="language-python"># 1 -&gt; 2 -&gt; 3 -&gt; None
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)</code></pre></li>
<li><strong>Doubly Linked List</strong>
<pre class="highlight"><code class="language-python">class DoublyListNode:
    def __init__(self, val=0, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev</code></pre></li>
<li><strong>Circular Linked List</strong>
<pre class="highlight"><code class="language-python"># 1 -&gt; 2 -&gt; 3 -&gt; 1 (cycles back)
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = head  # Creates cycle</code></pre></li>
</ol>
<h2 id="core-implementation-options">📚 Core Implementation Options<a class="headerlink" href="#core-implementation-options" title="Permanent link">&para;</a></h2>
<h3 id="1-using-collectionsdeque">1️⃣ Using collections.deque<a class="headerlink" href="#1-using-collectionsdeque" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from collections import deque

# Creating linked lists
llist = deque()              # Empty list
llist = deque([1, 2, 3])     # From iterable
llist = deque('abc')         # From string

# Common Operations
llist.append(x)      # Add to right
llist.appendleft(x)  # Add to left
llist.pop()          # Remove from right
llist.popleft()      # Remove from left</code></pre>
<h3 id="2-custom-linked-list-implementation">2️⃣ Custom Linked List Implementation<a class="headerlink" href="#2-custom-linked-list-implementation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return str(self.data)

class LinkedList:
    def __init__(self, nodes=None):
        self.head = None
        if nodes:
            node = Node(data=nodes.pop(0))
            self.head = node
            for elem in nodes:
                node.next = Node(data=elem)
                node = node.next

    def __repr__(self):
        nodes = []
        curr = self.head
        while curr:
            nodes.append(str(curr.data))
            curr = curr.next
        return " -&gt; ".join(nodes + ["None"])

    def __iter__(self):
        node = self.head
        while node:
            yield node
            node = node.next</code></pre>
<h2 id="common-pattern-templates">🎯 Common Pattern Templates<a class="headerlink" href="#common-pattern-templates" title="Permanent link">&para;</a></h2>
<h3 id="1-two-pointer-technique-template">1️⃣ Two-Pointer Technique Template<a class="headerlink" href="#1-two-pointer-technique-template" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def two_pointer_template(head):
    # Initialize pointers
    slow = fast = head

    # Move pointers
    while fast and fast.next:
        slow = slow.next           # Move one step
        fast = fast.next.next      # Move two steps

        # Optional: Detection logic here
        if slow == fast:
            return True  # Or other logic

    return False</code></pre>
<h3 id="2-reverse-list-template">2️⃣ Reverse List Template<a class="headerlink" href="#2-reverse-list-template" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def reverse_template(head):
    prev = None
    current = head

    while current:
        # Store next
        next_node = current.next
        # Reverse pointer
        current.next = prev
        # Move prev and current
        prev = current
        current = next_node

    return prev  # New head</code></pre>
<h3 id="3-merge-lists-template">3️⃣ Merge Lists Template<a class="headerlink" href="#3-merge-lists-template" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def merge_template(l1, l2):
    dummy = Node(0)
    current = dummy

    while l1 and l2:
        if l1.val &lt;= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    # Attach remaining nodes
    current.next = l1 or l2
    return dummy.next</code></pre>
<h2 id="essential-operations-templates">🛠️ Essential Operations Templates<a class="headerlink" href="#essential-operations-templates" title="Permanent link">&para;</a></h2>
<h3 id="1-node-insertion">1️⃣ Node Insertion<a class="headerlink" href="#1-node-insertion" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def insert_operations():
    # Insert at beginning - O(1)
    def add_first(self, node):
        node.next = self.head
        self.head = node

    # Insert at end - O(n)
    def add_last(self, node):
        if not self.head:
            self.head = node
            return
        for current in self:
            pass
        current.next = node

    # Insert after node - O(n)
    def add_after(self, target_data, new_node):
        if not self.head:
            raise Exception("List is empty")

        for node in self:
            if node.data == target_data:
                new_node.next = node.next
                node.next = new_node
                return

        raise Exception("Node not found")</code></pre>
<h3 id="2-node-deletion">2️⃣ Node Deletion<a class="headerlink" href="#2-node-deletion" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def removal_template(self, target):
    if not self.head:
        raise Exception("List is empty")

    # Handle head removal
    if self.head.data == target:
        self.head = self.head.next
        return

    # Handle other removals
    current = self.head
    while current.next:
        if current.next.data == target:
            current.next = current.next.next
            return
        current = current.next

    raise Exception("Node not found")</code></pre>
<h2 id="the-dummy-node-technique">🎯 The Dummy Node Technique<a class="headerlink" href="#the-dummy-node-technique" title="Permanent link">&para;</a></h2>
<h3 id="why-use-dummy-nodes">🔑 Why Use Dummy Nodes?<a class="headerlink" href="#why-use-dummy-nodes" title="Permanent link">&para;</a></h3>
<ol>
<li>Simplifies edge cases</li>
<li>Avoids null pointer exceptions</li>
<li>Makes code cleaner and more uniform</li>
<li>Particularly useful for:<ul>
<li>List manipulation</li>
<li>Merging lists</li>
<li>Removing elements</li>
<li>Complex operations</li>
</ul>
</li>
</ol>
<h3 id="dummy-node-pattern-template">📝 Dummy Node Pattern Template<a class="headerlink" href="#dummy-node-pattern-template" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def linked_list_operation(head: ListNode) -&gt; ListNode:
    # Create dummy node
    dummy = ListNode(0)
    dummy.next = head

    # Work with dummy node
    current = dummy
    while current.next:
        # Perform operations
        current = current.next

    # Return modified list
    return dummy.next</code></pre>
<h3 id="advanced-techniques-with-dummy-nodes">🎯 Advanced Techniques with Dummy Nodes<a class="headerlink" href="#advanced-techniques-with-dummy-nodes" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Multiple Dummy Nodes</strong>
<pre class="highlight"><code class="language-python">def oddEvenList(head: ListNode) -&gt; ListNode:
    if not head:
        return None

    # Two dummy nodes for odd and even lists
    odd_dummy = ListNode(0)
    even_dummy = ListNode(0)
    odd = odd_dummy
    even = even_dummy

    is_odd = True
    current = head

    while current:
        if is_odd:
            odd.next = current
            odd = odd.next
        else:
            even.next = current
            even = even.next
        is_odd = not is_odd
        current = current.next

    # Connect odd and even lists
    odd.next = even_dummy.next
    even.next = None
    return odd_dummy.next</code></pre></li>
<li><strong>Dummy Node w/ Fast/Slower Pointers</strong>
<pre class="highlight"><code class="language-python">def hasCycle(head: ListNode) -&gt; bool:
    dummy = ListNode(0)
    dummy.next = head
    slow = dummy
    fast = dummy

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False</code></pre></li>
</ol>
<h3 id="interview-tips">🎯 Interview Tips<a class="headerlink" href="#interview-tips" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>When to Use Dummy Nodes</strong><ul>
<li>List modification required</li>
<li>Head might change</li>
<li>Multiple pointer manipulation</li>
<li>Merging or splitting lists</li>
</ul>
</li>
<li><strong>Common Patterns</strong>
<pre class="highlight"><code class="language-python"># Pattern 1: Basic Dummy Node
dummy = ListNode(0)
dummy.next = head
current = dummy

# Pattern 2: Multiple Pointers
dummy = ListNode(0)
slow = fast = dummy

# Pattern 3: Multiple Dummies
dummy1 = ListNode(0)
dummy2 = ListNode(0)</code></pre></li>
<li><strong>Edge Cases to Consider</strong><ul>
<li>Empty list</li>
<li>Single node</li>
<li>Two nodes</li>
<li>Cycles in list</li>
<li>Duplicate values</li>
</ul>
</li>
</ol>
<h3 id="practice-problems_1">🎮 Practice Problems<a class="headerlink" href="#practice-problems_1" title="Permanent link">&para;</a></h3>
<ol>
<li>Reverse Linked List</li>
<li>Detect Cycle</li>
<li>Find Middle Node</li>
<li>Remove Duplicates</li>
<li>Merge K Sorted Lists</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always handle edge cases first</li>
<li>Consider using dummy nodes for cleaner code</li>
<li>Test with small examples</li>
<li>Draw the list operations on paper</li>
<li>Keep track of all pointers carefully</li>
</ul>
<h1 id="stack-queue-implementations-in-python">🔄 Stack &amp; Queue Implementations in Python<a class="headerlink" href="#stack-queue-implementations-in-python" title="Permanent link">&para;</a></h1>
<h2 id="stack-implementations">📚 Stack Implementations<a class="headerlink" href="#stack-implementations" title="Permanent link">&para;</a></h2>
<h3 id="1-using-list-as-stack">1️⃣ Using List as Stack<a class="headerlink" href="#1-using-list-as-stack" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class ListStack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        raise IndexError("Stack is empty")

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]
        raise IndexError("Stack is empty")

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)</code></pre>
<h3 id="2-using-collectionsdeque-as-stack">2️⃣ Using Collections.deque as Stack<a class="headerlink" href="#2-using-collectionsdeque-as-stack" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from collections import deque

class DequeStack:
    def __init__(self):
        self.stack = deque()

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        raise IndexError("Stack is empty")

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]
        raise IndexError("Stack is empty")

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)</code></pre>
<h3 id="common-stack-pattern-templates">Common Stack Pattern Templates<a class="headerlink" href="#common-stack-pattern-templates" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Basic Stack Operations Pattern</strong>
<pre class="highlight"><code class="language-python">def stack_pattern(data):
    stack = []  # or deque()

    for item in data:
        # Process current item
        while stack and some_condition(stack[-1], item):
            # Do something with stack.pop()
            pass
        stack.append(item)

    return result</code></pre></li>
<li><strong>Monotonic Stack Pattern</strong>
<pre class="highlight"><code class="language-python">def monotonic_stack_pattern(arr):
    stack = []  # stores indices usually
    result = [0] * len(arr)  # or any default value

    for i in range(len(arr)):
        # For increasing stack (next smaller)
        while stack and arr[stack[-1]] &gt; arr[i]:
            popped = stack.pop()
            result[popped] = i - popped  # or any calculation
        stack.append(i)

    return result</code></pre></li>
</ol>
<h2 id="queue-implementations">📝 Queue Implementations<a class="headerlink" href="#queue-implementations" title="Permanent link">&para;</a></h2>
<h3 id="1-using-collectionsdeque-as-queue">1️⃣ Using Collections.deque as Queue<a class="headerlink" href="#1-using-collectionsdeque-as-queue" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from collections import deque

class DequeQueue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.popleft()
        raise IndexError("Queue is empty")

    def front(self):
        if not self.is_empty():
            return self.queue[0]
        raise IndexError("Queue is empty")

    def rear(self):
        if not self.is_empty():
            return self.queue[-1]
        raise IndexError("Queue is empty")

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)</code></pre>
<h3 id="2-queue-implementation">2️⃣ Queue Implementation<a class="headerlink" href="#2-queue-implementation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from queue import Queue

# Thread-safe queue usage
queue = Queue()
queue.put(item)      # Enqueue
item = queue.get()   # Dequeue
size = queue.qsize() # Size
empty = queue.empty()</code></pre>
<h2 id="common-implementation-patterns">🎯 Common Implementation Patterns<a class="headerlink" href="#common-implementation-patterns" title="Permanent link">&para;</a></h2>
<h3 id="pattern-1-lifo-stack-pattern">Pattern 1: LIFO Stack Pattern<a class="headerlink" href="#pattern-1-lifo-stack-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def stack_pattern(data):
    stack = []  # or deque()

    for item in data:
        # Process current item
        while stack and condition(stack[-1], item):
            # Process stack.pop()
            pass
        stack.append(item)

    return result</code></pre>
<h3 id="pattern-2-fifo-queue-pattern">Pattern 2: FIFO Queue Pattern<a class="headerlink" href="#pattern-2-fifo-queue-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def queue_pattern(start_node):
    queue = deque([start_node])
    seen = {start_node}

    while queue:
        current = queue.popleft()
        # Process current node

        for neighbor in get_neighbors(current):
            if neighbor not in seen:
                seen.add(neighbor)
                queue.append(neighbor)</code></pre>
<h2 id="key-operations-complexities">🔑 Key Operations &amp; Complexities<a class="headerlink" href="#key-operations-complexities" title="Permanent link">&para;</a></h2>
<h3 id="stack-operations">Stack Operations<a class="headerlink" href="#stack-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">operations = {
    'push':    'O(1)',  # Add to top
    'pop':     'O(1)',  # Remove from top
    'peek':    'O(1)',  # View top element
    'isEmpty': 'O(1)',  # Check if empty
    'size':    'O(1)'   # Get number of elements
}</code></pre>
<h3 id="queue-operations">Queue Operations<a class="headerlink" href="#queue-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">operations = {
    'enqueue': 'O(1)',  # Add to back
    'dequeue': 'O(1)',  # Remove from front
    'front':   'O(1)',  # View front element
    'isEmpty': 'O(1)',  # Check if empty
    'size':    'O(1)'   # Get number of elements
}</code></pre>
<h2 id="when-to-use-what">💡When to Use What<a class="headerlink" href="#when-to-use-what" title="Permanent link">&para;</a></h2>
<h3 id="use-stack-when">Use Stack When:<a class="headerlink" href="#use-stack-when" title="Permanent link">&para;</a></h3>
<ul>
<li>Need LIFO (Last In, First Out) behavior</li>
<li>Tracking state changes (undo/redo)</li>
<li>Parse expressions (parentheses matching)</li>
<li>Function call management</li>
<li>DFS implementation</li>
</ul>
<h3 id="use-queue-when">Use Queue When:<a class="headerlink" href="#use-queue-when" title="Permanent link">&para;</a></h3>
<ul>
<li>Need FIFO (First In, First Out) behavior</li>
<li>Order must be preserved</li>
<li>BFS implementation</li>
<li>Task scheduling</li>
<li>Resource pooling</li>
</ul>
<h2 id="implementation-comparison">🎯 Implementation Comparison<a class="headerlink" href="#implementation-comparison" title="Permanent link">&para;</a></h2>
<h3 id="stack-implementation-comparison">Stack Implementation Comparison<a class="headerlink" href="#stack-implementation-comparison" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code># List as Stack
- Pros: Simple, built-in, good for small data
- Cons: Potential memory reallocation for large data
- Use when: Simple stack operations needed

# Deque as Stack
- Pros: Efficient memory usage, thread-safe
- Cons: Slightly more complex than list
- Use when: Large data or thread safety needed</code></pre>
<h3 id="queue-implementation-comparison">Queue Implementation Comparison<a class="headerlink" href="#queue-implementation-comparison" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code># Deque as Queue
- Pros: O(1) operations, efficient memory
- Cons: Not fixed size
- Use when: General queue operations needed

# Queue
- Pros: Memory efficient, fixed size
- Cons: More complex implementation
- Use when: Fixed size buffer needed</code></pre>
<h2 id="practice-problem-tips">🎮 Practice Problem Tips<a class="headerlink" href="#practice-problem-tips" title="Permanent link">&para;</a></h2>
<ol>
<li>Always clarify:<ul>
<li>Is there a size limit?</li>
<li>What happens on empty pop/dequeue?</li>
<li>Should operations be thread-safe?</li>
<li>What type of elements to store?</li>
</ul>
</li>
<li>Consider:<ul>
<li>Time/Space complexity requirements</li>
<li>Concurrency needs</li>
<li>Error handling approach</li>
<li>Edge cases</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Use  <code>collections.deque</code>  for efficient implementation</li>
<li>Consider thread-safety needs before choosing implementation</li>
<li>Watch for operation order dependence</li>
<li>Handle edge cases explicitly</li>
</ul>
<h1 id="hash-tables-in-python-dictionaries">🗃️ Hash Tables in Python (Dictionaries)<a class="headerlink" href="#hash-tables-in-python-dictionaries" title="Permanent link">&para;</a></h1>
<h2 id="basic-implementation">📚 Basic Implementation<a class="headerlink" href="#basic-implementation" title="Permanent link">&para;</a></h2>
<h3 id="1-dictionary-creation">1️⃣ Dictionary Creation<a class="headerlink" href="#1-dictionary-creation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Method 1: Using curly braces
hash_map = {
    'key1': 'value1',
    'key2': 'value2'
}

# Method 2: Using dict() constructor
hash_map = dict(
    key1='value1',
    key2='value2'
)

# Method 3: From list of tuples
hash_map = dict([
    ('key1', 'value1'),
    ('key2', 'value2')
])

# Method 4: Empty dictionary
hash_map = {}</code></pre>
<h3 id="2-basic-operations">2️⃣ Basic Operations<a class="headerlink" href="#2-basic-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Access Operations - O(1) average case
hash_map['key'] = 'value'  # Insert/Update
value = hash_map['key']    # Access
del hash_map['key']        # Delete

# Safe Access
value = hash_map.get('key', default_value)  # Returns default_value if key not found

# Check Existence - O(1)
if 'key' in hash_map:
    # Key exists
    pass</code></pre>
<h2 id="common-hash-table-patterns">🎯 Common Hash Table Patterns<a class="headerlink" href="#common-hash-table-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-counting-pattern">1️⃣ Counting Pattern<a class="headerlink" href="#1-counting-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def counting_pattern(items):
    counter = {}

    # Count occurrences
    for item in items:
        counter[item] = counter.get(item, 0) + 1

    return counter

# Alternative using defaultdict
from collections import defaultdict

def counting_with_defaultdict(items):
    counter = defaultdict(int)
    for item in items:
        counter[item] += 1
    return counter</code></pre>
<h3 id="2-grouping-pattern">2️⃣ Grouping Pattern<a class="headerlink" href="#2-grouping-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def grouping_pattern(items, key_func):
    groups = {}

    for item in items:
        key = key_func(item)
        if key not in groups:
            groups[key] = []
        groups[key].append(item)

    return groups

# Alternative using defaultdict
def grouping_with_defaultdict(items, key_func):
    groups = defaultdict(list)
    for item in items:
        groups[key_func(item)].append(item)
    return groups</code></pre>
<h3 id="3-cachingmemoization-pattern">3️⃣ Caching/Memoization Pattern<a class="headerlink" href="#3-cachingmemoization-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def memoization_pattern():
    cache = {}

    def memoized_func(arg):
        if arg not in cache:
            cache[arg] = compute_value(arg)
        return cache[arg]

    return memoized_func

# Alternative using @lru_cache
from functools import lru_cache

@lru_cache(maxsize=None)
def cached_function(arg):
    return compute_value(arg)</code></pre>
<h3 id="4-two-sum-pattern">4️⃣ Two-Sum Pattern<a class="headerlink" href="#4-two-sum-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def two_sum_pattern(nums, target):
    seen = {}  # value -&gt; index

    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

    return []</code></pre>
<h2 id="advanced-techniques">🎮 Advanced Techniques<a class="headerlink" href="#advanced-techniques" title="Permanent link">&para;</a></h2>
<h3 id="1-multi-level-dictionary">1️⃣ Multi-Level Dictionary<a class="headerlink" href="#1-multi-level-dictionary" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Creation
multi_level = {
    'level1': {
        'level2': {
            'level3': 'value'
        }
    }
}

# Safe Navigation
def safe_get(dictionary, *keys, default=None):
    current = dictionary
    for key in keys:
        if not isinstance(current, dict):
            return default
        current = current.get(key, default)
    return current</code></pre>
<h3 id="2-dictionary-comprehension">2️⃣ Dictionary Comprehension<a class="headerlink" href="#2-dictionary-comprehension" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Basic comprehension
squares = {x: x*x for x in range(5)}

# Conditional comprehension
even_squares = {x: x*x for x in range(5) if x % 2 == 0}

# Transforming dictionaries
transformed = {k: v*2 for k, v in original.items()}</code></pre>
<h3 id="3-advanced-operations">3️⃣ Advanced Operations<a class="headerlink" href="#3-advanced-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python"># Merging dictionaries
dict3 = {**dict1, **dict2}  # Python 3.5+
dict3 = dict1 | dict2       # Python 3.9+

# Get multiple values safely
values = [hash_map.get(key) for key in keys]

# Delete multiple keys
for key in keys_to_delete:
    hash_map.pop(key, None)  # Won't raise KeyError</code></pre>
<h2 id="common-interview-problem-patterns">📝 Common Interview Problem Patterns<a class="headerlink" href="#common-interview-problem-patterns" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Frequency Counter Problems</strong><ul>
<li>Character frequency in strings</li>
<li>Word frequency in sentences</li>
<li>Element frequency in arrays</li>
</ul>
</li>
<li><strong>Two-Sum Type Problems</strong><ul>
<li>Finding pairs with target sum</li>
<li>Finding triplets</li>
<li>Subarray with given sum</li>
</ul>
</li>
<li><strong>Caching Problems</strong><ul>
<li>Implementing LRU cache</li>
<li>Memoization problems</li>
<li>Function results caching</li>
</ul>
</li>
<li><strong>String Problems</strong><ul>
<li>Anagram detection</li>
<li>First non-repeating character</li>
<li>String permutations</li>
</ul>
</li>
</ol>
<h2 id="practice-problems_2">🎯 Practice Problems<a class="headerlink" href="#practice-problems_2" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Frequency Based</strong><ul>
<li>Find the first non-repeating character in a string</li>
<li>Find if two strings are anagrams</li>
<li>Most frequent element in an array</li>
</ul>
</li>
<li><strong>Lookup Based</strong><ul>
<li>Implement two sum</li>
<li>Group anagrams together</li>
<li>Find all pairs with given difference</li>
</ul>
</li>
<li><strong>Caching Based</strong><ul>
<li>Implement LRU cache</li>
<li>Design a file system cache</li>
<li>Implement memoization decorator</li>
</ul>
</li>
<li><strong>Advanced Problems</strong><ul>
<li>Design a time-based key-value store</li>
<li>Implement a data structure that supports insert, delete, getRandom in O(1)</li>
<li>Design a logger rate limiter</li>
</ul>
</li>
</ol>
<h2 id="common-pitfalls-to-watch-for">⚠️ Common Pitfalls to Watch For<a class="headerlink" href="#common-pitfalls-to-watch-for" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Mutability Issues</strong><ul>
<li>Using mutable objects as dictionary keys</li>
<li>Modifying dictionary while iterating</li>
</ul>
</li>
<li><strong>Performance Traps</strong><ul>
<li>Repeatedly accessing the same key</li>
<li>Not using .get() for default values</li>
<li>Unnecessary key existence checks</li>
</ul>
</li>
<li><strong>Memory Issues</strong><ul>
<li>Unbounded growth in caching problems</li>
<li>Not clearing references in long-running applications</li>
</ul>
</li>
<li><strong>Edge Cases</strong><ul>
<li>Empty dictionaries</li>
<li>Non-existent keys</li>
<li>None values vs missing keys</li>
</ul>
</li>
</ol>
<p>Remember: Hash tables provide O(1) average case operations but require good hash functions and collision handling strategies. In Python, this is handled automatically by the dictionary implementation.</p>
<h1 id="heaps-for-technical-interviews">🌳 Heaps for Technical Interviews<a class="headerlink" href="#heaps-for-technical-interviews" title="Permanent link">&para;</a></h1>
<h2 id="core-concepts">📚 Core Concepts<a class="headerlink" href="#core-concepts" title="Permanent link">&para;</a></h2>
<h3 id="what-is-a-heap">What is a Heap?<a class="headerlink" href="#what-is-a-heap" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">"""
A heap is a complete binary tree that satisfies the heap property:
- Max Heap: Parent nodes are greater than or equal to children
- Min Heap: Parent nodes are less than or equal to children
- Python's heapq implements min heap
"""

# Key Properties:
properties = {
    "Complete Binary Tree": "All levels filled except possibly last level",
    "Heap Property": "Parent-child relationship maintained throughout",
    "Root": "Smallest element (min heap) or largest element (max heap)",
    "Implementation": "Usually backed by an array/list",
    "Height": "O(log n) where n is number of nodes"
}</code></pre>
<h3 id="parent-child-relationships-in-array-implementation">Parent-Child Relationships in Array Implementation<a class="headerlink" href="#parent-child-relationships-in-array-implementation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def get_relationships(i: int) -&gt; dict:
    return {
        'parent': (i - 1) // 2,    # Parent index
        'left_child': 2 * i + 1,   # Left child index
        'right_child': 2 * i + 2,  # Right child index
    }    </code></pre>
<h2 id="basic-operations-using-heapq">🔧 Basic Operations Using heapq<a class="headerlink" href="#basic-operations-using-heapq" title="Permanent link">&para;</a></h2>
<h3 id="1-heap-creation">1. Heap Creation<a class="headerlink" href="#1-heap-creation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">import heapq

# Method 1: Heapify existing list
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
heapq.heapify(numbers)  # O(n)

# Method 2: Create empty heap (just use list)
heap = []</code></pre>
<h3 id="2-core-operations">2. Core Operations<a class="headerlink" href="#2-core-operations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def heap_operations():
    heap = []

    # Push - O(log n)
    heapq.heappush(heap, 5)

    # Pop - O(log n)
    smallest = heapq.heappop(heap)

    # Peek - O(1)
    if heap:
        smallest = heap[0]

    # Push and Pop combined - O(log n)
    smallest = heapq.heappushpop(heap, 4)  # Push then pop
    smallest = heapq.heapreplace(heap, 4)  # Pop then push</code></pre>
<h3 id="3-helper-functions">3. Helper Functions<a class="headerlink" href="#3-helper-functions" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def heap_helpers(items):
    # Find n smallest elements - O(n log k)
    n_smallest = heapq.nsmallest(3, items)

    # Find n largest elements - O(n log k)
    n_largest = heapq.nlargest(3, items)

    # Merge sorted iterables - O(n log k)
    merged = heapq.merge([1,3,5], [2,4,6])</code></pre>
<h2 id="common-heap-patterns">🎯 Common Heap Patterns<a class="headerlink" href="#common-heap-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-priority-queue-implementation">1. Priority Queue Implementation<a class="headerlink" href="#1-priority-queue-implementation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any = field(compare=False)

class PriorityQueue:
    def __init__(self):
        self._queue = []

    def push(self, item, priority):
        heapq.heappush(self._queue, PrioritizedItem(priority, item))

    def pop(self):
        return heapq.heappop(self._queue).item

    def peek(self):
        return self._queue[0].item if self._queue else None</code></pre>
<h3 id="2-k-way-merge-pattern">2. K-Way Merge Pattern<a class="headerlink" href="#2-k-way-merge-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def k_way_merge(sorted_arrays):
    """Merge k sorted arrays using heap."""
    merged = []
    heap = []

    # Initialize heap with first element from each array
    for i, arr in enumerate(sorted_arrays):
        if arr:
            heapq.heappush(heap, (arr[0], i, 0))

    while heap:
        val, array_index, elem_index = heapq.heappop(heap)
        merged.append(val)

        if elem_index + 1 &lt; len(sorted_arrays[array_index]):
            next_val = sorted_arrays[array_index][elem_index + 1]
            heapq.heappush(heap, (next_val, array_index, elem_index + 1))

    return merged</code></pre>
<h3 id="3-running-median-pattern">3. Running Median Pattern<a class="headerlink" href="#3-running-median-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class MedianFinder:
    def __init__(self):
        self.small = []  # max heap (-ve numbers)
        self.large = []  # min heap

    def add_num(self, num: int) -&gt; None:
        # Add to appropriate heap
        if len(self.small) == len(self.large):
            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))
        else:
            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))

    def find_median(self) -&gt; float:
        if len(self.small) == len(self.large):
            return (-self.small[0] + self.large[0]) / 2.0
        return float(self.large[0])</code></pre>
<h2 id="common-interview-problems">🎯 Common Interview Problems<a class="headerlink" href="#common-interview-problems" title="Permanent link">&para;</a></h2>
<h3 id="problem-types">Problem Types<a class="headerlink" href="#problem-types" title="Permanent link">&para;</a></h3>
<ol>
<li>K-th Element Problems
<pre class="highlight"><code class="language-python">def find_kth_largest(nums: List[int], k: int) -&gt; int:
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) &gt; k:
            heapq.heappop(heap)
    return heap[0]</code></pre></li>
<li>Merge Problems
<pre class="highlight"><code class="language-python">def merge_k_arrays(arrays: List[List[int]]) -&gt; List[int]:
    return list(heapq.merge(*arrays))</code></pre></li>
<li>Scheduling Problems
<pre class="highlight"><code class="language-python">def min_meeting_rooms(intervals: List[List[int]]) -&gt; int:
    heap = []  # Track end times
    for start, end in sorted(intervals):
        if heap and heap[0] &lt;= start:
            heapq.heapreplace(heap, end)
        else:
            heapq.heappush(heap, end)
    return len(heap)    </code></pre></li>
</ol>
<h3 id="edge-cases-to-consider">⚠️ Edge Cases to Consider<a class="headerlink" href="#edge-cases-to-consider" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def edge_cases_to_check():
    """
    1. Empty heap operations
    2. Single element heap
    3. Duplicate elements
    4. Negative numbers
    5. Very large numbers
    6. Equal priorities in priority queue
    """
    pass</code></pre>
<h3 id="time-complexity-summary">🎯 Time Complexity Summary<a class="headerlink" href="#time-complexity-summary" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">complexities = {
    "heapify": "O(n)",
    "push": "O(log n)",
    "pop": "O(log n)",
    "peek": "O(1)",
    "heappushpop": "O(log n)",
    "nlargest/nsmallest": "O(n log k)",  # where k is the count requested
    "merge k sorted lists": "O(n log k)"  # where k is number of lists
}</code></pre>
<h2 id="interview-tips_1">💡 Interview Tips<a class="headerlink" href="#interview-tips_1" title="Permanent link">&para;</a></h2>
<ol>
<li>Use heap when:<ul>
<li>Need to find k largest/smallest elements</li>
<li>Need to continuously find min/max</li>
<li>Need to merge sorted sequences</li>
<li>Implementing priority queue</li>
</ul>
</li>
<li>Python Heap Notes:<ul>
<li>heapq implements min heap</li>
<li>For max heap, negate values</li>
<li>No decrease-key operation</li>
<li>Can't access arbitrary elements</li>
</ul>
</li>
<li>Solution Strategy:<ul>
<li>Identify if problem needs min or max heap</li>
<li>Consider if heap is overkill (sorted list might work)</li>
<li>Check if priority queue would be clearer</li>
<li>Think about space complexity tradeoffs</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always verify time/space complexity</li>
<li>Consider edge cases</li>
<li>Explain heap property while coding</li>
<li>Mention alternative approaches</li>
</ul>
<h1 id="recursion-guide-for-technical-interviews">🔄 Recursion Guide for Technical Interviews<a class="headerlink" href="#recursion-guide-for-technical-interviews" title="Permanent link">&para;</a></h1>
<h2 id="core-concepts_1">📚 Core Concepts<a class="headerlink" href="#core-concepts_1" title="Permanent link">&para;</a></h2>
<h3 id="what-is-recursion">What is Recursion?<a class="headerlink" href="#what-is-recursion" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">"""
Recursion is when a function calls itself either:
1. Directly: The function directly calls itself
2. Indirectly: Function A calls Function B which calls Function A

Key Components:
1. Base Case (stopping condition)
2. Recursive Case (moving towards base case)
"""</code></pre>
<h3 id="key-elements-of-recursive-function">Key Elements of Recursive Function<a class="headerlink" href="#key-elements-of-recursive-function" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def recursive_function(input):
    # 1. Base Case
    if input &lt;= base_case:
        return base_value

    # 2. Recursive Case
    # - Must move towards base case
    # - Usually operates on smaller input
    return recursive_function(smaller_input)</code></pre>
<h2 id="common-recursion-patterns">🎯 Common Recursion Patterns<a class="headerlink" href="#common-recursion-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-linear-recursion-pattern">1. Linear Recursion Pattern<a class="headerlink" href="#1-linear-recursion-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def linear_recursion(n: int) -&gt; int:
    # Base case
    if n &lt;= 0:
        return base_value

    # Single recursive call
    return recursive_step(linear_recursion(n - 1))

# Example: Factorial
def factorial(n: int) -&gt; int:
    if n &lt;= 1:  # Base case
        return 1
    return n * factorial(n - 1)  # Recursive case</code></pre>
<h3 id="2-binary-recursion-pattern">2. Binary Recursion Pattern<a class="headerlink" href="#2-binary-recursion-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def binary_recursion(data):
    # Base case
    if base_condition(data):
        return base_value

    # Two recursive calls
    left = binary_recursion(left_portion(data))
    right = binary_recursion(right_portion(data))
    return combine(left, right)

# Example: Binary Tree Traversal
def traverse(root):
    if not root:
        return
    traverse(root.left)
    traverse(root.right)</code></pre>
<h3 id="3-tail-recursion-pattern">3. Tail Recursion Pattern<a class="headerlink" href="#3-tail-recursion-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def tail_recursion(n, accumulator=initial_value):
    # Base case
    if n &lt;= 0:
        return accumulator

    # Recursive call must be last operation
    return tail_recursion(n - 1, next_accumulator)

# Example: Tail Recursive Factorial
def factorial_tail(n: int, acc: int = 1) -&gt; int:
    if n &lt;= 1:
        return acc
    return factorial_tail(n - 1, n * acc)</code></pre>
<h3 id="4-nested-recursion-pattern">4. Nested Recursion Pattern<a class="headerlink" href="#4-nested-recursion-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def nested_recursion(n):
    # Base case
    if n &lt;= 0:
        return base_value

    # Recursive call within recursive call
    return nested_recursion(nested_recursion(n - 1))</code></pre>
<h2 id="common-interview-problem-types">📝 Common Interview Problem Types<a class="headerlink" href="#common-interview-problem-types" title="Permanent link">&para;</a></h2>
<h3 id="1-treegraph-problems">1. Tree/Graph Problems<a class="headerlink" href="#1-treegraph-problems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def tree_traversal(root):
    # Base case
    if not root:
        return

    # Process current node
    process(root)

    # Recurse on children
    for child in root.children:
        tree_traversal(child)</code></pre>
<h3 id="2-stringarray-problems">2. String/Array Problems<a class="headerlink" href="#2-stringarray-problems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def is_palindrome(s: str) -&gt; bool:
    # Base case: empty string or single char
    if len(s) &lt;= 1:
        return True

    # Check outermost chars and recurse on inner
    return s[0] == s[-1] and is_palindrome(s[1:-1])</code></pre>
<h3 id="3-divide-and-conquer-problems">3. Divide and Conquer Problems<a class="headerlink" href="#3-divide-and-conquer-problems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def quick_sort(arr: list) -&gt; list:
    # Base case
    if len(arr) &lt;= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]

    # Recursive case
    return quick_sort(left) + middle + quick_sort(right)</code></pre>
<h2 id="common-pitfalls-solutions">⚠️ Common Pitfalls &amp; Solutions<a class="headerlink" href="#common-pitfalls-solutions" title="Permanent link">&para;</a></h2>
<h3 id="1-stack-overflow">1. Stack Overflow<a class="headerlink" href="#1-stack-overflow" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from sys import setrecursionlimit

def handle_deep_recursion(n: int):
    # Increase recursion limit if needed
    setrecursionlimit(10000)  # Default is 1000

    # Or better: Convert to iteration
    def iterative_version():
        stack = []
        while stack:
            # Process iteratively
            pass</code></pre>
<h3 id="2-redundant-computations">2. Redundant Computations<a class="headerlink" href="#2-redundant-computations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def fibonacci_with_memo(n: int, memo: dict = None) -&gt; int:
    if memo is None:
        memo = {}

    # Check memo before computing
    if n in memo:
        return memo[n]

    # Base cases
    if n &lt;= 1:
        return n

    # Store result in memo
    memo[n] = fibonacci_with_memo(n-1, memo) + fibonacci_with_memo(n-2, memo)
    return memo[n]</code></pre>
<h3 id="3-not-moving-towards-base-case">3. Not Moving Towards Base Case<a class="headerlink" href="#3-not-moving-towards-base-case" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def ensure_progress(n: int) -&gt; int:
    # Bad: Might never reach base case
    if n != 0:
        return ensure_progress(n)

    # Good: Always moves towards base case
    if n &lt;= 0:
        return 0
    return ensure_progress(n - 1)</code></pre>
<h2 id="timespace-complexity-analysis">🎯 Time/Space Complexity Analysis<a class="headerlink" href="#timespace-complexity-analysis" title="Permanent link">&para;</a></h2>
<h3 id="time-complexity-patterns">Time Complexity Patterns<a class="headerlink" href="#time-complexity-patterns" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">complexities = {
    "Linear Recursion": "O(n) - Each call reduces n by 1",
    "Binary Recursion": "O(2^n) - Each call spawns 2 more calls",
    "Divide &amp; Conquer": "O(n log n) - Divides problem in half each time",
    "Tail Recursion": "O(n) - Can be optimized by compiler",
}</code></pre>
<h3 id="space-complexity-considerations">Space Complexity Considerations<a class="headerlink" href="#space-complexity-considerations" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">space_usage = {
    "Call Stack": "Each recursive call adds a frame",
    "Linear Recursion": "O(n) stack space",
    "Tail Recursion": "O(1) with optimization",
    "Tree Recursion": "O(h) where h is tree height"
}</code></pre>
<h2 id="interview-tips_2">💡 Interview Tips<a class="headerlink" href="#interview-tips_2" title="Permanent link">&para;</a></h2>
<ol>
<li>Always start with:<ul>
<li>Base case identification</li>
<li>How to move towards base case</li>
<li>Whether recursion makes sense</li>
</ul>
</li>
<li>Consider converting to iteration if:<ul>
<li>Deep recursion possible</li>
<li>Space complexity is crucial</li>
<li>Performance is critical</li>
</ul>
</li>
<li>Optimize using:<ul>
<li>Memoization for overlapping subproblems</li>
<li>Tail recursion when possible</li>
<li>Helper functions for additional parameters</li>
</ul>
</li>
<li>Be prepared to explain:<ul>
<li>Why recursion is appropriate</li>
<li>Space/time complexity</li>
<li>How to handle edge cases</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Clarity over cleverness</li>
<li>Consider both recursive and iterative solutions</li>
<li>Watch for stack overflow in large inputs</li>
<li>Test with small examples first</li>
</ul>
<h1 id="backtracking-guide">♻️ Backtracking Guide<a class="headerlink" href="#backtracking-guide" title="Permanent link">&para;</a></h1>
<h2 id="core-properties">📚 Core Properties<a class="headerlink" href="#core-properties" title="Permanent link">&para;</a></h2>
<h3 id="1-property-1-no-repetition-and-completion">1️⃣ Property 1: No Repetition and Completion<a class="headerlink" href="#1-property-1-no-repetition-and-completion" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">"""
Backtracking is a systematic method that:
1. Avoids repetitions
2. Doesn't miss any possible solutions
3. Builds solutions incrementally
4. Returns to previous states ("backtracks")

Ideal for:
- Combinatorial problems (permutations, combinations)
- Enumeration problems
- Path finding in graphs
"""</code></pre>
<h3 id="2-property-2-search-pruning">2️⃣ Property 2: Search Pruning<a class="headerlink" href="#2-property-2-search-pruning" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">"""
During solution building:
1. Evaluates partial solutions
2. Prunes branches that can't lead to valid solutions
3. Skips invalid configurations
4. Abandons paths worse than known solutions

Ideal for:
- Constraint satisfaction problems (CSP)
- Optimization problems
- Game-playing scenarios
"""</code></pre>
<h2 id="implementation-patterns">🎯 Implementation Patterns<a class="headerlink" href="#implementation-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-two-pass-pattern">1. Two-Pass Pattern<a class="headerlink" href="#1-two-pass-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def backtrack_pattern(input_data):
    def dfs(curr_state):
        # Forward Pass: Build solution incrementally
        for choice in get_valid_choices(curr_state):
            # 1. Make choice
            apply_choice(curr_state, choice)

            # 2. Recurse
            dfs(curr_state)

            # Backward Pass: Reset state
            undo_choice(curr_state, choice)

    initial_state = create_initial_state()
    dfs(initial_state)</code></pre>
<h3 id="best-used-when">Best Used When:<a class="headerlink" href="#best-used-when" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>State Modification Required</strong>
<pre class="highlight"><code class="language-python"># Example: N-Queens Problem
def solve_n_queens(n):
    def dfs(board, row):
        # Forward: Place queen
        board[row][col] = 'Q'
        solve_further(board, row + 1)
        # Backward: Remove queen
        board[row][col] = '.'</code></pre></li>
<li><strong>Grid/Matrix Problems</strong>
<pre class="highlight"><code class="language-python"># Example: Maze Solving
def solve_maze(maze):
    def dfs(x, y):
        # Forward: Mark path
        maze[x][y] = 'PATH'
        explore_neighbors(x, y)
        # Backward: Unmark if dead end
        maze[x][y] = 'EMPTY'</code></pre></li>
<li><strong>Graph Problems with State Changes</strong>
<pre class="highlight"><code class="language-python"># Example: Graph Coloring
def color_graph(graph):
    def dfs(node, colors):
        # Forward: Color node
        node.color = next_color
        color_neighbors(node)
        # Backward: Reset if invalid
        node.color = None</code></pre></li>
</ol>
<h3 id="characteristics">Characteristics:<a class="headerlink" href="#characteristics" title="Permanent link">&para;</a></h3>
<ul>
<li>Need to maintain and restore state</li>
<li>Solutions built by modifying shared state</li>
<li>Requires explicit cleanup</li>
<li>Common in problems with global constraints</li>
</ul>
<h3 id="2-state-tracking-pattern">2. State Tracking Pattern<a class="headerlink" href="#2-state-tracking-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def state_tracking_pattern():
    used = set()  # or list/array for tracking used elements
    curr = []     # current partial solution

    def dfs(state):
        if is_complete(state):
            record_solution(curr[:])
            return

        for choice in get_choices(state):
            if choice not in used:
                # Forward pass
                used.add(choice)
                curr.append(choice)

                dfs(next_state(state, choice))

                # Backward pass
                used.remove(choice)
                curr.pop()</code></pre>
<h3 id="best-used-when_1">Best Used When:<a class="headerlink" href="#best-used-when_1" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Building Combinations/Permutations</strong>
<pre class="highlight"><code class="language-python"># Example: Generate Subsets
def subsets(nums):
    result = []
    curr = []
    def dfs(start):
        result.append(curr[:])
        for i in range(start, len(nums)):
            curr.append(nums[i])
            dfs(i + 1)
            curr.pop()</code></pre></li>
<li><strong>Building Sequences</strong>
<pre class="highlight"><code class="language-python"># Example: Phone Number Letter Combinations
def letter_combinations(digits):
    curr = []
    def dfs(index):
        if len(curr) == len(digits):
            result.append(''.join(curr))
            return
        for letter in mapping[digits[index]]:
            curr.append(letter)
            dfs(index + 1)
            curr.pop()</code></pre></li>
<li><strong>Path Finding Without State Modification</strong>
<pre class="highlight"><code class="language-python"># Example: All Paths from Source to Target
def all_paths(graph):
    curr_path = []
    def dfs(node):
        curr_path.append(node)
        dfs(next_node)
        curr_path.pop()</code></pre></li>
</ol>
<h3 id="characteristics_1">Characteristics:<a class="headerlink" href="#characteristics_1" title="Permanent link">&para;</a></h3>
<ul>
<li>Solutions built by tracking sequences</li>
<li>No need for explicit state restoration</li>
<li>Usually involves collecting multiple solutions</li>
<li>Common in combinatorial problems</li>
</ul>
<h2 id="decision-making-guide">🎯 Decision Making Guide<a class="headerlink" href="#decision-making-guide" title="Permanent link">&para;</a></h2>
<h3 id="use-two-pass-pattern-when">Use Two-Pass Pattern When:<a class="headerlink" href="#use-two-pass-pattern-when" title="Permanent link">&para;</a></h3>
<ol>
<li>Working with:<ul>
<li>Board games (Chess, N-Queens)</li>
<li>Maze problems</li>
<li>Grid-based problems</li>
<li>Graph coloring</li>
<li>State modification required</li>
</ul>
</li>
<li>Need to:<ul>
<li>Modify and restore shared state</li>
<li>Handle complex constraints</li>
<li>Work with matrix/grid structures</li>
<li>Deal with global state</li>
</ul>
</li>
</ol>
<h3 id="use-state-tracking-pattern-when">Use State Tracking Pattern When:<a class="headerlink" href="#use-state-tracking-pattern-when" title="Permanent link">&para;</a></h3>
<ol>
<li>Working with:<ul>
<li>Combinations/Permutations</li>
<li>String building problems</li>
<li>Subset generation</li>
<li>Path finding without modification</li>
<li>Sequence generation</li>
</ul>
</li>
<li>Need to:<ul>
<li>Build multiple solutions</li>
<li>Generate all possible arrangements</li>
<li>Work with independent states</li>
<li>Create combinations or selections</li>
</ul>
</li>
</ol>
<h2 id="hybrid-approach-examples">🎮 Hybrid Approach Examples<a class="headerlink" href="#hybrid-approach-examples" title="Permanent link">&para;</a></h2>
<p>Sometimes you might need to combine both patterns:
<pre class="highlight"><code class="language-python">def hybrid_backtracking():
    curr_path = []  # State Tracking
    board = [[0] * N for _ in range(N)]  # Two-Pass State

    def dfs(row, col):
        # State Tracking: Build path
        curr_path.append((row, col))

        # Two-Pass: Modify board
        board[row][col] = 'VISITED'

        # Recurse
        explore_neighbors(row, col)

        # Two-Pass: Restore board
        board[row][col] = 'EMPTY'

        # State Tracking: Remove from path
        curr_path.pop()</code></pre></p>
<h3 id="when-to-use-hybrid">When to Use Hybrid:<a class="headerlink" href="#when-to-use-hybrid" title="Permanent link">&para;</a></h3>
<ol>
<li>Complex game scenarios</li>
<li>Path finding with state constraints</li>
<li>Problems requiring both solution building and state modification</li>
<li>Problems with both global and local constraints</li>
</ol>
<p>Remember:</p>
<ul>
<li>Consider state management needs</li>
<li>Think about solution collection requirements</li>
<li>Evaluate constraint checking needs</li>
<li>Consider readability and maintainability</li>
</ul>
<h2 id="common-problem-types">🎮 Common Problem Types<a class="headerlink" href="#common-problem-types" title="Permanent link">&para;</a></h2>
<h3 id="1-permutation-problems">1. Permutation Problems<a class="headerlink" href="#1-permutation-problems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def permute(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(curr: List[int], used: Set[int]):
        # Base case: complete permutation
        if len(curr) == len(nums):
            result.append(curr[:])
            return

        # Try each unused number
        for i in range(len(nums)):
            # Skip used numbers
            if i in used:
                continue

            # Forward pass
            used.add(i)
            curr.append(nums[i])

            backtrack(curr, used)

            # Backward pass
            used.remove(i)
            curr.pop()

    result = []
    backtrack([], set())
    return result</code></pre>
<h3 id="2-unique-permutations-with-duplicates">2. Unique Permutations (With Duplicates)<a class="headerlink" href="#2-unique-permutations-with-duplicates" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def permuteUnique(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(curr: List[int], counter: Dict[int, int]):
        if len(curr) == len(nums):
            result.append(curr[:])
            return

        # Use counter to handle duplicates
        for num in counter:
            if counter[num] &gt; 0:
                curr.append(num)
                counter[num] -= 1

                backtrack(curr, counter)

                curr.pop()
                counter[num] += 1

    result = []
    counter = Counter(nums)
    backtrack([], counter)
    return result</code></pre>
<h3 id="3-constraint-satisfaction-problems">3. Constraint Satisfaction Problems<a class="headerlink" href="#3-constraint-satisfaction-problems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def solve_csp(constraints):
    def is_valid_state(state):
        return all(constraint(state) for constraint in constraints)

    def backtrack(state):
        if is_complete(state):
            return is_valid_state(state)

        for value in get_possible_values(state):
            if is_valid_partial(state, value):
                apply_value(state, value)

                if backtrack(state):
                    return True

                undo_value(state, value)

        return False</code></pre>
<h2 id="time-complexity-analysis">🎯 Time Complexity Analysis<a class="headerlink" href="#time-complexity-analysis" title="Permanent link">&para;</a></h2>
<pre class="highlight"><code class="language-python">complexity_notes = {
    "Permutations": {
        "Time": "O(n!)",
        "Space": "O(n) for recursion stack",
        "Note": "Visits each state exactly once"
    },
    "Combinations": {
        "Time": "O(2^n)",
        "Space": "O(n) for recursion stack",
        "Note": "Each element has two choices"
    },
    "CSP Problems": {
        "Time": "O(d^n) where d is domain size",
        "Space": "O(n) for recursion stack",
        "Note": "Pruning can significantly improve average case"
    }
}</code></pre>
<h2 id="optimization-techniques">💡 Optimization Techniques<a class="headerlink" href="#optimization-techniques" title="Permanent link">&para;</a></h2>
<h3 id="1-early-pruning">1. Early Pruning<a class="headerlink" href="#1-early-pruning" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def optimized_backtrack(state):
    # Check constraints early
    if not is_valid_partial(state):
        return False

    if is_complete(state):
        return True

    for choice in sorted_choices(state):  # Sort choices for better pruning
        if is_promising(state, choice):
            apply_choice(state, choice)
            if optimized_backtrack(state):
                return True
            undo_choice(state, choice)</code></pre>
<h3 id="2-state-duplication">2. State Duplication<a class="headerlink" href="#2-state-duplication" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def backtrack_with_dedup(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(start: int, curr: List[int]):
        result.append(curr[:])

        used = set()  # Track used numbers at this level
        for i in range(start, len(nums)):
            if nums[i] in used:  # Skip duplicates at same level
                continue
            used.add(nums[i])

            curr.append(nums[i])
            backtrack(i + 1, curr)
            curr.pop()</code></pre>
<h2 id="interview-tips_3">💡 Interview Tips<a class="headerlink" href="#interview-tips_3" title="Permanent link">&para;</a></h2>
<ol>
<li>Implementation Strategy:<ul>
<li>Always use DFS for backtracking</li>
<li>Identify state representation clearly</li>
<li>Track partial solutions carefully</li>
</ul>
</li>
<li>Optimization Strategy:<ul>
<li>Look for early pruning opportunities</li>
<li>Consider sorting input for better pruning</li>
<li>Use sets/counters for duplicate handling</li>
</ul>
</li>
<li>Problem Solving Steps:<ul>
<li>Identify what makes a valid solution</li>
<li>Determine how to build solutions incrementally</li>
<li>Define clear base cases</li>
<li>Plan state tracking strategy</li>
</ul>
</li>
<li>Testing Strategy:<ul>
<li>Start with small inputs</li>
<li>Test with duplicates if relevant</li>
<li>Verify all solutions are found</li>
<li>Check for invalid inputs</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Backtracking = Choices + Consequences</li>
<li>Think in terms of state and state changes</li>
<li>Always handle cleanup in backward pass</li>
<li>Consider space complexity of solution storage</li>
</ul>
<h1 id="binary-trees-guide">🌳 Binary Trees Guide<a class="headerlink" href="#binary-trees-guide" title="Permanent link">&para;</a></h1>
<h2 id="core-implementation">📚 Core Implementation<a class="headerlink" href="#core-implementation" title="Permanent link">&para;</a></h2>
<h3 id="basic-tree-node">Basic Tree Node<a class="headerlink" href="#basic-tree-node" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right</code></pre>
<h3 id="common-tree-building-patterns">Common Tree Building Patterns<a class="headerlink" href="#common-tree-building-patterns" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def build_tree_examples():
    # Simple Tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)

    # From List
    def from_list(nums: List[int], index: int = 0) -&gt; TreeNode:
        if index &gt;= len(nums) or nums[index] is None:
            return None
        root = TreeNode(nums[index])
        root.left = from_list(nums, 2 * index + 1)
        root.right = from_list(nums, 2 * index + 2)
        return root</code></pre>
<h2 id="core-traversal-patterns">🎯 Core Traversal Patterns<a class="headerlink" href="#core-traversal-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-dfs-patterns">1. DFS Patterns<a class="headerlink" href="#1-dfs-patterns" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class DFSPatterns:
    def inorder(self, root: TreeNode) -&gt; List[int]:
        # Left -&gt; Root -&gt; Right
        def dfs(node):
            if not node:
                return
            dfs(node.left)        # Process left
            result.append(node.val)# Process root
            dfs(node.right)       # Process right

        result = []
        dfs(root)
        return result

    def preorder(self, root: TreeNode) -&gt; List[int]:
        # Root -&gt; Left -&gt; Right
        def dfs(node):
            if not node:
                return
            result.append(node.val)# Process root
            dfs(node.left)        # Process left
            dfs(node.right)       # Process right

        result = []
        dfs(root)
        return result

    def postorder(self, root: TreeNode) -&gt; List[int]:
        # Left -&gt; Right -&gt; Root
        def dfs(node):
            if not node:
                return
            dfs(node.left)        # Process left
            dfs(node.right)       # Process right
            result.append(node.val)# Process root

        result = []
        dfs(root)
        return result</code></pre>
<h3 id="2-bfs-pattern">2. BFS Pattern<a class="headerlink" href="#2-bfs-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from collections import deque

def level_order(root: TreeNode) -&gt; List[List[int]]:
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        current_level = []

        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(current_level)

    return result</code></pre>
<h2 id="common-problem-patterns">🎮 Common Problem Patterns<a class="headerlink" href="#common-problem-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-path-problems-pattern">1. Path Problems Pattern<a class="headerlink" href="#1-path-problems-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def path_pattern(root: TreeNode):
    def dfs(node, path, target):
        if not node:
            return

        # Add current node to path
        path.append(node.val)

        # Check if leaf node
        if not node.left and not node.right:
            process_path(path)  # Process complete path

        # Recurse on children
        dfs(node.left, path, target)
        dfs(node.right, path, target)

        # Backtrack
        path.pop()</code></pre>
<h3 id="2-binary-search-tree-pattern">2. Binary Search Tree Pattern<a class="headerlink" href="#2-binary-search-tree-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def bst_pattern(root: TreeNode):
    def validate_bst(node, min_val=float('-inf'), max_val=float('inf')):
        if not node:
            return True

        # Check BST property
        if node.val &lt;= min_val or node.val &gt;= max_val:
            return False

        # Recurse with updated bounds
        return (validate_bst(node.left, min_val, node.val) and 
                validate_bst(node.right, node.val, max_val))</code></pre>
<h3 id="3-lowest-common-ancestor">3. Lowest Common Ancestor<a class="headerlink" href="#3-lowest-common-ancestor" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def lca_pattern(root: TreeNode, p: TreeNode, q: TreeNode):
    def find_lca(node):
        if not node or node == p or node == q:
            return node

        # Search in left and right subtrees
        left = find_lca(node.left)
        right = find_lca(node.right)

        # If found in both subtrees, current node is LCA
        if left and right:
            return node

        # Return non-null node
        return left or right</code></pre>
<h3 id="4-view-problems-pattern">4. View Problems Pattern<a class="headerlink" href="#4-view-problems-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def tree_view_pattern(root: TreeNode):
    def right_view(root):
        result = []

        def dfs(node, level):
            if not node:
                return

            # First node of this level from right
            if len(result) == level:
                result.append(node.val)

            # Visit right first for right view
            dfs(node.right, level + 1)
            dfs(node.left, level + 1)

        dfs(root, 0)
        return result</code></pre>
<h2 id="pattern-recognition-guide">🎯 Pattern Recognition Guide<a class="headerlink" href="#pattern-recognition-guide" title="Permanent link">&para;</a></h2>
<h3 id="when-to-use-each-pattern">When to Use Each Pattern:<a class="headerlink" href="#when-to-use-each-pattern" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Use DFS When:</strong><ul>
<li>Need to process nodes in a specific order</li>
<li>Working with paths from root to leaf</li>
<li>Validating tree properties</li>
<li>Computing tree properties recursively</li>
</ul>
</li>
<li><strong>Use BFS When:</strong><ul>
<li>Need level-by-level processing</li>
<li>Finding shortest paths</li>
<li>Working with tree width</li>
<li>Level-based operations</li>
</ul>
</li>
<li><strong>Use Path Patterns When:</strong><ul>
<li>Need complete paths from root to leaf</li>
<li>Summing paths</li>
<li>Finding specific paths</li>
<li>Path validation</li>
</ul>
</li>
<li><strong>Use BST Patterns When:</strong><ul>
<li>Searching for values</li>
<li>Validating BST properties</li>
<li>Range-based operations</li>
<li>Maintaining sorted order</li>
</ul>
</li>
</ol>
<h2 id="problem-solving-strategy">💡 Problem-Solving Strategy<a class="headerlink" href="#problem-solving-strategy" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Identify Pattern Type:</strong><ul>
<li>Is it path-based?</li>
<li>Is it level-based?</li>
<li>Does it involve BST properties?</li>
<li>Is order important?</li>
</ul>
</li>
<li><strong>Choose Traversal Method:</strong>
<pre class="highlight"><code class="language-python">patterns = {
    "Need Path": "DFS with path tracking",
    "Level Operations": "BFS with queue",
    "Specific Order": "Choose appropriate DFS order",
    "BST Operations": "Use BST properties"
}</code></pre></li>
<li><strong>Consider Edge Cases</strong>
<pre class="highlight"><code class="language-python">edge_cases = [
    "Empty tree",
    "Single node",
    "All nodes same value",
    "Unbalanced tree",
    "Complete binary tree"
]</code></pre></li>
<li>
<p><strong>Time/Space Complexity</strong>
<pre class="highlight"><code class="language-python">complexities = {
    "DFS": "Time: O(n), Space: O(h)",
    "BFS": "Time: O(n), Space: O(w)",
    "Path": "Time: O(n), Space: O(h)",
    "BST": "Time: O(h), Space: O(1) typical"
}
# where n = nodes, h = height, w = max width</code></pre>
Remember:</p>
</li>
<li>
<p>Start with traversal pattern identification</p>
</li>
<li>Consider whether order matters</li>
<li>Check if BST properties help</li>
<li>Handle edge cases explicitly</li>
</ol>
<h1 id="tries-prefix-trees">🌲 Tries (Prefix Trees)<a class="headerlink" href="#tries-prefix-trees" title="Permanent link">&para;</a></h1>
<h2 id="core-implementation_1">📚 Core Implementation<a class="headerlink" href="#core-implementation_1" title="Permanent link">&para;</a></h2>
<h3 id="basic-trie-node">Basic Trie Node<a class="headerlink" href="#basic-trie-node" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class TrieNode:
    def __init__(self):
        self.children = {}  # or [None] * 26 for fixed alphabet
        self.is_end = False  # Marks end of word</code></pre>
<h3 id="basic-trie-structure">Basic Trie Structure<a class="headerlink" href="#basic-trie-structure" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -&gt; None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word: str) -&gt; bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def starts_with(self, prefix: str) -&gt; bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True</code></pre>
<h2 id="common-patterns">🎯 Common Patterns<a class="headerlink" href="#common-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-word-dictionary-pattern">1. Word Dictionary Pattern<a class="headerlink" href="#1-word-dictionary-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -&gt; None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search_with_wildcard(self, word: str) -&gt; bool:
        def dfs(node, i):
            if i == len(word):
                return node.is_end

            if word[i] == '.':
                for child in node.children.values():
                    if child and dfs(child, i + 1):
                        return True
                return False

            if word[i] not in node.children:
                return False

            return dfs(node.children[word[i]], i + 1)

        return dfs(self.root, 0)</code></pre>
<h3 id="2-prefix-matching-pattern">2. Prefix Matching Pattern<a class="headerlink" href="#2-prefix-matching-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def prefix_matching_pattern():
    class AutocompleteSystem:
        def __init__(self, words: List[str], times: List[int]):
            self.root = TrieNode()
            self.prefix = ""

            # Insert words with frequencies
            for word, count in zip(words, times):
                self._insert(word, count)

        def _insert(self, word: str, count: int) -&gt; None:
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
                node.counts[word] = count

        def input(self, c: str) -&gt; List[str]:
            if c == '#':
                self._insert(self.prefix, 1)
                self.prefix = ""
                return []

            self.prefix += c
            node = self.root

            # Find node for current prefix
            for char in self.prefix:
                if char not in node.children:
                    return []
                node = node.children[char]

            # Get top 3 suggestions
            return sorted(node.counts.items(), 
                        key=lambda x: (-x[1], x[0]))[:3]</code></pre>
<h3 id="3-word-square-pattern">3. Word Square Pattern<a class="headerlink" href="#3-word-square-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def word_square_pattern(words: List[str]) -&gt; List[List[str]]:
    trie = Trie()
    n = len(words[0])

    # Build prefix map
    prefix_map = defaultdict(list)
    for i, word in enumerate(words):
        for j in range(len(word) + 1):
            prefix_map[word[:j]].append(i)

    def get_words_with_prefix(prefix):
        return [words[i] for i in prefix_map[prefix]]

    def backtrack(square):
        if len(square) == n:
            result.append(square[:])
            return

        # Get prefix for next word
        pos = len(square)
        prefix = ''.join(word[pos] for word in square)

        # Try all words with this prefix
        for word in get_words_with_prefix(prefix):
            square.append(word)
            backtrack(square)
            square.pop()

    result = []
    backtrack([])
    return result</code></pre>
<h2 id="timespace-complexity">🎯 Time/Space Complexity<a class="headerlink" href="#timespace-complexity" title="Permanent link">&para;</a></h2>
<pre class="highlight"><code class="language-python">complexities = {
    "Insert": {
        "Time": "O(m) where m is word length",
        "Space": "O(m)"
    },
    "Search": {
        "Time": "O(m)",
        "Space": "O(1)"
    },
    "StartsWith": {
        "Time": "O(m)",
        "Space": "O(1)"
    },
    "Space Usage": "O(ALPHABET_SIZE * m * n) for n words"
}</code></pre>
<h2 id="key-advantagesdisadvantages">🔑 Key Advantages/Disadvantages<a class="headerlink" href="#key-advantagesdisadvantages" title="Permanent link">&para;</a></h2>
<h3 id="advantages">Advantages:<a class="headerlink" href="#advantages" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">advantages = [
    "Fast prefix lookups O(m)",
    "Space-efficient for common prefixes",
    "No need for hash function",
    "No collisions to handle",
    "Natural for autocomplete/spellcheck"
]</code></pre>
<h3 id="disadvantages">Disadvantages<a class="headerlink" href="#disadvantages" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">disadvantages = [
    "Memory intensive (many null pointers)",
    "Slower than hash table for exact lookups",
    "Complex to implement/maintain",
    "Not cache-friendly due to pointer chasing"
]</code></pre>
<h2 id="when-to-use-tries">💡 When to Use Tries<a class="headerlink" href="#when-to-use-tries" title="Permanent link">&para;</a></h2>
<pre class="highlight"><code class="language-python">use_cases = {
    "Autocomplete": "Search suggestions",
    "Spell Checker": "Word validation",
    "IP Routing": "Prefix matching",
    "Word Games": "Word validation/search",
    "Contact List": "Type-ahead search"
}</code></pre>
<h2 id="common-pitfalls">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Memory Management</strong>
<pre class="highlight"><code class="language-python">def avoid_memory_issues():
    """
    - Consider using array instead of map for fixed alphabet
    - Clean up unused nodes
    - Use compressed tries for long strings
    """
    pass</code></pre></li>
<li><strong>Implementation Choices</strong>
<pre class="highlight"><code class="language-python">def implementation_tips():
    """
    - Choose appropriate children structure
      (array vs map based on alphabet size)
    - Decide on case sensitivity handling
    - Plan wildcard character handling
    """
    pass</code></pre></li>
</ol>
<h2 id="practice-problem-types">🎯 Practice Problem Types<a class="headerlink" href="#practice-problem-types" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Basic Operations</strong><ul>
<li>Implement insert/search/startsWith</li>
<li>Handle wildcards</li>
<li>Case-sensitive operations</li>
</ul>
</li>
<li><strong>Word Problems</strong><ul>
<li>Word search</li>
<li>Word squares</li>
<li>Word break</li>
<li>Replace words</li>
</ul>
</li>
<li><strong>Prefix Problems</strong><ul>
<li>Autocomplete</li>
<li>Longest common prefix</li>
<li>Unique prefixes</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Consider memory-space tradeoffs</li>
<li>Handle edge cases (empty strings, special chars)</li>
<li>Think about prefix sharing opportunities</li>
<li>Consider case sensitivity requirements</li>
</ul>
<h1 id="binary-search-guide">🔍 Binary Search Guide<a class="headerlink" href="#binary-search-guide" title="Permanent link">&para;</a></h1>
<h2 id="core-template">📚 Core Template<a class="headerlink" href="#core-template" title="Permanent link">&para;</a></h2>
<h3 id="most-generalized-binary-search-template">Most Generalized Binary Search Template<a class="headerlink" href="#most-generalized-binary-search-template" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def binary_search(array) -&gt; int:
    def condition(value) -&gt; bool:
        # Customize condition here
        pass

    left, right = min(search_space), max(search_space)
    while left &lt; right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid
        else:
            left = mid + 1
    return left

# Key Points:
# 1. Initialize boundaries to include ALL possible answers
# 2. Condition function defines search criteria
# 3. Returns minimum k where condition(k) is True</code></pre>
<h2 id="three-key-components">🎯 Three Key Components<a class="headerlink" href="#three-key-components" title="Permanent link">&para;</a></h2>
<h3 id="1-boundary-initialization">1. Boundary Initialization<a class="headerlink" href="#1-boundary-initialization" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def initialize_boundaries():
    """
    Rules for setting left and right:
    1. Must include all possible answers
    2. Common patterns:
       - [0, len(array)]         # For index search
       - [min(array), max(array)] # For value search
       - [1, max_possible]       # For minimum/maximum problems
    """
    # Example bounds for different scenarios
    bounds = {
        "Index Search": (0, len(array)),
        "Value Search": (min(array), max(array)),
        "Minimum Search": (1, max_value),
        "Maximum Search": (min_value, sum(array))
    }</code></pre>
<h3 id="2-condition-function-design">2. Condition Function Design<a class="headerlink" href="#2-condition-function-design" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def design_condition():
    """
    Patterns for condition functions:
    1. Direct Comparison: array[mid] &gt;= target
    2. Feasibility Check: can_achieve(mid)
    3. Counting: count_less_equal(mid) &gt;= k
    4. Validation: is_valid_solution(mid)
    """
    # Example condition patterns
    conditions = {
        "Finding Target": lambda mid: array[mid] &gt;= target,
        "Feasibility": lambda mid: can_do_task_with_value(mid),
        "Counting": lambda mid: count_elements_less_than(mid) &gt;= k,
        "Validation": lambda mid: validates_constraint(mid)
    }</code></pre>
<h3 id="3-return-value-selection">3. Return Value Selection<a class="headerlink" href="#3-return-value-selection" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def choose_return():
    """
    Return value patterns:
    1. left: Minimum value satisfying condition
    2. left - 1: Maximum value not satisfying condition
    3. right: Alternative minimum value
    4. Special handling for not found cases
    """
    return_patterns = {
        "Minimum Satisfying": "return left",
        "Maximum Not Satisfying": "return left - 1",
        "Not Found": "return -1 if not found"
    }</code></pre>
<h2 id="common-problem-patterns_1">🎮 Common Problem Patterns<a class="headerlink" href="#common-problem-patterns_1" title="Permanent link">&para;</a></h2>
<h3 id="1-classical-binary-search">1. Classical Binary Search<a class="headerlink" href="#1-classical-binary-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def classical_search(nums: List[int], target: int) -&gt; int:
    left, right = 0, len(nums)

    while left &lt; right:
        mid = left + (right - left) // 2
        if nums[mid] &gt;= target:
            right = mid
        else:
            left = mid + 1

    return left if left &lt; len(nums) and nums[left] == target else -1</code></pre>
<h3 id="2-minimum-value-search">2. Minimum Value Search<a class="headerlink" href="#2-minimum-value-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def find_minimum(nums: List[int]) -&gt; int:
    def feasible(value) -&gt; bool:
        # Define feasibility condition
        total = 0
        for num in nums:
            if condition(num, value):
                total += 1
        return total &gt;= required

    left, right = min_possible, max_possible
    while left &lt; right:
        mid = left + (right - left) // 2
        if feasible(mid):
            right = mid
        else:
            left = mid + 1
    return left</code></pre>
<h3 id="3-maximum-value-search">3. Maximum Value Search<a class="headerlink" href="#3-maximum-value-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def find_maximum(nums: List[int]) -&gt; int:
    def feasible(value) -&gt; bool:
        # Define feasibility condition
        return can_achieve_with_value(value)

    left, right = min_possible, max_possible
    while left &lt; right:
        mid = left + (right - left + 1) // 2  # Note: Different mid calculation
        if feasible(mid):
            left = mid
        else:
            right = mid - 1
    return left</code></pre>
<h2 id="pattern-recognition-guide_1">🎯 Pattern Recognition Guide<a class="headerlink" href="#pattern-recognition-guide_1" title="Permanent link">&para;</a></h2>
<h3 id="when-to-use-binary-search">When to Use Binary Search:<a class="headerlink" href="#when-to-use-binary-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">binary_search_indicators = {
    "Sorted Array": "Direct binary search possible",
    "Monotonic Condition": "Can use binary search on answer space",
    "Min/Max Optimization": "Likely binary search on result",
    "Feasibility Check": "Can binary search with validation",
    "Counting Problems": "Binary search possible if monotonic"
}</code></pre>
<h3 id="problem-type-recognition">Problem Type Recognition<a class="headerlink" href="#problem-type-recognition" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def identify_pattern(problem):
    patterns = {
        "Find Exact Value": "Classical binary search",
        "Find Minimum Satisfying": "Minimum value pattern",
        "Find Maximum Possible": "Maximum value pattern",
        "Optimization with Constraint": "Feasibility pattern",
        "Counting with Condition": "Counting pattern"
    }</code></pre>
<h2 id="common-pitfalls_1">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_1" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Boundary Issues</strong>
<pre class="highlight"><code class="language-python">def avoid_boundary_issues():
    """
    Common pitfalls:
    1. Off-by-one errors in boundaries
    2. Not including all possible answers
    3. Infinite loops due to improper mid calculation
    4. Not handling edge cases
    """
    pass</code></pre></li>
<li><strong>Condition Design</strong>
<pre class="highlight"><code class="language-python">def condition_pitfalls():
    """
    Watch out for:
    1. Non-monotonic conditions
    2. Incorrect comparison operators
    3. Missing edge cases in condition
    4. Overcomplicated condition logic
    """
    pass</code></pre></li>
</ol>
<h2 id="implementation-tips">💡 Implementation Tips<a class="headerlink" href="#implementation-tips" title="Permanent link">&para;</a></h2>
<ol>
<li>Always use  <code>left + (right - left) // 2</code>  to avoid overflow</li>
<li>Consider whether to include end points</li>
<li>Test with small examples first</li>
<li>Verify monotonicity of condition</li>
<li>Handle edge cases explicitly</li>
</ol>
<p>Remember:</p>
<ul>
<li>Think in terms of answer space vs index space</li>
<li>Verify condition function monotonicity</li>
<li>Consider boundary cases carefully</li>
<li>Test with small inputs first</li>
</ul>
<h1 id="greedy-algorithms">🪙 Greedy Algorithms<a class="headerlink" href="#greedy-algorithms" title="Permanent link">&para;</a></h1>
<h2 id="core-properties_1">📚 Core Properties<a class="headerlink" href="#core-properties_1" title="Permanent link">&para;</a></h2>
<h3 id="what-is-a-greedy-algorithm">What is a Greedy Algorithm?<a class="headerlink" href="#what-is-a-greedy-algorithm" title="Permanent link">&para;</a></h3>
<p>A greedy algorithm makes the locally optimal choice at each step, hoping to find a global optimum. While simple and intuitive, they don't always yield the optimal solution but often provide efficient solutions for optimization problems.</p>
<h3 id="key-properties">Key Properties<a class="headerlink" href="#key-properties" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">properties = {
    "Local Optimal Choice": "Best choice at current step",
    "Hope": "Local optimum leads to global optimum",
    "No Backtracking": "Decisions are final",
    "Simple Implementation": "Usually straightforward code"
}</code></pre>
<h2 id="when-to-use-greedy-algorithms">🎯 When to Use Greedy Algorithms<a class="headerlink" href="#when-to-use-greedy-algorithms" title="Permanent link">&para;</a></h2>
<h3 id="criteria-for-greedy-approach">Criteria for Greedy Approach<a class="headerlink" href="#criteria-for-greedy-approach" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def is_greedy_applicable(problem):
    criteria = {
        "Greedy Choice Property": """Local optimal choices 
            lead to global optimal solution""",
        "Optimal Substructure": """Optimal solution contains 
            optimal solutions to subproblems""",
        "No Future Impact": "Current choice doesn't affect future choices",
        "Simple Constraints": "Problem has straightforward constraints"
    }
    return all(criteria.values())</code></pre>
<h2 id="common-greedy-patterns">🎮 Common Greedy Patterns<a class="headerlink" href="#common-greedy-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-activity-selection-pattern">1. Activity Selection Pattern<a class="headerlink" href="#1-activity-selection-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def activity_selection(start: List[int], finish: List[int]) -&gt; List[int]:
    # Sort activities by finish time
    activities = sorted(zip(start, finish), key=lambda x: x[1])
    selected = [activities[0]]
    last_finish = activities[0][1]

    for start_time, finish_time in activities[1:]:
        if start_time &gt;= last_finish:
            selected.append((start_time, finish_time))
            last_finish = finish_time

    return selected</code></pre>
<h3 id="2-fractional-knapsack-problem">2. Fractional Knapsack Problem<a class="headerlink" href="#2-fractional-knapsack-problem" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def fractional_knapsack(values: List[int], weights: List[int], 
                       capacity: int) -&gt; float:
    # Calculate value/weight ratio
    items = sorted(zip(values, weights), 
                  key=lambda x: x[0]/x[1], reverse=True)
    total_value = 0

    for value, weight in items:
        if capacity &gt;= weight:
            # Take whole item
            capacity -= weight
            total_value += value
        else:
            # Take fraction of item
            total_value += value * (capacity / weight)
            break

    return total_value</code></pre>
<h3 id="3-meeting-rooms-pattern">3. Meeting Rooms Pattern<a class="headerlink" href="#3-meeting-rooms-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def min_meeting_rooms(intervals: List[List[int]]) -&gt; int:
    if not intervals:
        return 0

    # Separate start and end times
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])

    rooms = 0
    max_rooms = 0
    s = e = 0

    while s &lt; len(intervals):
        if starts[s] &lt; ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)

    return max_rooms</code></pre>
<h3 id="4-coin-change-greedy-pattern">4. Coin Change (Greedy Pattern)<a class="headerlink" href="#4-coin-change-greedy-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def coin_change_greedy(amount: int, coins: List[int]) -&gt; int:
    coins.sort(reverse=True)  # Sort coins in descending order
    count = 0

    for coin in coins:
        while amount &gt;= coin:
            amount -= coin
            count += 1

    return count if amount == 0 else -1</code></pre>
<h2 id="universal-greedy-patterns">🔄 Universal Greedy Patterns<a class="headerlink" href="#universal-greedy-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-sorting-first-pattern">1. Sorting-First Pattern<a class="headerlink" href="#1-sorting-first-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def sorting_first_pattern(items, key_function=None):
    """
    Universal pattern for problems requiring initial sorting.
    Common in: Activity selection, Job scheduling, Meeting rooms
    """
    # 1. Sort based on key metric
    sorted_items = sorted(items, key=key_function) if key_function else sorted(items)

    result = []
    current = sorted_items[0]  # Track current selection

    # 2. Process items in sorted order
    for item in sorted_items[1:]:
        if satisfies_constraint(current, item):
            # 3. Make greedy choice
            result.append(current)
            current = item

    result.append(current)  # Don't forget last item
    return result

# Example Usage: Activity Selection
def activity_selection(activities):
    return sorting_first_pattern(
        activities,
        key_function=lambda x: x[1]  # Sort by finish time
    )

# Example Usage: Meeting Rooms
def meeting_rooms(meetings):
    return sorting_first_pattern(
        meetings,
        key_function=lambda x: x[0]  # Sort by start time
    )</code></pre>
<h3 id="2-fraction-ratepattern">2. Fraction Rate/Pattern<a class="headerlink" href="#2-fraction-ratepattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def fraction_pattern(items, constraint, get_value, get_weight):
    """
    Universal pattern for fractional optimization problems.
    Common in: Knapsack, Task scheduling with efficiency
    """
    # 1. Calculate rates and sort
    rates = [(get_value(item)/get_weight(item), item) 
             for item in items]
    rates.sort(reverse=True)

    result = []
    total_value = 0
    remaining = constraint

    # 2. Process items by rate
    for rate, item in rates:
        weight = get_weight(item)
        if remaining &gt;= weight:
            # Take whole item
            result.append((item, 1.0))
            total_value += get_value(item)
            remaining -= weight
        else:
            # Take fraction
            fraction = remaining / weight
            result.append((item, fraction))
            total_value += get_value(item) * fraction
            break

    return result, total_value

# Example Usage: Fractional Knapsack
def fractional_knapsack(items, capacity):
    return fraction_pattern(
        items,
        capacity,
        get_value=lambda x: x.value,
        get_weight=lambda x: x.weight
    )</code></pre>
<h3 id="3-running-window-pattern">3. Running Window Pattern<a class="headerlink" href="#3-running-window-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def running_window_pattern(items, constraint):
    """
    Universal pattern for running window problems.
    Common in: Meeting rooms, Task scheduling, Resource allocation
    """
    # 1. Separate start and end events
    events = []
    for start, end in items:
        events.append((start, 1))   # 1 for start
        events.append((end, -1))    # -1 for end

    # 2. Sort events
    events.sort()

    current = 0
    max_needed = 0

    # 3. Process events in order
    for time, change in events:
        current += change
        max_needed = max(max_needed, current)

        if max_needed &gt; constraint:
            return False

    return True

# Example Usage: Meeting Rooms
def can_schedule_meetings(meetings, available_rooms):
    return running_window_pattern(meetings, available_rooms)</code></pre>
<h3 id="4-local-exchange-pattern">4. Local Exchange Pattern<a class="headerlink" href="#4-local-exchange-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def local_exchange_pattern(items):
    """
    Universal pattern for local optimization problems.
    Common in: Job scheduling, Task optimization
    """
    result = list(items)  # Create mutable copy
    made_change = True

    while made_change:
        made_change = False
        for i in range(len(result) - 1):
            # Compare adjacent items
            if better_exchange(result[i], result[i + 1]):
                result[i], result[i + 1] = result[i + 1], result[i]
                made_change = True

    return result

# Example Usage: Job Sequencing
def job_sequencing(jobs):
    def better_exchange(job1, job2):
        return (job1.profit/job1.deadline &lt; 
                job2.profit/job2.deadline)

    return local_exchange_pattern(jobs)</code></pre>
<h3 id="5-priority-queue-pattern">5. Priority Queue Pattern<a class="headerlink" href="#5-priority-queue-pattern" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from heapq import heappush, heappop

def priority_queue_pattern(items, k):
    """
    Universal pattern for k-selection problems.
    Common in: K closest points, Top K frequent elements
    """
    heap = []

    for item in items:
        # Maintain heap of size k
        if len(heap) &lt; k:
            heappush(heap, item)
        else:
            if better_than_top(item, heap[0]):
                heappop(heap)
                heappush(heap, item)

    return sorted(heap)  # Return sorted result

# Example Usage: K Closest Points
def k_closest_points(points, k):
    return priority_queue_pattern(
        points,
        k=k
    )</code></pre>
<h3 id="pattern-selection-guide">Pattern Selection Guide<a class="headerlink" href="#pattern-selection-guide" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">pattern_guide = {
    "Sorting-First": {
        "Use When": [
            "Items need to be processed in specific order",
            "Selection based on sorted property",
            "No overlapping allowed"
        ],
        "Examples": [
            "Activity selection",
            "Meeting rooms",
            "Task scheduling"
        ]
    },
    "Fraction/Rate": {
        "Use When": [
            "Divisible items",
            "Optimization based on rates",
            "Knapsack-like problems"
        ],
        "Examples": [
            "Fractional knapsack",
            "Resource allocation",
            "Time management"
        ]
    },
    "Running Window": {
        "Use When": [
            "Time/Space intervals",
            "Resource constraints",
            "Overlapping intervals"
        ],
        "Examples": [
            "Meeting rooms",
            "CPU scheduling",
            "Resource booking"
        ]
    },
    "Local Exchange": {
        "Use When": [
            "Local optimization possible",
            "Pairwise comparisons sufficient",
            "Order matters"
        ],
        "Examples": [
            "Job sequencing",
            "Task ordering",
            "Optimization problems"
        ]
    },
    "Priority Queue": {
        "Use When": [
            "K-selection problems",
            "Running minimum/maximum",
            "Stream processing"
        ],
        "Examples": [
            "K closest points",
            "Top K elements",
            "Running median"
        ]
    }
}</code></pre>
<h2 id="problem-solving-framework">🎯 Problem-Solving Framework<a class="headerlink" href="#problem-solving-framework" title="Permanent link">&para;</a></h2>
<h3 id="1-verify-greedy-approach">1. Verify Greedy Approach<a class="headerlink" href="#1-verify-greedy-approach" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def verify_greedy_approach():
    checks = {
        "Local Choice": "Can we make locally optimal choice?",
        "Subproblem": "Does it lead to simpler subproblem?",
        "Optimality": "Do local choices lead to global optimum?",
        "Constraints": "Are constraints simple and local?"
    }</code></pre>
<h3 id="2-design-steps">2. Design Steps<a class="headerlink" href="#2-design-steps" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Sort if Needed</strong><ul>
<li>Often first step is sorting by key metric</li>
<li>Examples: finish time, value/weight ratio</li>
</ul>
</li>
<li><strong>Define Greedy Choice</strong><ul>
<li>What makes a choice locally optimal?</li>
<li>How to select next element?</li>
</ul>
</li>
<li><strong>Implement Selection Process</strong><ul>
<li>Process elements in sorted order</li>
<li>Apply greedy choice at each step</li>
</ul>
</li>
<li><strong>Track Progress/Result</strong><ul>
<li>Maintain running solution</li>
<li>Update constraints</li>
</ul>
</li>
</ol>
<h2 id="common-pitfalls_2">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_2" title="Permanent link">&para;</a></h2>
<h3 id="1-verification-issues">1. Verification Issues<a class="headerlink" href="#1-verification-issues" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">pitfalls = {
    "Optimality": "Not verifying if greedy leads to optimal",
    "Constraints": "Missing important constraints",
    "Sorting": "Wrong sorting criteria",
    "Edge Cases": "Not handling edge cases"
}</code></pre>
<h3 id="2-implementation-issues">2. Implementation Issues<a class="headerlink" href="#2-implementation-issues" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">implementation_issues = {
    "Initialization": "Incorrect initial values",
    "Updates": "Wrong progress tracking",
    "Termination": "Incorrect stopping condition",
    "Optimization": "Missing optimization opportunities"
}</code></pre>
<h2 id="common-interview-problems_1">📝 Common Interview Problems<a class="headerlink" href="#common-interview-problems_1" title="Permanent link">&para;</a></h2>
<h3 id="1-scheduling-problems">1. Scheduling Problems<a class="headerlink" href="#1-scheduling-problems" title="Permanent link">&para;</a></h3>
<ul>
<li>Activity Selection</li>
<li>Meeting Rooms</li>
<li>Task Scheduling</li>
</ul>
<h3 id="2-optimization-problems">2. Optimization Problems<a class="headerlink" href="#2-optimization-problems" title="Permanent link">&para;</a></h3>
<ul>
<li>Fractional Knapsack</li>
<li>Minimum Coins</li>
<li>Huffman Coding</li>
</ul>
<h3 id="3-connection-problems">3. Connection Problems<a class="headerlink" href="#3-connection-problems" title="Permanent link">&para;</a></h3>
<ul>
<li>Minimum Spanning Tree</li>
<li>Job Sequencing</li>
<li>Shortest Path (Dijkstra's)</li>
</ul>
<h2 id="interview-tips_4">💡 Interview Tips<a class="headerlink" href="#interview-tips_4" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Approach</strong><ul>
<li>Start with greedy hypothesis</li>
<li>Prove/disprove with examples</li>
<li>Consider sorting first</li>
<li>Track progress clearly</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>Use small examples</li>
<li>Find counter-examples</li>
<li>Explain why greedy works</li>
</ul>
</li>
<li><strong>Implementation</strong><ul>
<li>Keep code clean and simple</li>
<li>Handle edge cases</li>
<li>Consider optimization</li>
<li>Test with various inputs</li>
</ul>
</li>
</ol>
<h2 id="time-complexity-analysis_1">🎯 Time Complexity Analysis<a class="headerlink" href="#time-complexity-analysis_1" title="Permanent link">&para;</a></h2>
<p><pre class="highlight"><code class="language-python">complexities = {
    "Sorting Based": "O(n log n) typical",
    "Linear Scan": "O(n) without sorting",
    "Priority Queue": "O(n log k) for k elements",
    "Space": "Usually O(1) or O(n)"
}</code></pre>
Remember:</p>
<ul>
<li>Greedy algorithms are simple but not always optimal</li>
<li>Verify greedy choice property</li>
<li>Consider sorting as first step</li>
<li>Handle edge cases carefully</li>
</ul>
<h1 id="dynamic-programming-from-fundamentals-to-mastery">🎯 Dynamic Programming - From Fundamentals to Mastery<a class="headerlink" href="#dynamic-programming-from-fundamentals-to-mastery" title="Permanent link">&para;</a></h1>
<h2 id="introduction-to-dynamic-programming">📚 Introduction to Dynamic Programming<a class="headerlink" href="#introduction-to-dynamic-programming" title="Permanent link">&para;</a></h2>
<h3 id="what-is-dynamic-programming">What is Dynamic Programming?<a class="headerlink" href="#what-is-dynamic-programming" title="Permanent link">&para;</a></h3>
<p>Dynamic Programming (DP) is both a mathematical optimization method and a programming method that:</p>
<ol>
<li>Breaks down complex problems into simpler subproblems</li>
<li>Stores solutions to these subproblems to avoid recalculating them</li>
<li>Uses stored solutions to build up to the final solution</li>
</ol>
<p>Think of it as "careful brute force" - instead of recalculating values we've seen before, we save them for later use.</p>
<h3 id="when-to-use-dynamic-programming">When to Use Dynamic Programming<a class="headerlink" href="#when-to-use-dynamic-programming" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">criteria_for_dp = {
    "1. Optimal Substructure": """
        Can the problem be broken down into smaller problems?
        Example: Fibonacci numbers - F(n) depends on F(n-1) and F(n-2)
        """,
    "2. Overlapping Subproblems": """
        Do we calculate the same things repeatedly?
        Example: In Fibonacci, F(5) and F(4) both need F(3)
        """,
    "3. No Greedy Choice": """
        Does making the locally optimal choice not always lead to global optimal?
        Example: Coin change problem with coins [1, 15, 25]
        """
}</code></pre>
<h2 id="core-concepts-explained">🎯 Core Concepts Explained<a class="headerlink" href="#core-concepts-explained" title="Permanent link">&para;</a></h2>
<h3 id="1-subproblems-and-optimal-substructure">1. Subproblems and Optimal Substructure<a class="headerlink" href="#1-subproblems-and-optimal-substructure" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def understand_subproblems():
    """
    Example: Finding F(4) in Fibonacci sequence

    F(4) = F(3) + F(2)     # Main problem
    F(3) = F(2) + F(1)     # Subproblem
    F(2) = F(1) + F(0)     # Smaller subproblem

    Properties:
    1. Each subproblem is smaller version of main problem
    2. Solution to main problem depends on subproblems
    3. Base cases stop the recursion
    """
    pass</code></pre>
<h3 id="2-overlapping-subproblems">2. Overlapping Subproblems<a class="headerlink" href="#2-overlapping-subproblems" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def show_overlapping_example(n: int):
    """
    Without DP (lots of repeated calculations):
    F(5)
    ├── F(4)
    │   ├── F(3)
    │   │   ├── F(2)  # Calculated multiple times
    │   │   └── F(1)
    │   └── F(2)      # Calculated again
    └── F(3)
        ├── F(2)      # Calculated yet again
        └── F(1)

    With DP (calculate once, reuse result):
    memo = {
        0: 0,
        1: 1,
        2: F(2),  # Calculate once, reuse many times
        3: F(3),
        ...
    }
    """
    pass</code></pre>
<h2 id="two-main-approaches-to-dp">🎮 Two Main Approaches to DP<a class="headerlink" href="#two-main-approaches-to-dp" title="Permanent link">&para;</a></h2>
<h3 id="1-top-down-memoization">1. Top-Down (Memoization)<a class="headerlink" href="#1-top-down-memoization" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def explain_memoization():
    """
    Top-Down Process:
    1. Start with original problem (top)
    2. Break into subproblems recursively
    3. Store results in memo table
    4. Return memoized results if subproblem seen before

    Advantages:
    - More intuitive (follows natural thinking)
    - Only solves needed subproblems
    - Easier to debug

    Disadvantages:
    - Recursion overhead
    - Stack space usage
    """
    # Example implementation
    def fib_memo(n: int, memo: dict = None) -&gt; int:
        if memo is None:
            memo = {}

        # Base cases
        if n &lt;= 1:
            return n

        # Check memo before computing
        if n in memo:
            return memo[n]

        # Store result in memo
        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
        return memo[n]</code></pre>
<h3 id="2-bottom-up-tabulation">2. Bottom-Up (Tabulation)<a class="headerlink" href="#2-bottom-up-tabulation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def explain_tabulation():
    """
    Bottom-Up Process:
    1. Start with base cases (bottom)
    2. Build larger solutions from smaller ones
    3. Store results in table
    4. Use table to build final solution

    Advantages:
    - More space efficient
    - No recursion overhead
    - Better cache performance

    Disadvantages:
    - May solve unnecessary subproblems
    - Sometimes less intuitive
    """
    # Example implementation
    def fib_table(n: int) -&gt; int:
        if n &lt;= 1:
            return n

        # Initialize table with base cases
        dp = [0] * (n + 1)
        dp[1] = 1

        # Build up the solution
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]</code></pre>
<h2 id="problem-solving-framework_1">🎯 Problem-Solving Framework<a class="headerlink" href="#problem-solving-framework_1" title="Permanent link">&para;</a></h2>
<h3 id="step-1-identify-dp-characteristics">Step 1: Identify DP Characteristics<a class="headerlink" href="#step-1-identify-dp-characteristics" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def identify_dp_potential(problem):
    """
    Ask these questions:
    1. Can I break this into smaller similar subproblems?
    2. Does solving subproblems help solve the original problem?
    3. Am I calculating same things repeatedly?
    4. Can I store and reuse these calculations?
    """
    checklist = {
        "Optimal Substructure": False,
        "Overlapping Subproblems": False,
        "Need for Optimization": False
    }
    return all(checklist.values())</code></pre>
<h3 id="step-2-define-the-subproblem">Step 2: Define the Subproblem<a class="headerlink" href="#step-2-define-the-subproblem" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def define_subproblem():
    """
    1. State Definition:
    - What variables define a subproblem?
    - What information needed to solve it?

    2. State Transition:
    - How do I move from one state to another?
    - What choices do I have at each state?

    Example (Knapsack):
    - State: dp[i][w] = max value using items[0..i] with weight limit w
    - Transition: Choose whether to include item i or not
    """
    pass</code></pre>
<h3 id="step-3-write-the-recurrence-relation">Step 3: Write the Recurrence Relation<a class="headerlink" href="#step-3-write-the-recurrence-relation" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def create_recurrence():
    """
    1. Base Cases:
    - Smallest possible subproblem
    - Starting point for computation

    2. Recurrence Formula:
    - How larger problems relate to smaller ones
    - Mathematical relationship between states

    Example (Knapsack):
    dp[i][w] = max(
        dp[i-1][w],                    # Don't take item
        dp[i-1][w-weight[i]] + val[i]  # Take item
    )
    """
    pass</code></pre>
<h3 id="step-4-implement-solution">Step 4: Implement Solution<a class="headerlink" href="#step-4-implement-solution" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def implement_solution():
    """
    Choose Implementation Style:
    1. Top-Down if:
    - Natural recursive solution
    - Not all subproblems needed
    - Need to debug/understand easily

    2. Bottom-Up if:
    - Need to optimize space
    - All subproblems needed
    - Want to avoid recursion
    """
    pass</code></pre>
<h2 id="common-dp-patterns">🎯 Common DP Patterns<a class="headerlink" href="#common-dp-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-linear-sequence">1. Linear Sequence<a class="headerlink" href="#1-linear-sequence" title="Permanent link">&para;</a></h3>
<p>Used when each state depends on previous states.
<pre class="highlight"><code class="language-python">def linear_dp_example():
    # Example: House Robber Problem
    def rob(nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

        return dp[-1]</code></pre></p>
<h3 id="2-matrix-chain">2. Matrix Chain<a class="headerlink" href="#2-matrix-chain" title="Permanent link">&para;</a></h3>
<p>Used for optimization problems involving sequences.
<pre class="highlight"><code class="language-python">def matrix_chain_example():
    # Example: Matrix Chain Multiplication
    def matrix_mult_cost(dimensions: List[int]) -&gt; int:
        n = len(dimensions) - 1
        dp = [[0] * n for _ in range(n)]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                dp[i][j] = float('inf')
                for k in range(i, j):
                    cost = (dp[i][k] + dp[k+1][j] + 
                           dimensions[i] * dimensions[k+1] * dimensions[j+1])
                    dp[i][j] = min(dp[i][j], cost)

        return dp[0][n-1]</code></pre></p>
<h3 id="3-interval-problems">3. Interval Problems<a class="headerlink" href="#3-interval-problems" title="Permanent link">&para;</a></h3>
<p>Used when dealing with ranges or intervals.
<pre class="highlight"><code class="language-python">def interval_dp_example():
    # Example: Palindrome Partitioning
    def min_cuts(s: str) -&gt; int:
        n = len(s)
        # is_palindrome[i][j] tells if s[i:j+1] is palindrome
        is_palindrome = [[False] * n for _ in range(n)]

        # Single letters are palindromes
        for i in range(n):
            is_palindrome[i][i] = True

        # Check for palindromes of length 2 and more
        for length in range(2, n + 1):
            for start in range(n - length + 1):
                end = start + length - 1
                if length == 2:
                    is_palindrome[start][end] = (s[start] == s[end])
                else:
                    is_palindrome[start][end] = (
                        s[start] == s[end] and 
                        is_palindrome[start+1][end-1]
                    )

        # dp[i] = minimum cuts needed for s[0:i+1]
        dp = [0] * n
        for i in range(n):
            if is_palindrome[0][i]:
                dp[i] = 0
            else:
                dp[i] = i
                for j in range(i):
                    if is_palindrome[j+1][i]:
                        dp[i] = min(dp[i], dp[j] + 1)

        return dp[n-1]</code></pre></p>
<h2 id="advanced-optimization-techniques">💡 Advanced Optimization Techniques<a class="headerlink" href="#advanced-optimization-techniques" title="Permanent link">&para;</a></h2>
<h3 id="1-space-optimization">1. Space Optimization<a class="headerlink" href="#1-space-optimization" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def space_optimization_example():
    """
    Common Techniques:
    1. Rolling Array
    - Keep only last k states
    - Use mod operator for indexing

    2. State Compression
    - Use bits to represent states
    - Reduce dimension of dp table

    Example: Fibonacci with O(1) space
    """
    def fib_optimized(n: int) -&gt; int:
        if n &lt;= 1:
            return n
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b</code></pre>
<h3 id="2-state-reduction">2. State Reduction<a class="headerlink" href="#2-state-reduction" title="Permanent link">&para;</a></h3>
<p><pre class="highlight"><code class="language-python">def state_reduction_example():
    """
    Techniques:
    1. Eliminate Redundant States
    - Identify states that can be derived
    - Combine overlapping states

    2. Change State Representation
    - More efficient encoding
    - Different perspective on problem

    Example: Reducing 2D DP to 1D
    """
    # Original 2D Knapsack
    def knapsack_2d(weights: List[int], values: List[int], capacity: int) -&gt; int:
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]

        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i-1] &lt;= w:
                    dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], 
                                 dp[i-1][w])
                else:
                    dp[i][w] = dp[i-1][w]
        return dp[n][capacity]

    # Optimized 1D Knapsack
    def knapsack_1d(weights: List[int], values: List[int], capacity: int) -&gt; int:
        dp = [0] * (capacity + 1)

        for i in range(len(weights)):
            for w in range(capacity, weights[i]-1, -1):
                dp[w] = max(dp[w], dp[w-weights[i]] + values[i])
        return dp[capacity]</code></pre>
Remember:</p>
<ul>
<li>Always start with a clear understanding of subproblems</li>
<li>Draw out the recurrence relation</li>
<li>Consider both top-down and bottom-up approaches</li>
<li>Look for optimization opportunities</li>
<li>Test with small cases first</li>
</ul>
<h3 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/aPQY__2H3tE?si=kF10ZwFUbYQa1s0B">Dynamic Programming</a></p>
<h1 id="graphs-graph-theory">📊 Graphs &amp; Graph Theory<a class="headerlink" href="#graphs-graph-theory" title="Permanent link">&para;</a></h1>
<h2 id="core-concepts_2">📚 Core Concepts<a class="headerlink" href="#core-concepts_2" title="Permanent link">&para;</a></h2>
<h3 id="what-is-a-graph">What is a Graph?<a class="headerlink" href="#what-is-a-graph" title="Permanent link">&para;</a></h3>
<p>A graph is a data structure consisting of:</p>
<ul>
<li><strong>Vertices (Nodes)</strong>: Points in the graph</li>
<li><strong>Edges</strong>: Connections between vertices</li>
<li><strong>Optional Properties</strong>: Weights, directions, labels</li>
</ul>
<p>Types of Graphs:
<pre class="highlight"><code class="language-python">graph_types = {
    "Undirected": "Edges have no direction (Facebook friendships)",
    "Directed": "Edges have direction (Twitter follows)",
    "Weighted": "Edges have weights (Road distances)",
    "Connected": "Path exists between any two vertices",
    "Cyclic": "Contains at least one cycle",
    "Acyclic": "Contains no cycles (trees are acyclic)"
}</code></pre></p>
<h2 id="graph-representations">🎯 Graph Representations<a class="headerlink" href="#graph-representations" title="Permanent link">&para;</a></h2>
<h3 id="1-adjacency-list-most-common-in-interviews">1. Adjacency List (Most Common in Interviews)<a class="headerlink" href="#1-adjacency-list-most-common-in-interviews" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class Graph:
    def __init__(self):
        self.graph = {}

    def add_vertex(self, vertex):
        if vertex not in self.graph:
            self.graph[vertex] = set()

    def add_edge(self, v1, v2):
        if v1 not in self.graph:
            self.add_vertex(v1)
        if v2 not in self.graph:
            self.add_vertex(v2)
        self.graph[v1].add(v2)
        self.graph[v2].add(v1)  # Remove for directed graph</code></pre>
<h3 id="2-adjacency-matrix">2. Adjacency Matrix<a class="headerlink" href="#2-adjacency-matrix" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class GraphMatrix:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]

    def add_edge(self, v1, v2, weight=1):
        self.graph[v1][v2] = weight
        self.graph[v2][v1] = weight  # Remove for directed graph</code></pre>
<h2 id="essential-graph-operations">🎮 Essential Graph Operations<a class="headerlink" href="#essential-graph-operations" title="Permanent link">&para;</a></h2>
<h3 id="1-graph-traversal">1. Graph Traversal<a class="headerlink" href="#1-graph-traversal" title="Permanent link">&para;</a></h3>
<h3 id="bfs-breadth-first-search">BFS (Breadth-First Search)<a class="headerlink" href="#bfs-breadth-first-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from collections import deque

def bfs(graph, start):
    """
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Finding shortest paths
    - Level-by-level traversal
    - Finding nodes at distance k
    """
    visited = set([start])
    queue = deque([start])

    while queue:
        vertex = queue.popleft()

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return visited</code></pre>
<h3 id="dfs-depth-first-search">DFS (Depth-First Search)<a class="headerlink" href="#dfs-depth-first-search" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def dfs(graph, start, visited=None):
    """
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Finding paths/cycles
    - Exhaustively exploring paths
    - Topological sorting
    """
    if visited is None:
        visited = set()

    visited.add(start)

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

# Iterative DFS (often preferred in interviews)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(neighbor for neighbor in graph[node] 
                        if neighbor not in visited)
    return visited</code></pre>
<h3 id="2-path-finding">2. Path Finding<a class="headerlink" href="#2-path-finding" title="Permanent link">&para;</a></h3>
<h3 id="find-path-between-two-vertices">Find Path Between Two Vertices<a class="headerlink" href="#find-path-between-two-vertices" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def find_path(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]

    if start == end:
        return path

    for neighbor in graph[start]:
        if neighbor not in path:
            new_path = find_path(graph, neighbor, end, path)
            if new_path:
                return new_path
    return None</code></pre>
<h3 id="find-all-paths">Find All Paths<a class="headerlink" href="#find-all-paths" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def find_all_paths(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]

    if start == end:
        return [path]

    paths = []
    for neighbor in graph[start]:
        if neighbor not in path:
            new_paths = find_all_paths(graph, neighbor, end, path)
            paths.extend(new_paths)
    return paths</code></pre>
<h2 id="common-graph-algorithms-for-interviews">🎯 Common Graph Algorithms for Interviews<a class="headerlink" href="#common-graph-algorithms-for-interviews" title="Permanent link">&para;</a></h2>
<h3 id="1-detect-cycle">1. Detect Cycle<a class="headerlink" href="#1-detect-cycle" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def dfs_cycle(vertex):
        visited.add(vertex)
        rec_stack.add(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                if dfs_cycle(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(vertex)
        return False

    for vertex in graph:
        if vertex not in visited:
            if dfs_cycle(vertex):
                return True
    return False</code></pre>
<h3 id="2-topological-sort">2. Topological Sort<a class="headerlink" href="#2-topological-sort" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def topological_sort(graph):
    """
    For directed acyclic graphs (DAGs)
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Scheduling with dependencies
    - Build systems
    - Course prerequisites
    """
    def dfs(node):
        if node in visited:
            return
        visited.add(node)

        for neighbor in graph[node]:
            dfs(neighbor)
        result.append(node)

    visited = set()
    result = []

    for node in graph:
        dfs(node)

    return result[::-1]  # Reverse for correct order

# Alternative: Kahn's Algorithm (BFS-based)
def topological_sort_kahn(graph):
    in_degree = {node: 0 for node in graph}
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] += 1

    queue = deque([node for node, degree in in_degree.items() if degree == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return result if len(result) == len(graph) else []  # Check for cycles</code></pre>
<h3 id="3-connected-components">3. Connected Components<a class="headerlink" href="#3-connected-components" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def find_connected_components(graph):
    def dfs_component(vertex, component):
        visited.add(vertex)
        component.append(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                dfs_component(neighbor, component)

    visited = set()
    components = []

    for vertex in graph:
        if vertex not in visited:
            current_component = []
            dfs_component(vertex, current_component)
            components.append(current_component)

    return components</code></pre>
<h3 id="4-shortest-path-algorithms">4. Shortest Path Algorithms<a class="headerlink" href="#4-shortest-path-algorithms" title="Permanent link">&para;</a></h3>
<h4 id="dijkstras-algorithm">Dijkstra's Algorithm<a class="headerlink" href="#dijkstras-algorithm" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-python">import heapq

def dijkstra(graph, start):
    """
    For weighted graphs with non-negative edges
    Time: O((V + E) log V)
    Space: O(V)
    Use when:
    - Finding shortest paths
    - Network routing
    - GPS navigation
    """
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    pq = [(0, start)]

    while pq:
        current_distance, current = heapq.heappop(pq)

        if current_distance &gt; distances[current]:
            continue

        for neighbor, weight in graph[current].items():
            distance = current_distance + weight

            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances</code></pre>
<h3 id="5-union-find-disjoint-set">5. Union Find (Disjoint Set)<a class="headerlink" href="#5-union-find-disjoint-set" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class UnionFind:
    """
    Time: O(α(n)) per operation (practically O(1))
    Space: O(n)
    Use when:
    - Finding connected components
    - Cycle detection
    - Minimum spanning trees
    """
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False

        # Union by rank
        if self.rank[px] &lt; self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] &gt; self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        return True</code></pre>
<h2 id="interview-problem-patterns">📝 Interview Problem Patterns<a class="headerlink" href="#interview-problem-patterns" title="Permanent link">&para;</a></h2>
<h3 id="1-graph-traversal-problems">1. Graph Traversal Problems<a class="headerlink" href="#1-graph-traversal-problems" title="Permanent link">&para;</a></h3>
<ul>
<li>Visiting all nodes/edges</li>
<li>Finding connected components</li>
<li>Level-order traversal
<pre class="highlight"><code class="language-python">traversal_tips = {
    "BFS": "Use when:- Finding shortest path- Level by level traversal- Minimum steps",
    "DFS": "Use when:- Exploring paths- Finding cycles- Topological sorting",
    "Edge Cases": "- Empty graph- Single node- Disconnected components"
}</code></pre></li>
</ul>
<h3 id="2-path-finding-problems">2. Path Finding Problems<a class="headerlink" href="#2-path-finding-problems" title="Permanent link">&para;</a></h3>
<ul>
<li>Shortest path</li>
<li>All possible paths</li>
<li>Path with constraints
<pre class="highlight"><code class="language-python">def shortest_path(graph, start, end):
    queue = deque([(start, [start])])
    visited = {start}

    while queue:
        vertex, path = queue.popleft()
        if vertex == end:
            return path

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return None</code></pre></li>
</ul>
<h2 id="interview-tips_5">💡 Interview Tips<a class="headerlink" href="#interview-tips_5" title="Permanent link">&para;</a></h2>
<ol>
<li><strong>Representation Choice</strong>
<pre class="highlight"><code class="language-python">choosing_representation = {
    "Adjacency List": "- Sparse graphs- Memory efficient- Quick neighbor lookup",
    "Adjacency Matrix": "- Dense graphs- Quick edge weight lookup- Simple implementation"
}</code></pre></li>
<li><strong>Algorithm Selection</strong>
<pre class="highlight"><code class="language-python">algorithm_selection = {
    "BFS": "Shortest path in unweighted graph",
    "DFS": "Path finding, cycle detection",
    "Dijkstra": "Shortest path in weighted graph",
    "Union Find": "Connected components, cycle detection in undirected graph"
}</code></pre>
<pre class="highlight"><code class="language-python">selection_guide = {
    "Shortest Path (Unweighted)": "Use BFS",
    "Shortest Path (Weighted, Non-negative)": "Use Dijkstra",
    "Shortest Path (Weighted, Can be negative)": "Use Bellman-Ford",
    "Cycle Detection": "Use DFS with recursion stack",
    "Component Finding": "Use Union Find or DFS",
    "Dependency Ordering": "Use Topological Sort",
    "Two-Coloring Problems": "Use Bipartite Check"
}</code></pre></li>
<li>
<p><strong>Edge Cases to Consider</strong>
<pre class="highlight"><code class="language-python">edge_cases = [
    "Empty graph",
    "Single node",
    "Disconnected components",
    "Cycles",
    "Self-loops",
    "Bidirectional edges",
    "No path exists"
]</code></pre></p>
</li>
<li>
<p><strong>Optimization Tips</strong>:</p>
</li>
<li>
<p>Use adjacency list for sparse graphs</p>
</li>
<li>Use adjacency matrix for dense graphs</li>
<li>Consider using iterative DFS instead of recursive for large graphs</li>
<li>Use Union Find for dynamic connectivity problems</li>
<li>Cache results in graph traversal when possible</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always clarify the graph properties (directed/undirected, weighted/unweighted)</li>
<li>Consider time/space complexity tradeoffs</li>
<li>Draw examples when solving</li>
<li>Test with small cases first</li>
<li>Consider using helper functions for complex logic</li>
</ul>
<h1 id="minimum-spanning-trees-mst">🌳 Minimum Spanning Trees (MST)<a class="headerlink" href="#minimum-spanning-trees-mst" title="Permanent link">&para;</a></h1>
<h2 id="core-concepts_3">📚 Core Concepts<a class="headerlink" href="#core-concepts_3" title="Permanent link">&para;</a></h2>
<h3 id="what-is-a-minimum-spanning-tree">What is a Minimum Spanning Tree?<a class="headerlink" href="#what-is-a-minimum-spanning-tree" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">"""
A Minimum Spanning Tree (MST) is a subset of edges in a connected, 
undirected, weighted graph that:
1. Connects all vertices
2. Contains no cycles
3. Has minimum total edge weight among all possible spanning trees

Properties:
- Contains exactly V-1 edges (where V is number of vertices)
- May not be unique (graph can have multiple MSTs)
- Always unique if all edge weights are different
"""</code></pre>
<h2 id="key-algorithms">🎯 Key Algorithms<a class="headerlink" href="#key-algorithms" title="Permanent link">&para;</a></h2>
<h3 id="1-kruskals-algorithm">1. Kruskal's Algorithm<a class="headerlink" href="#1-kruskals-algorithm" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        # Union by rank
        if self.rank[px] &lt; self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] &gt; self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        return True

def kruskal_mst(graph, V):
    """
    Time: O(E log E) where E is number of edges
    Space: O(V) where V is number of vertices

    Use when:
    - Graph is sparse (E &lt;&lt; V²)
    - Graph might not be connected
    - Edge weights are primary consideration
    """
    edges = []  # (weight, u, v)
    for u in range(V):
        for v, w in graph[u]:
            edges.append((w, u, v))

    edges.sort()  # Sort by weight
    uf = UnionFind(V)
    mst = []
    mst_weight = 0

    for weight, u, v in edges:
        if uf.union(u, v):  # If no cycle is created
            mst.append((u, v))
            mst_weight += weight
            if len(mst) == V - 1:
                break

    return mst, mst_weight</code></pre>
<h3 id="2-prims-algorithm">2. Prim's Algorithm<a class="headerlink" href="#2-prims-algorithm" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">from heapq import heappush, heappop

def prim_mst(graph, V):
    """
    Time: O(E log V) with min-heap
    Space: O(V)

    Use when:
    - Graph is dense (E ≈ V²)
    - Graph is guaranteed to be connected
    - Starting vertex is known/important
    """
    visited = [False] * V
    min_heap = [(0, 0, -1)]  # (weight, vertex, parent)
    mst = []
    mst_weight = 0

    while min_heap:
        weight, vertex, parent = heappop(min_heap)

        if visited[vertex]:
            continue

        visited[vertex] = True
        if parent != -1:
            mst.append((parent, vertex))
            mst_weight += weight

        for next_vertex, edge_weight in graph[vertex]:
            if not visited[next_vertex]:
                heappush(min_heap, (edge_weight, next_vertex, vertex))

    return mst, mst_weight</code></pre>
<h2 id="algorithm-selection-guide">🎮 Algorithm Selection Guide<a class="headerlink" href="#algorithm-selection-guide" title="Permanent link">&para;</a></h2>
<h3 id="when-to-use-each-algorithm">When to Use Each Algorithm<a class="headerlink" href="#when-to-use-each-algorithm" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def choose_mst_algorithm(graph_properties):
    selection_guide = {
        "Kruskal": {
            "Best for": [
                "Sparse graphs (E &lt;&lt; V²)",
                "When graph might be disconnected",
                "When edge weights are the focus"
            ],
            "Advantages": [
                "Works with disconnected graphs",
                "Tends to be simpler to implement",
                "Good for sparse graphs"
            ]
        },
        "Prim": {
            "Best for": [
                "Dense graphs (E ≈ V²)",
                "When starting vertex matters",
                "When graph is connected"
            ],
            "Advantages": [
                "Better for dense graphs",
                "Can find partial MSTs",
                "More efficient with priority queue"
            ]
        }
    }</code></pre>
<h2 id="common-interview-problems_2">📝 Common Interview Problems<a class="headerlink" href="#common-interview-problems_2" title="Permanent link">&para;</a></h2>
<h3 id="1-connecting-cities-with-minimum-cost">1. Connecting Cities with Minimum Cost<a class="headerlink" href="#1-connecting-cities-with-minimum-cost" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def min_cost_connect_cities(connections, N):
    """
    Given a list of connections [city1, city2, cost],
    find minimum cost to connect all cities
    """
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        parent[px] = py
        return True

    parent = list(range(N + 1))
    connections.sort(key=lambda x: x[2])  # Sort by cost

    total_cost = 0
    edges_used = 0

    for city1, city2, cost in connections:
        if union(city1, city2):
            total_cost += cost
            edges_used += 1

    return total_cost if edges_used == N - 1 else -1</code></pre>
<h3 id="2-network-optimization">2. Network Optimization<a class="headerlink" href="#2-network-optimization" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">def optimize_network(nodes, connections):
    """
    Optimize network connections while maintaining
    minimum latency between all nodes
    """
    def mst_with_constraints(edges):
        uf = UnionFind(len(nodes))
        mst = []
        total_latency = 0

        for u, v, latency in sorted(edges, key=lambda x: (x[2], x[0])):
            if uf.union(u, v):
                mst.append((u, v))
                total_latency += latency

        return mst, total_latency if len(mst) == len(nodes) - 1 else float('inf')</code></pre>
<h2 id="interview-tips_6">💡 Interview Tips<a class="headerlink" href="#interview-tips_6" title="Permanent link">&para;</a></h2>
<h3 id="1-problem-recognition">1. Problem Recognition<a class="headerlink" href="#1-problem-recognition" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">mst_indicators = {
    "Minimum cost/distance/weight": "Total weight needs to be minimized",
    "Connect all points": "Need spanning tree property",
    "No cycles allowed": "Tree structure required",
    "Optimize network": "Network optimization problems",
    "Reduce redundancy": "Remove unnecessary edges"
}</code></pre>
<h3 id="2-implementation-strategy">2. Implementation Strategy<a class="headerlink" href="#2-implementation-strategy" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-python">implementation_tips = {
    "1. Graph Representation": [
        "Adjacency list for sparse graphs",
        "Adjacency matrix for dense graphs",
        "Edge list for Kruskal's"
    ],
    "2. Edge Cases": [
        "Empty graph",
        "Single node",
        "Disconnected components",
        "Equal edge weights"
    ],
    "3. Optimization": [
        "Use Union-Find for cycle detection",
        "Priority queue for Prim's",
        "Sort edges once for Kruskal's"
    ]
}</code></pre>
<h3 id="3-common-mistakes-to-avoid">3. Common Mistakes to Avoid<a class="headerlink" href="#3-common-mistakes-to-avoid" title="Permanent link">&para;</a></h3>
<p><pre class="highlight"><code class="language-python">common_mistakes = {
    "Algorithm Selection": "Not considering graph density",
    "Cycle Detection": "Forgetting to check for cycles",
    "Edge Processing": "Not handling duplicate edges",
    "Disconnected Graphs": "Assuming graph is connected",
    "Edge Weights": "Not handling negative weights"
}</code></pre>
Remember:</p>
<ul>
<li>Always verify if graph is connected when using Prim's</li>
<li>Consider edge cases (empty graph, single node)</li>
<li>Watch for negative edge weights</li>
<li>Check if all vertices are included in final MST</li>
<li>Consider trade-offs between algorithms based on graph properties</li>
</ul>
<h1 id="technical-interview-patterns">Technical Interview Patterns<a class="headerlink" href="#technical-interview-patterns" title="Permanent link">&para;</a></h1>
<p><a href="https://blog.algomaster.io/p/15-leetcode-patterns">Common Technical Interview Patterns</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../1.Fundamentals/d_python/" class="btn btn-neutral float-left" title="Python"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../../1.Fundamentals/d_python/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
