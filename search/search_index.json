{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>As a software engineer, I created this handbook to serve as my own personal \"second brain\" - a living repository of knowledge, experiences, and learning that will go with me throughout my career. While others may find value in this documentation, its primary purpose is to help me grow and excel in my software engineering journey.</p>"},{"location":"#why-i-created-this-handbook","title":"Why I Created This Handbook","text":"<p>The inspiration for this handbook came from a common challenge I faced, that I also feel others continuously face as well: the need to constantly revisit, relearn, and recall various aspects of software engineering. I found myself:</p> <ul> <li>Repeatedly searching for solutions I had previously implemented</li> <li>Needing a reliable way to document my learning experiences</li> <li>Wanting to track my growth and evolution as a developer</li> <li>Desiring a structured way to build upon my knowledge</li> </ul> <p>This handbook serves as my personal knowledge management system, helping me maintain and expand my expertise while reducing cognitive load.</p>"},{"location":"#structure-of-my-knowledge-base","title":"Structure of My Knowledge Base","text":"<p>I've organized this handbook to reflect the key areas of my software engineering practice:</p> <p>\ud83d\udd2e Fundamentals</p> <p>Core concepts I need to maintain and regularly revisit, including programming principles, data structures, and algorithms.</p> <p>\ud83d\udcbb Programming Languages</p> <p>Documentation of my experience with Python, JavaScript/TypeScript, Java, Go, Rust, and C/C++:</p> <ul> <li>Language-specific patterns that I frequently use</li> <li>Solutions to common challenges</li> <li>Language-specific syntax overviews of each for review</li> <li>Personal coding preferences and style notes</li> <li>Tips and tricks to remember</li> </ul> <p>\ud83d\udee0 Tools and Technologies My setup and configurations for:</p> <ul> <li>Version control workflows</li> <li>IDE customizations</li> <li>Debugging approaches</li> <li>Container configurations</li> </ul> <p>\ud83d\udcd0 Architecture and Design</p> <p>Time tested insights, personal experiences, and learnings with:</p> <ul> <li>Design patterns</li> <li>Microservices architecture</li> <li>Tradoffs between different architectural approaches</li> </ul> <p>\ud83d\udcbe Database Systems</p> <p>My learnings, readings, and knowledge of:</p> <ul> <li>SQL and NoSQL as well as their various implementations</li> <li>ORM configurations</li> <li>Database design decisions and their outcomes</li> </ul> <p>\ud83d\ude80 DevOps and Deployment</p> <p>Here will be documentation of my preferred:</p> <ul> <li>CI/CD pipeline setups</li> <li>Monitoring solutions</li> <li>Cloud service configurations</li> </ul> <p>\ud83d\udccb Project Management</p> <p>Here you'll find my notes and learnings on process improvements and team collaboration.</p> <p>\ud83d\udc68\u200d\ud83d\udcbb Professional Development</p> <p>Here is where you'll find tracking my career growth through:</p> <ul> <li>My own growth in personal coding standards and skill</li> <li>Code review insights that I receive as I gain in seniority</li> <li>Learning resources that I find valuable as time goes on</li> </ul>"},{"location":"#how-i-use-this-handbook","title":"How I Use This Handbook","text":""},{"location":"#daily-work","title":"Daily Work","text":"<ol> <li>Quick references for common tasks</li> <li>Documentation of solutions to recurring problems</li> <li>Storage for useful code snippets and patterns I find myself continually searching for</li> </ol>"},{"location":"#learning-and-growth","title":"Learning and Growth","text":"<ol> <li>Recording new concepts as I learn them</li> <li>Documenting lessons learned from projects that I take on and contribute to</li> <li>Tracking my evolution in different technical areas</li> </ol>"},{"location":"#career-development","title":"Career Development","text":"<ol> <li>Maintaining a record of my growing expertise</li> <li>Tracking projects and their outcomes</li> <li>Noting areas for future learning and improvement</li> </ol>"},{"location":"#benefits-of-maintaining-this-knowledge-base","title":"Benefits of Maintaining This Knowledge Base","text":""},{"location":"#1-personal-reference","title":"1. Personal Reference","text":"<ul> <li>It provides quick access to my preferred solutions</li> <li>Documents my learning journey as my career progresses</li> <li>Records my decisions and their outcomes for better feedback loops</li> </ul>"},{"location":"#2-knowledge-retention","title":"2. Knowledge Retention","text":"<ul> <li>Structured documentation of knowledge reduces cognitive overhead</li> <li>Reduces the need to continually search for answers to common problems I encounter</li> <li>Provides a base level floor of knowledge that I can always build off of as my field changes i.e. \"first-principles\".</li> </ul>"},{"location":"#3-career-growth","title":"3. Career Growth","text":"<ul> <li>Portfolio of my technical knowledge</li> <li>Record of problem-solving appraoches</li> <li>Documentation of my professional evolution</li> </ul>"},{"location":"#living-documentation","title":"Living Documentation","text":"<p>This handbook grows with my career, reflecting:</p> <ul> <li>New technologies I learn</li> <li>Projects I complete</li> <li>Challenges I overcome</li> <li>Insights I gain</li> <li>Skills I develop</li> </ul> <p>While others may find value in this documentation, its primary purpose is to serve as my personal knowledge repository, helping me become a better software engineer. It represents my journey, my learnings, and my growth in the field.</p> <p>As I continue to learn and evolve in my career, this handbook will remain my trusted companion, growing and adapting with each new experience and challenge.</p>"},{"location":"1.Fundamentals/a_object_oriented_programming/","title":"Object Oriented Programming","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#introduction","title":"Introduction","text":"<p>As a software engineer, mastering programming fundamentals is fundamental to writing maintainable, scalable, and efficient code. This guide focuses on Object-Oriented Programming (OOP), one of the most important paradigms in modern software development.</p>"},{"location":"1.Fundamentals/a_object_oriented_programming/#why-object-oriented-programming","title":"Why Object-Oriented Programming?","text":"<p>I've personally found OOP to be crucial so far in my journey as a software engineer. OOP is important because:</p> <ul> <li>It helps manage complex systems by breaking them into manageable pieces</li> <li>Promotes code reuse and reduces redundancy</li> <li>Makes code more maintainable and easier to debug</li> <li>Facilitates team collaboration through clear interfaces</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use-oop","title":"When to Use OOP","text":"<ul> <li>When building medium to large-scale applications</li> <li>Working on long-term maintainable projects</li> <li>Developing systems with clear entity relationships</li> <li>Creating frameworks or libraries</li> <li>Working with domain-driven design</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-not-to-use-oop","title":"When Not to Use OOP","text":"<ul> <li>Simple script-like programs</li> <li>One-off automation tasks</li> <li>Performance-critical systems where procedural code might be more efficient</li> <li>Functional programming scenarios</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#core-concepts","title":"Core Concepts","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#classes-and-objects","title":"Classes and Objects","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#what-are-they","title":"What Are They?","text":"<ul> <li>Class: A blueprint for creating objects, defining their properties and behaviors</li> <li>Object: An instance of a class with actual values</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-create-a-class","title":"When to Create a Class","text":"<ul> <li>When modeling real-world entities (e.g., User, Product)</li> <li>When grouping related functionality</li> <li>When you need multiple instances with similar properties</li> <li>When implementing a design pattern</li> </ul> <pre><code>public class User {\n    // Properties (state)\n    private String username;\n    private String email;\n\n    // Constructor\n    public User(String username, String email) {\n        this.username = username;\n        this.email = email;\n    }\n\n    // Methods (behavior)\n    public void updateEmail(String newEmail) {\n        this.email = newEmail;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#encapsulation","title":"Encapsulation","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#what-is-it","title":"What Is It?","text":"<p>Encapsulation bundles data and the methods that it operates on within a single unit, restricting direct access to some of an object's components.</p>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use","title":"When to Use","text":"<ul> <li>Protecting internal state of objects</li> <li>Controlling access to data</li> <li>Hiding implementation details</li> <li>Enforcing validation logic</li> </ul> <pre><code>public class BankAccount {\n    private double balance;  // Encapsulated data\n\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        } else {\n            throw new IllegalArgumentException(\"Deposit amount must be positive\");\n        }\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#inheritance","title":"Inheritance","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#what-is-it_1","title":"What Is It?","text":"<p>Inheritance allows a class to inherit attributes and methods from another class, establishing an \"is-a\" relationship.</p>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use_1","title":"When to Use","text":"<ul> <li>Creating specialized versions of classes</li> <li>Sharing common functionality among related classes</li> <li>Implementing polymorphic behavior</li> <li>Building class hierarchies</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-not-to-use","title":"When Not to Use","text":"<ul> <li>When there's no clear \"is-a\" relationship</li> <li>When you need flexibility in changing behavior</li> <li>When inheritance would create deep hierarchies</li> <li>When composition would be more appropriate</li> </ul> <pre><code>public abstract class Vehicle {\n    protected String brand;\n\n    public abstract void start();\n}\n\npublic class Car extends Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car starting...\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#polymorphism","title":"Polymorphism","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#what-is-it_2","title":"What Is It?","text":"<p>Polymorphism allows objects to take multiple forms, enabling you to perform the same action in different ways.</p>"},{"location":"1.Fundamentals/a_object_oriented_programming/#types-of-polymorphism","title":"Types of Polymorphism","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#1-compile-time-method-overloading","title":"1. Compile-time (Method Overloading)","text":"<ul> <li>Same method name, different parameters</li> <li>Resolve at compile time</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#2-runtime-method-overriding","title":"2. Runtime (Method Overriding)","text":"<ul> <li>Same method signature in parent and child classes</li> <li>Resolved at runtime</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use_2","title":"When to Use","text":"<ul> <li>Creating flexible and extensible APIs</li> <li>Implementing plugins or extensions</li> <li>Working with collections of related objects</li> <li>Building framework-level code <pre><code>// Method Overloading\npublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n}\n\n// Method Overriding\npublic interface PaymentProcessor {\n    void processPayment(double amount);\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        // Credit card specific logic\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#association-aggregation-and-composition","title":"Association, Aggregation, and Composition","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#association","title":"Association","text":"<ul> <li>Represents relationships between objects</li> <li>Can be one-to-one, one-to-many, or many-to-many</li> <li>Objects have independent lifecycles</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use-association","title":"When to Use Association","text":"<ul> <li>When objects need to communicate</li> <li>When representing relationships between independent entities</li> <li>When objects can exist independently</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#one-to-one-association","title":"One-to-One Association","text":"<pre><code>public class Person {\n    private Passport passport;  // One person has exactly one passport\n\n    public Person() {}\n\n    public void setPassport(Passport passport) {\n        this.passport = passport;\n    }\n\n    public Passport getPassport() {\n        return passport;\n    }\n}\n\npublic class Passport {\n    private Person owner;  // One passport belongs to exactly one person\n    private String passportNumber;\n\n    public Passport(String passportNumber) {\n        this.passportNumber = passportNumber;\n    }\n\n    public void setOwner(Person person) {\n        this.owner = person;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#one-to-many-association","title":"One-to-Many Association","text":"<pre><code>public class Department {\n    private String name;\n    private List&lt;Employee&gt; employees;  // One department has many employees\n\n    public Department(String name) {\n        this.name = name;\n        this.employees = new ArrayList&lt;&gt;();\n    }\n\n    public void addEmployee(Employee employee) {\n        employees.add(employee);\n    }\n\n    public List&lt;Employee&gt; getEmployees() {\n        return new ArrayList&lt;&gt;(employees);  // Return copy for encapsulation\n    }\n}\n\npublic class Employee {\n    private String name;\n    private Department department;  // One employee belongs to one department\n\n    public Employee(String name) {\n        this.name = name;\n    }\n\n    public void setDepartment(Department department) {\n        this.department = department;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#many-to-many-association","title":"Many-to-Many Association","text":"<pre><code>public class Student {\n    private String name;\n    private List&lt;Course&gt; courses;  // One student can enroll in many courses\n\n    public Student(String name) {\n        this.name = name;\n        this.courses = new ArrayList&lt;&gt;();\n    }\n\n    public void enrollInCourse(Course course) {\n        if (!courses.contains(course)) {\n            courses.add(course);\n            course.addStudent(this);\n        }\n    }\n\n    public List&lt;Course&gt; getCourses() {\n        return new ArrayList&lt;&gt;(courses);\n    }\n}\n\npublic class Course {\n    private String courseName;\n    private List&lt;Student&gt; students;  // One course can have many students\n\n    public Course(String courseName) {\n        this.courseName = courseName;\n        this.students = new ArrayList&lt;&gt;();\n    }\n\n    public void addStudent(Student student) {\n        if (!students.contains(student)) {\n            students.add(student);\n        }\n    }\n\n    public List&lt;Student&gt; getStudents() {\n        return new ArrayList&lt;&gt;(students);\n    }\n}\n\n// Usage Example\npublic class Main {\n    public static void main(String[] args) {\n        // Creating courses\n        Course java = new Course(\"Java Programming\");\n        Course python = new Course(\"Python Programming\");\n\n        // Creating students\n        Student alice = new Student(\"Alice\");\n        Student bob = new Student(\"Bob\");\n\n        // Enrolling students in multiple courses\n        alice.enrollInCourse(java);\n        alice.enrollInCourse(python);\n        bob.enrollInCourse(java);\n\n        // Now:\n        // - Alice is enrolled in both Java and Python courses\n        // - Bob is enrolled in Java course\n        // - Java course has two students (Alice and Bob)\n        // - Python course has one student (Alice)\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/a_object_oriented_programming/#key-points-about-associations","title":"Key Points About Associations","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#1-one-to-one","title":"1. One-to-One","text":"<ul> <li>Each object is related to exactly one instance of another object</li> <li>Example: Person-Passport relationship</li> <li>Use when: representing unique pairings</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#2-one-to-many","title":"2. One-to-Many","text":"<ul> <li>One object can be related to multiple instances of another object</li> <li>Example: Department-Employee relationship</li> <li>Use when: representing hierarchical relationships</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#3-many-to-many","title":"3. Many-to-Many","text":"<ul> <li>Multiple objects can be related to multiple instances of another object</li> <li>Example: Student-Course relationship</li> <li>Use when: representing complex relationships where both sides can have multiple connections</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#best-practices","title":"\ud83d\udca1 Best Practices","text":"<ul> <li>Always protect collections using defensive copying</li> <li>Consider using bi-directional relationships when necessary</li> <li>Implement proper encapsulation for associated objects</li> <li>Be careful with circular references in bi-directional relationships</li> <li>Use appropriate access modifiers</li> <li>Document the nature of the relationship</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use-each-type","title":"When to Use Each Type","text":"<p>Choose the appropriate association type based on your business requirements:</p> <ul> <li>One-to-One: for unique pairings (Person-Passport)</li> <li>One-to-Many: For hierarchical relationships (Department-Employees)</li> <li>Many-to-Many: For complex relationships requiring multiple connections (Students-Courses)</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#aggregation-has-a","title":"Aggregation (Has-A)","text":"<ul> <li>Special form of association</li> <li>Represents ownership</li> <li>Objects can exist independently</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use-aggregation","title":"When to Use Aggregation","text":"<ul> <li>When one class \"has\" another class</li> <li>When child objects can exist independently</li> <li>When sharing objects across owners <pre><code>public class Department {\n    private List&lt;Professor&gt; professors;  // Aggregation\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#composition-part-of","title":"Composition (Part-Of)","text":"<ul> <li>Stronger form of of aggregation</li> <li>Child objects cannot exist without parent</li> <li>Represents a \"part-of\" relationship</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#when-to-use-composition","title":"When to Use Composition","text":"<ul> <li>When child objects are essential parts of parent</li> <li>When child objects shouldn't exist independently</li> <li>When enforcing tight coupling is desired <pre><code>public class Car {\n    private final Engine engine;  // Composition\n\n    public Car() {\n        engine = new Engine();  // Engine cannot exist without Car\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#best-practices_1","title":"Best Practices","text":""},{"location":"1.Fundamentals/a_object_oriented_programming/#1-class-design","title":"1. Class Design","text":"<ul> <li>Keep classes focused (Single Responsibility Principle)</li> <li>Favor composition over inheritance</li> <li>Use meaningful names</li> <li>Keep inheritance hierarchies shallow</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#2-encapsulation","title":"2. Encapsulation","text":"<ul> <li>Make fields private unless there's a good reason not to</li> <li>Provide getters/setters only when necessary</li> <li>Validate data in setters</li> <li>Use immutable objects when possible</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#3-code-organization","title":"3. Code Organization","text":"<ul> <li>Group related classes in packages</li> <li>Maintain clear separation of concerns</li> <li>Document public APIs and complex logic</li> <li>Follow consistent naming conventions</li> </ul>"},{"location":"1.Fundamentals/a_object_oriented_programming/#references","title":"References","text":"<p>Object Oriented Programming Notes OOP Principles Playlist</p>"},{"location":"1.Fundamentals/b_data_structures/","title":"Data Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction","title":"\ud83d\udcd8 Introduction","text":"<p>Data structures are specialized formats for organizing, processing, retrieving, and storing data. Understanding data structures is fundamental to writing efficient and scalable code. This guide explores various data structures, their implementations, and practical applications in software development.</p>"},{"location":"1.Fundamentals/b_data_structures/#why-data-structures-matter","title":"Why Data Structures Matter","text":"<ul> <li>Efficient Problem-Solving: Choosing the right data structure can dramatically improve program performance</li> <li>Career Development: Essential for technical interviews at top tech companies</li> <li>Code Optimization: Enables writing more efficient and maintainable code</li> <li>Real-World Applications: Critical for building scalable software systems</li> <li>Competitive Edge: Fundamental for algorithmic problem-solving and competitions</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#guide-structure","title":"Guide Structure","text":"<p>Each data structure section will cover: - Core concepts and characteristics - Implementation details - Time and space complexities - Common operations - Best practices and use cases - Code examples and tips</p>"},{"location":"1.Fundamentals/b_data_structures/#categories-of-data-structures","title":"Categories of Data Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#linear-data-structures","title":"Linear Data Structures","text":"<p>Structures where elements are stored sequentially:</p> <ul> <li>Arrays &amp; ArrayLists:<ul> <li>Direct access by index</li> <li>Contiguous memory storage</li> <li>Best for: Fixed-size collections with frequent access</li> </ul> </li> <li>Linked Lists:<ul> <li>Dynamic size</li> <li>Non-contiguous storage</li> <li>Best for: Frequent insertions/deletions</li> </ul> </li> <li>Stacks:<ul> <li>LIFO (Last-In-First-Out)</li> <li>Best for: Function calls, undo operations</li> </ul> </li> <li>Queues:<ul> <li>FIFO (First-In-First-Out)</li> <li>Best for: Task scheduling, resource management</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#tree-based-structures","title":"Tree-Based Structures","text":"<p>Hierarchical structures with parent-child relationships:</p> <ul> <li>Priority Queues:<ul> <li>Efficient priority-based operations</li> <li>Best for: Scheduling, event handling</li> </ul> </li> <li>Binary Trees:<ul> <li>Two children per node maximum</li> <li>Best for: Hierarchical data</li> </ul> </li> <li>Binary Search Trees:<ul> <li>Ordered nodes</li> <li>Best for: Fast search, insert, delete</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#advanced-tree-based-structures","title":"Advanced Tree-Based Structures","text":"<p>Specialized tree structures for specific use cases:</p> <ul> <li>AVL Trees: Balanced binary search trees    </li> <li>Red-Black Trees: Balanced search with color properties</li> <li>2-3 Trees: Guaranteed balanced search trees</li> <li>B-Trees: Optimized for disk storage</li> <li>K-D Trees: Space partitioning structure</li> <li>M-Ary Trees: Nodes with multiple children</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#hash-based-structures","title":"Hash-Based Structures","text":"<p>Structures using hash functions:</p> <ul> <li>Hash Tables:<ul> <li>Key-value storage</li> <li>O(1) average access</li> <li>Best for: Caching, dictionaries</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#graph-based-structures","title":"Graph-Based Structures","text":"<p>Structures representing connections:</p> <ul> <li>Directed Graphs: One-way connections</li> <li>Undirected Graphs: Two-way connections</li> <li>inaphs Coctions with costs</li> <li>Disjoint-Sets: Non-Overlapping group connections</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#advanced-structures","title":"Advanced Structures","text":"<p>Specialized data structures:</p> <ul> <li>Tries:<ul> <li>Efficient string operations</li> <li>Best for: Autocomplete, spell checkers</li> </ul> </li> <li>Skip Lists:<ul> <li>Probabilistic alternative to balanced trees</li> <li>Best for: Fast search with simple implementation</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#time-complexity-overview","title":"Time Complexity Overview","text":""},{"location":"1.Fundamentals/b_data_structures/#performance-overview","title":"\ud83d\udcca Performance Overview","text":"Data Structure Access Search Insertion Deletion Space Array O(1) O(n) O(n) O(n) O(n) ArrayList O(1) O(n) O(n)* O(n) O(n) LinkedList O(n) O(n) O(1) O(1) O(n) Stack O(n) O(n) O(1) O(1) O(n) Queue O(n) O(n) O(1) O(1) O(n) Priority Queue O(1)*** O(n) O(log n) O(log n) O(n) Binary Tree O(n) O(n) O(n) O(n) O(n) Binary Search Tree O(log n)* O(log n)* O(log n)* O(log n)* O(n) AVL Tree O(log n) O(log n) O(log n) O(log n) O(n) Red-Black Tree O(log n) O(log n) O(log n) O(log n) O(n) 2-3 Tree O(log n) O(log n) O(log n) O(log n) O(n) B-Tree O(log n) O(log n) O(log n) O(log n) O(n) K-D Tree O(n) O(log n)** O(log n)** O(log n)** O(n) Trie O(m)**** O(m)**** O(m)**** O(m)**** O(n*m) Skip List O(log n)** O(log n)** O(log n)** O(log n)** O(n log n) Hash Table O(1)** O(1)** O(1)** O(1)* <p>* Average case for balanced trees * Average case, assumes good hash function or balanced structure * For peek operation only *** Where m is the length of the string/pattern \u2020 Amortized time complexity for dynamic resizing~~</p>"},{"location":"1.Fundamentals/b_data_structures/#references","title":"References","text":"<p>Data Structures and Algorithms Notes</p>"},{"location":"1.Fundamentals/b_data_structures/#linear-data-structures_1","title":"LINEAR DATA STRUCTURES","text":""},{"location":"1.Fundamentals/b_data_structures/#arraylist","title":"ArrayList","text":"<p>An ArrayList is a dynamic array implementation that automatically handles resizing as elements are added or removed. It provides fast random access and is one of the most used data structures in Java.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics","title":"Core Characteristics","text":"<ul> <li>Dynamic sizing</li> <li>Contiguous memory storage</li> <li>Fast random access</li> <li>Mutable length</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure","title":"Structure","text":"<pre><code>public class ArrayList&lt;T&gt; {\n    private T[] backingArray;    // Internal array to store elements\n    private int size;            // Number of elements in the ArrayList\n    public static final int INITIAL_CAPACITY = 9;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations-time-complexities","title":"Core Operations &amp; Time Complexities","text":""},{"location":"1.Fundamentals/b_data_structures/#adding-elements","title":"Adding Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#addtobackt-data","title":"addToBack(T data)","text":"<p><pre><code>public void addToBack(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    addHelper(size, data);\n}\n</code></pre> -   Time Complexity: Amortized O(1) -   Best for: Adding elements when order doesn't matter -   Note: May trigger resizing of backing array</p>"},{"location":"1.Fundamentals/b_data_structures/#addtofrontt-data","title":"addToFront(T data)","text":"<p><pre><code>public void addToFront(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    addHelper(0, data);\n}\n</code></pre> -   Time Complexity: O(n) -   Warning: Requires shifting all elements -   Use Case: When elements must be added at the beginning</p>"},{"location":"1.Fundamentals/b_data_structures/#internal-helper-method-adding","title":"Internal Helper Method (Adding)","text":""},{"location":"1.Fundamentals/b_data_structures/#addhelperint-index-t-data","title":"addHelper(int index, T data)","text":"<pre><code>@SuppressWarnings(\"unchecked\")\nprivate void addHelper(int index, T data) {\n    // If array is full, create new array with double capacity\n    if (size == backingArray.length) {\n        T[] newArray = (T[]) new Object[backingArray.length * 2];\n        int i;\n\n        // Copy elements before index\n        for (i = 0; i &lt; index; i++) {\n            newArray[i] = backingArray[i];\n        }\n        // Insert new element\n        newArray[i] = data;\n        // Copy remaining elements\n        for (; i &lt; size; i++) {\n            newArray[i + 1] = backingArray[i];\n        }\n\n        backingArray = newArray;\n    } else {\n        // Shift elements to make room for new element\n        for (int i = size; i &gt; index; --i) {\n            backingArray[i] = backingArray[i - 1];\n        }\n        backingArray[index] = data;\n    }\n    size++;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#removing-elements","title":"Removing Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#removefromback","title":"removeFromBack()","text":"<p><pre><code>public T removeFromBack() {\n    if (size == 0) {\n        throw new java.util.NoSuchElementException(\"Cannot remove from an empty list\");\n    }\n    return removeHelper(size - 1);\n}\n</code></pre> -   Time Complexity: O(1) -   Most efficient removal operation -   Checks for empty list</p>"},{"location":"1.Fundamentals/b_data_structures/#removefromfront","title":"removeFromFront()","text":"<p><pre><code>public T removeFromFront() {\n    if (size == 0) {\n        throw new java.util.NoSuchElementException(\"Cannot remove from an empty list\");\n    }\n    return removeHelper(0);\n}\n</code></pre> -   Time Complexity: O(n) -   Requires shifting all elements -   Use sparingly due to performance cost</p>"},{"location":"1.Fundamentals/b_data_structures/#removeatindexint-index","title":"removeAtIndex(int index)","text":"<p><pre><code>public T removeAtIndex(int index) {\n    if (index &lt; 0 || index &gt;= size) {\n        throw new IndexOutOfBoundsException(\"Index cannot be outside the \"\n            + \"range [0, \" + size + \")\");\n    }\n    return removeHelper(index);\n}\n</code></pre> -   Time Complexity:     -   Best Case (last element): O(1)     -   Average/Worst Case: O(n) -   Purpose: Removes and returns element at specified index -   Validation: Checks for valid index range -   Process:     1.  Validates index bounds     2.  Calls removeHelper for actual removal     3.  Returns removed element</p>"},{"location":"1.Fundamentals/b_data_structures/#internal-helper-method-removing","title":"\ud83d\udee0\ufe0f Internal Helper Method (Removing)","text":""},{"location":"1.Fundamentals/b_data_structures/#removehelperint-index","title":"removeHelper(int index)","text":"<p><pre><code>private T removeHelper(int index) {\n    T removed = backingArray[index];\n    // Shift elements to fill the gap\n    for (int i = index; i &lt; size - 1; i++) {\n        backingArray[i] = backingArray[i + 1];\n    }\n    backingArray[--size] = null;  // Clear last element and decrease size\n    return removed;\n}\n</code></pre> -   Time Complexity: O(n) -   Purpose: Internal method for handling element removal and shifting -   Key Operations:     1.  Element removal at specified index     2.  Left-shifting remaining elements     3.  Cleanup and size management</p>"},{"location":"1.Fundamentals/b_data_structures/#access-operations","title":"Access Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#getint-index","title":"get(int index)","text":"<p><pre><code>public T get(int index) {\n    if (index &lt; 0 || index &gt;= size) {\n        throw new IndexOutOfBoundsException(\"Index cannot be outside the \"\n            + \"range [0, \" + size + \")\");\n    }\n    return backingArray[index];\n}\n</code></pre> -   Time Complexity: O(1) -   Direct index access -   Bounds checking included</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary","title":"Performance Summary","text":"Operation Time Complexity Notes Add to Back O(1)* *Amortized Add to Front O(n) Requires shifting Add at Index O(n) Requires shifting Remove from Back O(1) Most efficient removal Remove from Front O(n) Requires shifting Get/Set O(1) Direct access Clear O(1) Memory reset Size O(1) Constant tracking <p>* Amortized time complexity - occasional resizing operations are averaged over many operations</p>"},{"location":"1.Fundamentals/b_data_structures/#best-practices","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-initialization","title":"1. Initialization","text":"<ul> <li>State with reasonable initial capacity</li> <li>Consider expected size for optimal performance</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#2-usage-tips","title":"2. Usage Tips","text":"<pre><code>// Prefer adding to back when possible\nlist.addToBack(element);  // O(1)\n\n// Avoid frequent front operations\nlist.addToFront(element); // O(n) - expensive!\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-memory-management","title":"3. Memory Management","text":"<ul> <li>Clear references when removing elements</li> <li>Reset to initial capacity when clearing</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Dynamic lists of elements</li> <li>Buffer implementation</li> <li>Stack implementation</li> <li>Collection management</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Frequent front operations</li> <li>Not considering capacity growth</li> <li>Not handling null elements</li> <li>Ignoring bounds checking</li> </ol>"},{"location":"1.Fundamentals/b_data_structures/#when-to-use-arraylist","title":"When to Use ArrayList","text":"<ul> <li>Need dynamic sizing</li> <li>Frequent random access</li> <li>Mostly back-end operations</li> <li>Memory locality is important</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#when-not-to-use-arraylist","title":"When Not to Use ArrayList","text":"<ul> <li>Frequent insertions/deletions at front/middle</li> <li>Fixed size is sufficient</li> <li>Memory is extremely constrained</li> <li>Need concurrent access</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#references_1","title":"References","text":"<p>https://youtu.be/PEnFFiQe1pM?si=KfpsngEBI0gesUbC</p>"},{"location":"1.Fundamentals/b_data_structures/#linked-lists","title":"Linked Lists","text":""},{"location":"1.Fundamentals/b_data_structures/#singly-linked-list","title":"Singly Linked List","text":"<p>A Singly Linked List is a fundamental data structure where elements are stored in nodes, each containing data and a reference to the next node in the sequence. Unlike arrays, linked lists don't require contiguous memory allocation, making them ideal for dynamic data management.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_1","title":"Core Characteristics","text":"<ul> <li>Dynamic sizing (no fixed capacity)</li> <li>Sequential access pattern</li> <li>Node-based structure</li> <li>Efficient insertions and deletions at known positions</li> <li>Linear time search operations</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_1","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_1","title":"Structure","text":"<pre><code>public class LinkedList&lt;T&gt; {\n    private Node&lt;T&gt; head;\n    private int size;\n\n    private static class Node&lt;T&gt; {\n        private T data;\n        private Node&lt;T&gt; next;\n\n        public Node(T data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations-time-complexities_1","title":"Core Operations &amp; Time Complexities","text":""},{"location":"1.Fundamentals/b_data_structures/#adding-elements_1","title":"Adding Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#addtofrontt-data_1","title":"addToFront(T data)","text":"<p><pre><code>public void addToFront(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);\n    newNode.next = head;\n    head = newNode;\n    size++;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Stack-like operations -   Edge Cases:     -   Null data     -   First element (empty list)</p>"},{"location":"1.Fundamentals/b_data_structures/#addtobackt-data_1","title":"addToBack(T data)","text":"<p><pre><code>public void addToBack(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);\n\n    if (head == null) {\n        head = newNode;\n    } else {\n        Node&lt;T&gt; current = head;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = newNode;\n    }\n    size++;\n}\n</code></pre> -   Time Complexity: O(n) -   Best for: Queue-like operations -   Edge Cases:     -   Null data     -   Empty list     -   Consider tracking tail pointer for O(1) operation</p>"},{"location":"1.Fundamentals/b_data_structures/#addatindexint-index-t-data","title":"addAtIndex(int index, T data)","text":"<p><pre><code>public void addAtIndex(int index, T data) {\n    if (index &lt; 0 || index &gt; size) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    }\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    if (index == 0) {\n        addToFront(data);\n        return;\n    }\n\n    Node&lt;T&gt; current = head;\n    for (int i = 0; i &lt; index - 1; i++) {\n        current = current.next;\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);\n    newNode.next = current.next;\n    current.next = newNode;\n    size++;\n}\n</code></pre> -   Time Complexity: O(n) -   Best for: Ordered insertions -   Edge Cases:     -   Invalid index     -   Null data     -   Front insertion</p>"},{"location":"1.Fundamentals/b_data_structures/#removing-elements_1","title":"Removing Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#removefromfront_1","title":"removeFromFront()","text":"<p><pre><code>public T removeFromFront() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    T data = head.data;\n    head = head.next;\n    size--;\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Stack operations -   Edge Cases:     -   Empty list     -   Single element</p>"},{"location":"1.Fundamentals/b_data_structures/#removefromback_1","title":"removeFromBack()","text":"<p><pre><code>public T removeFromBack() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    if (size == 1) {\n        T data = head.data;\n        head = null;\n        size--;\n        return data;\n    }\n\n    Node&lt;T&gt; current = head;\n    while (current.next.next != null) {\n        current = current.next;\n    }\n\n    T data = current.next.data;\n    current.next = null;\n    size--;\n    return data;\n}\n</code></pre> -   Time Complexity: O(n) -   Best for: Queue operations -   Edge Cases:     -   Empty list     -   Single element     -   Consider tail pointer optimization</p>"},{"location":"1.Fundamentals/b_data_structures/#access-operations_1","title":"Access Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#getint-index_1","title":"get(int index)","text":"<p><pre><code>public T get(int index) {\n    if (index &lt; 0 || index &gt;= size) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    }\n\n    Node&lt;T&gt; current = head;\n    for (int i = 0; i &lt; index; i++) {\n        current = current.next;\n    }\n    return current.data;\n}\n</code></pre> -   Time Complexity: O(n) -   Best for: Sequential access -   Edge Cases:     -   Invalid index     -   Empty list</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_1","title":"Performance Summary","text":"Operation Time Complexity Notes Add to Front O(1) Constant time Add to Back O(n) Linear traversal Add at Index O(n) Traversal to index Remove from Front O(1) Constant time Remove from Back O(n) Linear traversal Get O(n) Linear traversal Size O(1) Tracked variable"},{"location":"1.Fundamentals/b_data_structures/#best-practices_1","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-null-handling","title":"1. Null Handling","text":"<pre><code>private void validateNotNull(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-index-validation","title":"2. Index Validation","text":"<pre><code>private void validateIndex(int index, boolean isAdd) {\n    int maxIndex = isAdd ? size : size - 1;\n    if (index &lt; 0 || index &gt; maxIndex) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-memory-management_1","title":"3. Memory Management","text":"<ul> <li>Clear references when removing nodes</li> <li>Consider garbage collection implications</li> <li>Track size for O(1) length checks</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_1","title":"Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-losing-references","title":"1. Losing References","text":"<pre><code>// WRONG - Lost reference to rest of list\nhead = new Node&lt;&gt;(data);  // Overwrites head reference\n\n// CORRECT - Maintain list structure\nNode&lt;T&gt; newNode = new Node&lt;&gt;(data);\nnewNode.next = head;\nhead = newNode;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-not-handling-edge-cases","title":"2. Not Handling Edge Cases","text":"<pre><code>// WRONG - Assumes non-empty list\nhead.next = newNode;\n\n// CORRECT - Handle empty list\nif (head == null) {\n    head = newNode;\n} else {\n    head.next = newNode;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#reference","title":"Reference","text":"<p>Singly Linked List Video</p>"},{"location":"1.Fundamentals/b_data_structures/#doubly-linked-list","title":"Doubly Linked List","text":"<p>A Doubly Linked List is a bidirectional linked data structure where each node contains data and references to both the next and previous nodes. This bidirectional linking enables efficient traversal in both directions and simplifies certain operations compared to singly linked lists.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_2","title":"Core Characteristics","text":"<ul> <li>Bi-directional traversal</li> <li>Dynamic sizing</li> <li>O(1) operations at both ends</li> <li>Efficient insertions and deletions</li> <li>Higher memory usage per node</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_2","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_2","title":"Structure","text":"<pre><code>public class DoublyLinkedList&lt;T&gt; {\n    private Node&lt;T&gt; head;\n    private Node&lt;T&gt; tail;\n    private int size;\n\n    private static class Node&lt;T&gt; {\n        private T data;\n        private Node&lt;T&gt; next;\n        private Node&lt;T&gt; previous;\n\n        Node(T data) {\n            this.data = data;\n            this.next = null;\n            this.previous = null;\n        }\n\n        Node(T data, Node&lt;T&gt; previous, Node&lt;T&gt; next) {\n            this.data = data;\n            this.previous = previous;\n            this.next = next;\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations-time-complexities_2","title":"Core Operations &amp; Time Complexities","text":""},{"location":"1.Fundamentals/b_data_structures/#adding-elements_2","title":"Adding Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#addtofrontt-data_2","title":"addToFront(T data)","text":"<p><pre><code>public void addToFront(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    head = new Node&lt;&gt;(data, null, head);\n    if (size == 0) {\n        tail = head;  // First node is both head and tail\n    } else {\n        head.next.previous = head;  // Link old head back to new head\n    }\n    size++;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Stack-like operations, maintaining recent items -   Edge Cases:     -   Empty list     -   Null data     -   Maintaining tail reference</p>"},{"location":"1.Fundamentals/b_data_structures/#addtobackt-data_2","title":"addToBack(T data)","text":"<p><pre><code>public void addToBack(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, tail, null);\n    if (size == 0) {\n        head = newNode;\n    } else {\n        tail.next = newNode;\n    }\n    tail = newNode;\n    size++;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Queue-like operations -   Edge Cases:     -   Empty list     -   Null data     -   Maintaining head reference</p>"},{"location":"1.Fundamentals/b_data_structures/#addatindexint-index-t-data_1","title":"addAtIndex(int index, T data)","text":"<p><pre><code>public void addAtIndex(int index, T data) {\n    if (index &lt; 0 || index &gt; size) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    }\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    if (index == 0) {\n        addToFront(data);\n        return;\n    }\n    if (index == size) {\n        addToBack(data);\n        return;\n    }\n\n    // Choose optimal traversal direction\n    Node&lt;T&gt; current;\n    if (index &lt; size / 2) {\n        // Start from head\n        current = head;\n        for (int i = 0; i &lt; index - 1; i++) {\n            current = current.next;\n        }\n    } else {\n        // Start from tail\n        current = tail;\n        for (int i = size - 1; i &gt; index; i--) {\n            current = current.previous;\n        }\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, current, current.next);\n    current.next.previous = newNode;\n    current.next = newNode;\n    size++;\n}\n</code></pre> -   Time Complexity: O(n) -   Optimization: Chooses optimal traversal direction -   Edge Cases:     -   Index bounds     -   Null data     -   Front/back insertions</p>"},{"location":"1.Fundamentals/b_data_structures/#remove-elements","title":"Remove Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#removefromfront_2","title":"removeFromFront()","text":"<p><pre><code>public T removeFromFront() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    T data = head.data;\n    head = head.next;\n    size--;\n\n    if (size == 0) {\n        tail = null;\n    } else {\n        head.previous = null;\n    }\n\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Stack operations -  Edge Cases:     -   Empty list     -   Single element     -   Maintaining tail reference</p>"},{"location":"1.Fundamentals/b_data_structures/#removefromback_2","title":"removeFromBack()","text":"<p><pre><code>public T removeFromBack() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    T data = tail.data;\n    tail = tail.previous;\n    size--;\n\n    if (size == 0) {\n        head = null;\n    } else {\n        tail.next = null;\n    }\n\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   Best for: Queue operations -   Edge Cases:     -   Empty list     -   Single element     -   Maintaining head reference</p>"},{"location":"1.Fundamentals/b_data_structures/#access-operations_2","title":"Access Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#getint-index_2","title":"get(int index)","text":"<p><pre><code>public T get(int index) {\n    if (index &lt; 0 || index &gt;= size) {\n        throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    }\n\n    Node&lt;T&gt; current;\n    if (index &lt; size / 2) {\n        current = head;\n        for (int i = 0; i &lt; index; i++) {\n            current = current.next;\n        }\n    } else {\n        current = tail;\n        for (int i = size - 1; i &gt; index; i--) {\n            current = current.previous;\n        }\n    }\n    return current.data;\n}\n</code></pre> -   Time Complexity: O(n) -   Optimization: Bi-directional traversal -   Edge Cases:     -   Invalid index     -   Empty list</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_2","title":"Performance Summary","text":"Operation Time Complexity Notes Add to Front O(1) Constant time Add to Back O(1) Constant time with tail Add at Index O(n) Optimal traversal direction Remove from Front O(1) Constant time Remove from Back O(1) Constant time with tail Get O(n) Optimal traversal direction Size O(1) Tracked variable"},{"location":"1.Fundamentals/b_data_structures/#best-practices_2","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-bi-directional-link-maintenance","title":"1. Bi-directional Link Maintenance","text":"<pre><code>// Always update both next and previous references\nnewNode.next = current.next;\nnewNode.previous = current;\ncurrent.next.previous = newNode;\ncurrent.next = newNode;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-headtail-management","title":"2. Head/Tail Management","text":"<pre><code>// For single element\nif (size == 1) {\n    head = tail = null;\n} else {\n    // Update references appropriately\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-traversal-optimization","title":"3. Traversal Optimization","text":"<pre><code>// Choose optimal direction based on index\nif (index &lt; size / 2) {\n    traverseFromHead();\n} else {\n    traverseFromTail();\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_2","title":"Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-incomplete-link-updates","title":"1. Incomplete Link Updates","text":"<pre><code>// WRONG - Only updating one direction\ncurrent.next = newNode;\n\n// CORRECT - Update both directions\ncurrent.next = newNode;\nnewNode.previous = current;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-memory-leaks","title":"2. Memory Leaks","text":"<pre><code>// WRONG - Leaving dangling references\nhead = head.next;\n\n// CORRECT - Clear all references\nT data = head.data;\nNode&lt;T&gt; newHead = head.next;\nhead.next = null;  // Clear reference\nif (newHead != null) {\n    newHead.previous = null;\n}\nhead = newHead;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_2","title":"References","text":"<p>Doubly Linked List Video</p>"},{"location":"1.Fundamentals/b_data_structures/#circular-singly-linked-list","title":"Circular Singly Linked List","text":"<p>A Circular Singly Linked List is a variant of linked lists where the last node points back to the first node, creating a circle. This structure is particularly useful when I need continuous traversal or cyclic operations, like round-robin scheduling.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_3","title":"Core Characteristics","text":"<ul> <li>Last node connects to first node</li> <li>Sequential access pattern</li> <li>No null references</li> <li>Continuous traversal capability</li> <li>Efficient for cyclic operations</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_3","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_3","title":"Structure","text":"<p><pre><code>public class CircularLinkedList&lt;T&gt; {\n    private Node&lt;T&gt; tail;  // Points to last node\n    private int size;\n\n    private static class Node&lt;T&gt; {\n        T data;\n        Node&lt;T&gt; next;\n\n        Node(T data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n}\n</code></pre> \ud83d\udcad Why track tail instead of head?</p> <ul> <li>O(1) insertions at both ends</li> <li>Easy access to both first and last nodes</li> <li>More efficient for common operations</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#core-operations","title":"Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#adding-elements_3","title":"Adding Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#addingtofrontt-data","title":"addingToFront(T data)","text":"<p><pre><code>public void addToFront(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);\n    if (isEmpty()) {\n        newNode.next = newNode;  // Points to itself\n        tail = newNode;\n    } else {\n        newNode.next = tail.next;  // Point to old first node\n        tail.next = newNode;       // Update tail's next to new node\n    }\n    size++;\n}\n</code></pre> -   Time Complexity: O(1) -   Important: Maintain circular nature -   Edge Cases: Empty list handling</p>"},{"location":"1.Fundamentals/b_data_structures/#addtobackt-data_3","title":"addToBack(T data)","text":"<p><pre><code>public void addToBack(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);\n    if (isEmpty()) {\n        newNode.next = newNode;\n    } else {\n        newNode.next = tail.next;  // Point to first node\n        tail.next = newNode;       // Update tail's next\n    }\n    tail = newNode;  // Update tail to new node\n    size++;\n}\n</code></pre> -   Time Complexity: O(1) -   Key Point: Tail reference makes this efficient -   Edge Cases: Empty list, single element</p>"},{"location":"1.Fundamentals/b_data_structures/#removing-elements_2","title":"Removing Elements","text":""},{"location":"1.Fundamentals/b_data_structures/#removefromfront_3","title":"removeFromFront()","text":"<p><pre><code>public T removeFromFront() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    T data = tail.next.data;  // Get first node's data\n    if (size == 1) {\n        tail = null;\n    } else {\n        tail.next = tail.next.next;  // Skip first node\n    }\n    size--;\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   Key Point: Maintain circular structure -   Edge Cases: Empty list, single element</p>"},{"location":"1.Fundamentals/b_data_structures/#removefromback_3","title":"removeFromBack()","text":"<p><pre><code>public T removeFromBack() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"List is empty\");\n    }\n\n    T data = tail.data;\n    if (size == 1) {\n        tail = null;\n    } else {\n        Node&lt;T&gt; current = tail.next;\n        while (current.next != tail) {\n            current = current.next;\n        }\n        current.next = tail.next;\n        tail = current;\n    }\n    size--;\n    return data;\n}\n</code></pre> -   Time Complexity: O(n) -   Note: Requires traversal to find second-to-last node -   Edge Cases: Empty list, single element</p>"},{"location":"1.Fundamentals/b_data_structures/#search-operation","title":"Search Operation","text":"<p><pre><code>public boolean contains(T data) {\n    if (isEmpty() || data == null) {\n        return false;\n    }\n\n    Node&lt;T&gt; current = tail.next;  // Start at first node\n    do {\n        if (data.equals(current.data)) {\n            return true;\n        }\n        current = current.next;\n    } while (current != tail.next);\n\n    return false;\n}\n</code></pre> -   Time Complexity: O(n) -   Important: Use do-while for circular traversal -   Handle: Null data, empty list</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_3","title":"\ud83d\udcca Performance Summary","text":"Operation Time Complexity Notes Add to Front O(1) Constant time with tail reference Add to Back O(1) Constant time with tail reference Remove from Front O(1) Constant time operation Remove from Back O(n) Requires traversal Search O(n) Linear traversal Size O(1) Tracked variable"},{"location":"1.Fundamentals/b_data_structures/#best-practices_3","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-circular-reference-maintenance","title":"1. Circular Reference Maintenance","text":"<pre><code>// Always ensure last node points to first\ntail.next = tail.next.next;  // When removing\nnewNode.next = tail.next;    // When adding\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-empty-list-handling","title":"2. Empty List Handling","text":"<pre><code>if (isEmpty()) {\n    // New node points to itself\n    newNode.next = newNode;\n    tail = newNode;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-single-element-handling","title":"3. Single Element Handling","text":"<pre><code>if (size == 1) {\n    tail = null;  // For removal\n    // OR\n    tail = newNode;  // For insertion\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_3","title":"Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-infinite-loops","title":"1. Infinite Loops","text":"<pre><code>// WRONG - May loop forever\nwhile (current.next != null) {  // Never true in circular list\n    current = current.next;\n}\n\n// CORRECT\ndo {\n    current = current.next;\n} while (current != tail.next);\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-lost-circular-reference","title":"2. Lost Circular Reference","text":"<pre><code>// WRONG - Loses circular structure\ntail.next = newNode;\n\n// CORRECT - Maintains circular structure\nnewNode.next = tail.next;\ntail.next = newNode;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#reference_1","title":"Reference","text":"<p>Circular Linked List Playlist</p>"},{"location":"1.Fundamentals/b_data_structures/#stack","title":"Stack","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction_1","title":"Introduction","text":"<p>A Stack is a linear data structure that follows the LIFO (Last In First Out) principle. Like a stack of plates, elements are added and removed from the same end, called the top of the stack. This fundamental data structure is ideal for scenarios where we need strict order control over our operations.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_4","title":"Core Characteristics","text":"<ul> <li>LIFO (Last In, First Out) principle</li> <li>Single point of access (top)</li> <li>Dynamic sizing through array resizing</li> <li>Ordered operations</li> <li>Constant time operations (amortized)</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_4","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_4","title":"Structure","text":"<pre><code>public class Stack&lt;T&gt; {\n    // Default capacity when no size is specified\n    private static final int DEFAULT_CAPACITY = 10;\n\n    // Internal array to store elements\n    private T[] backingArray;\n\n    // Keep track of the next available position\n    private int size;\n\n    // Constructor with default capacity\n    @SuppressWarnings(\"unchecked\")\n    public Stack() {\n        backingArray = (T[]) new Object[DEFAULT_CAPACITY];\n        size = 0;\n    }\n\n    // Constructor with specified initial capacity\n    @SuppressWarnings(\"unchecked\")\n    public Stack(int initialCapacity) {\n        if (initialCapacity &lt; 0) {\n            throw new IllegalArgumentException(\"Initial capacity cannot be negative\");\n        }\n        backingArray = (T[]) new Object[initialCapacity];\n        size = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_1","title":"Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#push-operation","title":"Push Operation","text":"<p><pre><code>public void push(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Cannot push null data\");\n    }\n\n    // Check if we need to resize\n    if (size == backingArray.length) {\n        resize();\n    }\n\n    // Add element and increment size\n    backingArray[size++] = data;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void resize() {\n    T[] newArray = (T[]) new Object[backingArray.length * 2];\n    for (int i = 0; i &lt; size; i++) {\n        newArray[i] = backingArray[i];\n    }\n    backingArray = newArray;\n}  \n</code></pre>    Time Complexity: O(1) amortized -   When to Use: Adding new elements to the stack -   Key Points:     -   Handles null check     -   Automatic resizing     -   Maintains LIFO order</p>"},{"location":"1.Fundamentals/b_data_structures/#pop-operation","title":"Pop Operation","text":"<p><pre><code>public T pop() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Cannot pop from empty stack\");\n    }\n\n    // Retrieve element and decrement size\n    T data = backingArray[--size];\n    backingArray[size] = null;  // Clear reference for garbage collection\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   When to Use: Removing and retrieving the most recently added element -   Key Points:     -   Checks for empty stack     -   Cleans up references     -   Maintains LIFO order</p>"},{"location":"1.Fundamentals/b_data_structures/#peek-operation","title":"Peek Operation","text":"<p><pre><code>public T peek() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Cannot peek empty stack\");\n    }\n    return backingArray[size - 1];\n}\n</code></pre> -   Time Complexity: O(1) -   When to Use: Viewing top element without removal -   Key Points:     -   No modification to stack     -   Preserves state     -   Checks for empty stack</p>"},{"location":"1.Fundamentals/b_data_structures/#utility-operations","title":"Utility Operations","text":"<pre><code>// Check if stack is empty\npublic boolean isEmpty() {\n    return size == 0;\n}\n\n// Get current number of elements\npublic int size() {\n    return size;\n}\n\n// Clear all elements\n@SuppressWarnings(\"unchecked\")\npublic void clear() {\n    backingArray = (T[]) new Object[DEFAULT_CAPACITY];\n    size = 0;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_4","title":"\ud83d\udcca Performance Summary","text":"Operation Time Complexity Notes Push O(1)* Amortized for resizing Pop O(1) Constant time Peek O(1) Constant time isEmpty O(1) Constant time Size O(1) Constant time Clear O(1) New array allocation <p>* Amortized time complexity accounts for occasional resizing operations</p>"},{"location":"1.Fundamentals/b_data_structures/#best-practices_4","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-memory-management","title":"1. Memory Management","text":"<pre><code>// Always clear references when removing elements\npublic T pop() {\n    T data = backingArray[--size];\n    backingArray[size] = null;  // Clear reference\n    return data;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-capacity-handling","title":"2. Capacity Handling","text":"<pre><code>// Consider shrinking array when usage is low\nprivate void shrinkIfNeeded() {\n    if (size &gt; 0 &amp;&amp; size &lt; backingArray.length / 4) {\n        resize(backingArray.length / 2);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-null-checking","title":"3. Null Checking","text":"<pre><code>// Always validate input\npublic void push(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    // push implementation\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_4","title":"Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-memory-leaks","title":"1. Memory Leaks","text":"<pre><code>// WRONG - Memory leak\npublic T pop() {\n    return backingArray[--size];  // Reference still held\n}\n\n// CORRECT - Clear reference\npublic T pop() {\n    T data = backingArray[--size];\n    backingArray[size] = null;  // Clear reference\n    return data;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-bound-checking","title":"2. Bound Checking","text":"<pre><code>// WRONG - No empty check\npublic T peek() {\n    return backingArray[size - 1];  // Possible IndexOutOfBoundsException\n}\n\n// CORRECT - With empty check\npublic T peek() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Stack is empty\");\n    }\n    return backingArray[size - 1];\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-use-cases_1","title":"Common Use Cases","text":""},{"location":"1.Fundamentals/b_data_structures/#1-function-call-stack","title":"1. Function Call Stack","text":"<pre><code>Stack&lt;FunctionCall&gt; callStack = new Stack&lt;&gt;();\ncallStack.push(new FunctionCall(\"main\"));\ncallStack.push(new FunctionCall(\"helper\"));\n// Current function is helper\ncallStack.pop();  // Return to main\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-expression-evaluation","title":"2. Expression Evaluation","text":"<pre><code>Stack&lt;Character&gt; parentheses = new Stack&lt;&gt;();\nfor (char c : expression.toCharArray()) {\n    if (c == '(') {\n        parentheses.push(c);\n    } else if (c == ')') {\n        if (!parentheses.isEmpty()) {\n            parentheses.pop();\n        } else {\n            // Unmatched closing parenthesis\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-undoredo-operations","title":"3. Undo/Redo Operations","text":"<pre><code>Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();\nStack&lt;Command&gt; redoStack = new Stack&lt;&gt;();\n\nvoid executeCommand(Command cmd) {\n    cmd.execute();\n    undoStack.push(cmd);\n    redoStack.clear();  // Clear redo history\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_3","title":"References","text":"<p>Stack Introduction Stack Implementation</p> <p>TODO: Add LinkedStack implementation</p>"},{"location":"1.Fundamentals/b_data_structures/#queue","title":"Queue","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction_2","title":"Introduction","text":"<p>A Queue is a linear data structure following the FIFO (First In, First Out) principle. Using a circular array implementation allows for efficient space usage and constant time operations by reusing array spaces that have been dequeued.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_5","title":"Core Characteristics","text":"<ul> <li>FIFO (First In, First Out) ordering</li> <li>Circular array implementation</li> <li>Dynamic sizing</li> <li>Constant time operations (amortized)</li> <li>Space efficient</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_5","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_5","title":"Structure","text":"<pre><code>public class Queue&lt;T&gt; {\n    private T[] backingArray;\n    private int front;      // Index of the front element\n    private int size;       // Number of elements in queue\n    private static final int INITIAL_CAPACITY = 10;\n\n    @SuppressWarnings(\"unchecked\")\n    public Queue() {\n        backingArray = (T[]) new Object[INITIAL_CAPACITY];\n        front = 0;\n        size = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_2","title":"Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#enqueue-operation","title":"Enqueue Operation","text":"<p><pre><code>public void enqueue(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Cannot enqueue null data\");\n    }\n\n    // Check if we need to resize\n    if (size == backingArray.length) {\n        resize();\n    }\n\n    // Calculate rear index using modulo for circular behavior\n    int rear = (front + size) % backingArray.length;\n    backingArray[rear] = data;\n    size++;\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate void resize() {\n    T[] newArray = (T[]) new Object[backingArray.length * 2];\n    // Copy elements in order, starting from front\n    for (int i = 0; i &lt; size; i++) {\n        newArray[i] = backingArray[(front + i) % backingArray.length];\n    }\n    backingArray = newArray;\n    front = 0;  // Reset front to beginning of new array\n}\n</code></pre> -   Time Complexity: O(1) amortized -   When to Use: Adding elements to queue -   Key Points:     -   Handles null check     -   Circular indexing with modulo     -   Resizes when full</p>"},{"location":"1.Fundamentals/b_data_structures/#dequeue-operation","title":"Dequeue Operation","text":"<p><pre><code>public T dequeue() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Queue is empty\");\n    }\n\n    T data = backingArray[front];\n    backingArray[front] = null;  // Help GC\n    front = (front + 1) % backingArray.length;\n    size--;\n    return data;\n}\n</code></pre> -   Time Complexity: O(1) -   When to Use: Removing elements from front -   Key Points:     -   Handles empty queue     -   Maintains circular structure     -   Cleans up references</p>"},{"location":"1.Fundamentals/b_data_structures/#peek-operation_1","title":"Peek Operation","text":"<p><pre><code>public T peek() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Queue is empty\");\n    }\n    return backingArray[front];\n}\n</code></pre> -   Time Complexity: O(1) -   When to Use: Examining front element -   Key Points:     -   No modification to queue     -   Front element access</p>"},{"location":"1.Fundamentals/b_data_structures/#utility-operations_1","title":"Utility Operations","text":"<pre><code>public boolean isEmpty() {\n    return size == 0;\n}\n\npublic int size() {\n    return size;\n}\n\n@SuppressWarnings(\"unchecked\")\npublic void clear() {\n    backingArray = (T[]) new Object[INITIAL_CAPACITY];\n    front = 0;\n    size = 0;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_5","title":"Performance Summary","text":"Operation Time Complexity Notes Enqueue O(1)* Amortized for resizing Dequeue O(1) Constant time Peek O(1) Constant time isEmpty O(1) Constant time Size O(1) Constant time Clear O(1) New array allocation <p>* Amortized time complexity accounts for occasional resizing operations</p>"},{"location":"1.Fundamentals/b_data_structures/#best-practices_5","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-circular-index-calculation","title":"1. Circular Index Calculation","text":"<pre><code>// Calculate next index with modulo\nprivate int getNextIndex(int currentIndex) {\n    return (currentIndex + 1) % backingArray.length;\n}\n\n// Calculate rear index\nprivate int getRearIndex() {\n    return (front + size) % backingArray.length;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-resizing-strategy","title":"2. Resizing Strategy","text":"<pre><code>private void resize() {\n    // Double size for amortized O(1)\n    T[] newArray = (T[]) new Object[backingArray.length * 2];\n\n    // Copy in order from front to rear\n    for (int i = 0; i &lt; size; i++) {\n        newArray[i] = backingArray[(front + i) % backingArray.length];\n    }\n    front = 0;  // Reset front after resize\n    backingArray = newArray;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-memory-management_2","title":"3. Memory Management","text":"<pre><code>public T dequeue() {\n    T data = backingArray[front];\n    backingArray[front] = null;  // Clear reference\n    front = (front + 1) % backingArray.length;\n    size--;\n    return data;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_5","title":"Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-incorrect-circular-indexing","title":"1. Incorrect Circular Indexing","text":"<pre><code>// WRONG - May cause overflow\nrear = rear + 1;\nif (rear == backingArray.length) rear = 0;\n\n// CORRECT - Use modulo\nrear = (rear + 1) % backingArray.length;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-resizing-issues","title":"2. Resizing Issues","text":"<pre><code>// WRONG - Doesn't maintain order\nSystem.arraycopy(backingArray, 0, newArray, 0, backingArray.length);\n\n// CORRECT - Maintains order from front\nfor (int i = 0; i &lt; size; i++) {\n    newArray[i] = backingArray[(front + i) % backingArray.length];\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-use-cases_2","title":"Common Use Cases","text":""},{"location":"1.Fundamentals/b_data_structures/#1-task-scheduling","title":"1. Task Scheduling","text":"<pre><code>Queue&lt;Task&gt; taskQueue = new Queue&lt;&gt;();\ntaskQueue.enqueue(new Task(\"Process payment\"));\ntaskQueue.enqueue(new Task(\"Send email\"));\n\nwhile (!taskQueue.isEmpty()) {\n    Task nextTask = taskQueue.dequeue();\n    processTask(nextTask);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-bfs-implementation","title":"2. BFS Implementation","text":"<pre><code>public void bfs(Node root) {\n    Queue&lt;Node&gt; queue = new Queue&lt;&gt;();\n    queue.enqueue(root);\n\n    while (!queue.isEmpty()) {\n        Node current = queue.dequeue();\n        for (Node child : current.getChildren()) {\n            queue.enqueue(child);\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-buffer-implementation","title":"3. Buffer Implementation","text":"<pre><code>public class Buffer&lt;T&gt; {\n    private Queue&lt;T&gt; queue = new Queue&lt;&gt;();\n    private final int capacity;\n\n    public void write(T data) {\n        if (queue.size() &lt; capacity) {\n            queue.enqueue(data);\n        }\n    }\n\n    public T read() {\n        return queue.isEmpty() ? null : queue.dequeue();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_4","title":"References","text":"<p>Queue Introduction Queue Implementation</p> <p>TODO: Add LinkedQueue Implementation</p>"},{"location":"1.Fundamentals/b_data_structures/#tree-based-structures_1","title":"\ud83c\udf33 Tree-Based Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#priority-queue","title":"\ud83d\udcca Priority Queue","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction_3","title":"Introduction","text":"<p>A Priority Queue is an advanced queue that orders elements by their priority rather than insertion order. It's commonly implemented using a heap data structure, typically a min-heap or max-heap. In this implementation, we'll focus on a min-heap based priority queue where lower values have higher priority.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_6","title":"Core Characteristics","text":"<ul> <li>\ud83d\udcc8 Priority-based ordering</li> <li>\ud83c\udf33 Heap-based implementation</li> <li>\ud83d\udccf Dynamic sizing</li> <li>\ud83d\udd04 Self-balancing structure</li> <li>\u26a1 Logarithmic time operations</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_6","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_6","title":"Structure","text":"<pre><code>public class PriorityQueue&lt;T extends Comparable&lt;? super T&gt;&gt; {\n    // Initial capacity of the priority queue\n    private static final int INITIAL_CAPACITY = 13;\n\n    // Backing array for the heap\n    private T[] backingArray;\n\n    // Number of elements in the queue\n    private int size;\n\n    @SuppressWarnings(\"unchecked\")\n    public PriorityQueue() {\n        backingArray = (T[]) new Comparable[INITIAL_CAPACITY];\n        size = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_3","title":"\ud83d\udd27 Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#add-operation","title":"Add Operation","text":"<p><pre><code>public void add(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Cannot add null data\");\n    }\n\n    // Resize if necessary\n    if (size + 1 == backingArray.length) {\n        resize();\n    }\n\n    // Add element to the end and restore heap property\n    backingArray[++size] = data;\n    upHeap(size);\n}\n\nprivate void upHeap(int index) {\n    while (index &gt; 1 &amp;&amp; \n           backingArray[index].compareTo(backingArray[index / 2]) &lt; 0) {\n        swap(backingArray, index, index / 2);\n        index = index / 2;\n    }\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) -   \ud83d\udcad When to Use: Adding new elements with priority -   \u26a0\ufe0f Key Points:     -   Maintains heap property     -   Handles resizing     -   Null checking</p>"},{"location":"1.Fundamentals/b_data_structures/#remove-operation","title":"Remove Operation","text":"<p><pre><code>public T remove() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Queue is empty\");\n    }\n\n    T removed = backingArray[1];\n    backingArray[1] = backingArray[size];\n    backingArray[size--] = null;\n\n    if (!isEmpty()) {\n        downHeap(1);\n    }\n\n    return removed;\n}\n\nprivate void downHeap(int index) {\n    while (2 * index &lt;= size) {\n        int j = 2 * index;\n        if (j &lt; size &amp;&amp; backingArray[j].compareTo(backingArray[j + 1]) &gt; 0) {\n            j++;\n        }\n        if (backingArray[index].compareTo(backingArray[j]) &lt;= 0) {\n            break;\n        }\n        swap(backingArray, index, j);\n        index = j;\n    }\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) -   \ud83d\udcad When to Use: Removing highest priority element -   \u26a0\ufe0f Key Points:     -   Maintains heap order     -   Handles empty case     -   Cleans references</p>"},{"location":"1.Fundamentals/b_data_structures/#peek-operation_2","title":"Peek Operation","text":"<p><pre><code>public T peek() {\n    if (isEmpty()) {\n        throw new NoSuchElementException(\"Queue is empty\");\n    }\n    return backingArray[1];\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(1) -   \ud83d\udcad When to Use: Viewing highest priority element -   \u26a0\ufe0f Key Points:     -   No modification to structure     -   Empty check</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_6","title":"\ud83d\udcca Performance Summary","text":""},{"location":"1.Fundamentals/b_data_structures/#performance-summary_7","title":"\ud83d\udcca Performance Summary","text":"Operation Time Complexity Notes Add/Offer O(log n) Requires upheap Remove/Poll O(log n) Requires downheap Peek O(1) Constant time isEmpty O(1) Constant time Size O(1) Constant time Clear O(1) New array allocation ### \ud83d\udca1 Best Practices #### 1. Maintain Heap Property <pre><code>private void swap(T[] arr, int i, int j) {\n    T temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n\nprivate int parent(int index) {\n    return index / 2;\n}\n\nprivate int leftChild(int index) {\n    return 2 * index;\n}\n\nprivate int rightChild(int index) {\n    return 2 * index + 1;\n}\n</code></pre> #### 2. Efficient Resizing <pre><code>@SuppressWarnings(\"unchecked\")\nprivate void resize() {\n    T[] newArray = (T[]) new Comparable[backingArray.length * 2];\n    for (int i = 1; i &lt;= size; i++) {\n        newArray[i] = backingArray[i];\n    }\n    backingArray = newArray;\n}\n</code></pre> #### 3. Handle Special Cases <pre><code>public boolean isEmpty() {\n    return size == 0;\n}\n\n@SuppressWarnings(\"unchecked\")\npublic void clear() {\n    backingArray = (T[]) new Comparable[INITIAL_CAPACITY];\n    size = 0;\n}\n</code></pre> ### \u26a0\ufe0f Common Pitfalls #### 1. Index Management <pre><code>// WRONG - Using 0-based indexing\nprivate int parent(int i) {\n    return (i - 1) / 2;\n}\n\n// CORRECT - Using 1-based indexing\nprivate int parent(int i) {\n    return i / 2;\n}\n</code></pre> #### 2. Comparator Consistency <pre><code>// WRONG - Inconsistent comparison\nif (a.someValue() &lt; b.someValue()) {\n    swap(a, b);\n}\n\n// CORRECT - Use compareTo\nif (a.compareTo(b) &lt; 0) {\n    swap(a, b);\n}\n</code></pre> ### \ud83c\udfaf Common Use Cases #### 1. Task Scheduling <pre><code>class Task implements Comparable&lt;Task&gt; {\n    private int priority;\n    private String description;\n\n    @Override\n    public int compareTo(Task other) {\n        return Integer.compare(this.priority, other.priority);\n    }\n}\n\nPriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;();\ntaskQueue.add(new Task(1, \"High Priority\"));\ntaskQueue.add(new Task(3, \"Low Priority\"));\n</code></pre> #### 2. Dijkstra's Algorithm <pre><code>PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; \n    Integer.compare(a.distance, b.distance));\npq.add(source);\nwhile (!pq.isEmpty()) {\n    Node current = pq.remove();\n    // Process node\n}\n</code></pre> #### 3. Event Processing <pre><code>class Event implements Comparable&lt;Event&gt; {\n    private long timestamp;\n\n    @Override\n    public int compareTo(Event other) {\n        return Long.compare(this.timestamp, other.timestamp);\n    }\n}\n\nPriorityQueue&lt;Event&gt; events = new PriorityQueue&lt;&gt;();\nevents.add(new Event(System.currentTimeMillis()));\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_5","title":"References","text":"<p>Priority Queue Introduction Priority Queue Min Heaps and Max Heaps Priority Queue Adding Elements Priority Queue Removing Elements</p>"},{"location":"1.Fundamentals/b_data_structures/#binary-tree","title":"\ud83c\udf33 Binary Tree","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction_4","title":"Introduction","text":"<p>A Binary Tree is a hierarchical, non-linear data structure where each node has at most two children, referred to as left child and right child. Unlike arrays or linked lists that store data sequentially, Binary Trees allow for representing hierarchical relationships between elements.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_7","title":"Core Characteristics","text":"<ul> <li>\ud83c\udf3f Each node has at most two children</li> <li>\ud83d\udd1d Single root node</li> <li>\ud83d\udcca Hierarchical structure</li> <li>\ud83d\udd04 Recursive nature</li> <li>\ud83c\udfaf Multiple traversal options</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_7","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_7","title":"Structure","text":"<pre><code>public class BinaryTree&lt;T&gt; {\n    private Node&lt;T&gt; root;\n    private int size;\n\n    private static class Node&lt;T&gt; {\n        T data;\n        Node&lt;T&gt; left;\n        Node&lt;T&gt; right;\n\n        Node(T data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    public BinaryTree() {\n        root = null;\n        size = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_4","title":"\ud83d\udd27 Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#traversal-operations","title":"Traversal Operations","text":"<p><pre><code>// InOrder Traversal (Left, Root, Right)\npublic void inOrderTraversal(Node&lt;T&gt; node) {\n    if (node != null) {\n        inOrderTraversal(node.left);\n        process(node.data);\n        inOrderTraversal(node.right);\n    }\n}\n\n// PreOrder Traversal (Root, Left, Right)\npublic void preOrderTraversal(Node&lt;T&gt; node) {\n    if (node != null) {\n        process(node.data);\n        preOrderTraversal(node.left);\n        preOrderTraversal(node.right);\n    }\n}\n\n// PostOrder Traversal (Left, Right, Root)\npublic void postOrderTraversal(Node&lt;T&gt; node) {\n    if (node != null) {\n        postOrderTraversal(node.left);\n        postOrderTraversal(node.right);\n        process(node.data);\n    }\n}\n\n// Level Order Traversal (BFS)\npublic void levelOrderTraversal() {\n    if (root == null) return;\n\n    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        Node&lt;T&gt; current = queue.poll();\n        process(current.data);\n\n        if (current.left != null) queue.offer(current.left);\n        if (current.right != null) queue.offer(current.right);\n    }\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(n) for all traversals -   \ud83d\udcad When to Use: Different traversal orders for different needs -   \u26a0\ufe0f Key Points: Each traversal visits all nodes exactly once</p>"},{"location":"1.Fundamentals/b_data_structures/#insertion-operation","title":"Insertion Operation","text":"<pre><code>public void insert(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    if (root == null) {\n        root = new Node&lt;&gt;(data);\n        size++;\n        return;\n    }\n\n    // Level-order insertion\n    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        Node&lt;T&gt; current = queue.poll();\n\n        if (current.left == null) {\n            current.left = new Node&lt;&gt;(data);\n            size++;\n            return;\n        } else {\n            queue.offer(current.left);\n        }\n\n        if (current.right == null) {\n            current.right = new Node&lt;&gt;(data);\n            size++;\n            return;\n        } else {\n            queue.offer(current.right);\n        }\n    }\n}\n</code></pre> <ul> <li>\u23f1\ufe0f Time Complexity: O(n)</li> <li>\ud83d\udcad When to Use: Adding new nodes to the tree</li> <li>\u26a0\ufe0f Key Points: Level-order insertion maintains tree balance</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#search-operation_1","title":"Search Operation","text":"<p><pre><code>public boolean contains(T data) {\n    return searchHelper(root, data);\n}\n\nprivate boolean searchHelper(Node&lt;T&gt; node, T data) {\n    if (node == null) return false;\n\n    if (node.data.equals(data)) return true;\n\n    return searchHelper(node.left, data) || \n           searchHelper(node.right, data);\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(n) -   \ud83d\udcad When to Use: Finding elements in the tree -   \u26a0\ufe0f Key Points: Must traverse potentially entire tree</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_8","title":"\ud83d\udcca Performance Summary","text":""},{"location":"1.Fundamentals/b_data_structures/#performance-summary_9","title":"\ud83d\udcca Performance Summary","text":"Operation Time Complexity Notes Insertion O(n) Level-order insertion Search O(n) Worst case traversal Deletion O(n) Find and reorganize Traversal O(n) All traversal types Height O(n) Must visit all nodes Size O(1) Maintained variable isEmpty O(1) Check root null"},{"location":"1.Fundamentals/b_data_structures/#best-practices_6","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-proper-node-handling","title":"1. Proper Node Handling","text":"<pre><code>private void validate(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-traversal-selection","title":"2. Traversal Selection","text":"<pre><code>// Use appropriate traversal for the task\n// InOrder: Sorted sequence in BST\n// PreOrder: Copy/serialize tree\n// PostOrder: Delete tree/calculate size\n// LevelOrder: Level-based processing\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-memory-management_3","title":"3. Memory Management","text":"<pre><code>public void clear() {\n    root = null;  // Allow GC to clean up\n    size = 0;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_6","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-not-handling-null-cases","title":"1. Not Handling Null Cases","text":"<pre><code>// WRONG\npublic void process(Node&lt;T&gt; node) {\n    process(node.left);  // NPE if node is null\n}  \n\n// CORRECT\npublic void process(Node&lt;T&gt; node) {\n    if (node == null) return;\n    process(node.left);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-improper-traversal-choice","title":"2. Improper Traversal Choice","text":"<pre><code>// WRONG - Using inOrder for level-based processing\n// CORRECT - Use levelOrder for level-based operations\npublic void printLevelByLevel() {\n    levelOrderTraversal();\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-use-cases_3","title":"\ud83c\udfaf Common Use Cases","text":""},{"location":"1.Fundamentals/b_data_structures/#1-file-system-representation","title":"1. File System Representation","text":"<pre><code>class FileNode&lt;T&gt; extends Node&lt;T&gt; {\n    boolean isDirectory;\n    // File system specific operations\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-expression-trees","title":"2. Expression Trees","text":"<pre><code>class ExpressionNode&lt;T&gt; extends Node&lt;T&gt; {\n    boolean isOperator;\n    public double evaluate() {\n        // Evaluation logic\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-decision-trees","title":"3. Decision Trees","text":"<pre><code>class DecisionNode&lt;T&gt; extends Node&lt;T&gt; {\n    boolean isLeaf;\n    public T decide(Input input) {\n        // Decision logic\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_6","title":"References","text":"<p>Binary Tree Data Structure</p>"},{"location":"1.Fundamentals/b_data_structures/#binary-search-tree","title":"\ud83c\udf33 Binary Search Tree","text":""},{"location":"1.Fundamentals/b_data_structures/#introduction_5","title":"Introduction","text":"<p>A Binary Search Tree (BST) is a binary tree that maintains an ordering property: for each node, all elements in its left subtree are less than the node's value, and all elements in its right subtree are greater. This property makes BSTs efficient for searching, inserting, and deleting elements.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_8","title":"Core Characteristics","text":"<ul> <li>\ud83d\udcca Ordered structure</li> <li>\ud83d\udd0d Efficient searching</li> <li>\ud83c\udfaf Dynamic operations</li> <li>\ud83c\udf3f Binary tree properties</li> <li>\u2696\ufe0f Balance affects performance</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_8","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_8","title":"Structure","text":"<pre><code>public class BST&lt;T extends Comparable&lt;? super T&gt;&gt; {\n    private BSTNode&lt;T&gt; root;\n    private int size;\n\n    private static class BSTNode&lt;T&gt; {\n        T data;\n        BSTNode&lt;T&gt; left;\n        BSTNode&lt;T&gt; right;\n\n        BSTNode(T data) {\n            this.data = data;\n            left = null;\n            right = null;\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_5","title":"\ud83d\udd27 Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#add-operation_1","title":"Add Operation","text":"<p><pre><code>public void add(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    root = addHelper(data, root);\n}\n\nprivate BSTNode&lt;T&gt; addHelper(T data, BSTNode&lt;T&gt; node) {\n    if (node == null) {\n        size++;\n        return new BSTNode&lt;&gt;(data);\n    }\n\n    int compare = data.compareTo(node.data);\n    if (compare &lt; 0) {\n        node.left = addHelper(data, node.left);\n    } else if (compare &gt; 0) {\n        node.right = addHelper(data, node.right);\n    }\n    return node;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) average, O(n) worst case -   \ud83d\udcad When to Use: Inserting new elements while maintaining order -   \u26a0\ufe0f Key Points:     -   Maintains BST property     -   Handles duplicates     -   Recursive implementation</p>"},{"location":"1.Fundamentals/b_data_structures/#remove-operation_1","title":"Remove Operation","text":"<p><pre><code>public T remove(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    BSTNode&lt;T&gt; dummy = new BSTNode&lt;&gt;(null);\n    root = removeHelper(data, root, dummy);\n    return dummy.data;\n}\n\nprivate BSTNode&lt;T&gt; removeHelper(T data, BSTNode&lt;T&gt; node, BSTNode&lt;T&gt; dummy) {\n    if (node == null) {\n        throw new NoSuchElementException(\"Data not found\");\n    }\n\n    int compare = data.compareTo(node.data);\n    if (compare &lt; 0) {\n        node.left = removeHelper(data, node.left, dummy);\n    } else if (compare &gt; 0) {\n        node.right = removeHelper(data, node.right, dummy);\n    } else {\n        dummy.data = node.data;\n        size--;\n\n        if (node.left == null) {\n            return node.right;\n        } else if (node.right == null) {\n            return node.left;\n        } else {\n            BSTNode&lt;T&gt; successor = findSuccessor(node.right);\n            node.data = successor.data;\n            node.right = removeHelper(successor.data, node.right, dummy);\n        }\n    }\n    return node;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) average, O(n) worst case -   \ud83d\udcad When to Use: Removing elements while maintaining order -   \u26a0\ufe0f Key Points:     -   Three cases: leaf, one child, two children     -   Uses successor for two-child case     -   Maintains BST property</p>"},{"location":"1.Fundamentals/b_data_structures/#search-operation_2","title":"Search Operation","text":"<p><pre><code>public T get(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n\n    BSTNode&lt;T&gt; node = getHelper(data, root);\n    if (node == null) {\n        throw new NoSuchElementException(\"Data not found\");\n    }\n    return node.data;\n}\n\nprivate BSTNode&lt;T&gt; getHelper(T data, BSTNode&lt;T&gt; node) {\n    if (node == null) {\n        return null;\n    }\n\n    int compare = data.compareTo(node.data);\n    if (compare &lt; 0) {\n        return getHelper(data, node.left);\n    } else if (compare &gt; 0) {\n        return getHelper(data, node.right);\n    }\n    return node;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) average, O(n) worst case -   \ud83d\udcad When to Use: Finding elements in the tree -   \u26a0\ufe0f Key Points:     -   Uses comparisons for direction     -   Returns stored data     -   Handles not found case</p>"},{"location":"1.Fundamentals/b_data_structures/#traversal-operations_1","title":"Traversal Operations","text":"<p><pre><code>// In-order traversal (sorted order)\npublic List&lt;T&gt; inorder() {\n    List&lt;T&gt; result = new ArrayList&lt;&gt;();\n    inorderHelper(root, result);\n    return result;\n}\n\nprivate void inorderHelper(BSTNode&lt;T&gt; node, List&lt;T&gt; result) {\n    if (node != null) {\n        inorderHelper(node.left, result);\n        result.add(node.data);\n        inorderHelper(node.right, result);\n    }\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(n) -   \ud83d\udcad When to Use: Getting elements in sorted order -   \u26a0\ufe0f Key Points:     -   In-order gives sorted sequence     -   Pre-order for copying tree     -   Post-order for deletion</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_10","title":"\ud83d\udcca Performance Summary","text":"Operation Average Case Worst Case Notes Insert O(log n) O(n) Unbalanced case Remove O(log n) O(n) Unbalanced case Search O(log n) O(n) Unbalanced case Traversal O(n) O(n) Visits all nodes Height O(1) O(1) Cached value Size O(1) O(1) Maintained count"},{"location":"1.Fundamentals/b_data_structures/#best-practices_7","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-balance-maintenance","title":"1. Balance Maintenance","text":"<pre><code>// Consider using self-balancing variants for better performance guarantees\n// AVL or Red-Black trees for automatic balancing\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-comparison-handling","title":"2. Comparison Handling","text":"<pre><code>// Use compareTo consistently\nint compare = data.compareTo(node.data);\nif (compare &lt; 0) {\n    // Go left\n} else if (compare &gt; 0) {\n    // Go right\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-null-handling","title":"3. Null Handling","text":"<pre><code>// Always validate input\nif (data == null) {\n    throw new IllegalArgumentException(\"Data cannot be null\");\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_7","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-unbalanced-trees","title":"1. Unbalanced Trees","text":"<pre><code>// WRONG - Adding sorted data creates linear structure\nbst.add(1);\nbst.add(2);\nbst.add(3);  // Creates right-skewed tree\n\n// BETTER - Balance the tree or use self-balancing variant\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-memory-management","title":"2. Memory Management","text":"<pre><code>// WRONG - Memory leak in remove\nnode = null;  // Only removes reference\n\n// CORRECT - Clean all references\nnode.left = null;\nnode.right = null;\nnode.data = null;\nnode = null;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-use-cases_4","title":"\ud83c\udfaf Common Use Cases","text":""},{"location":"1.Fundamentals/b_data_structures/#1-dictionary-implementation","title":"1. Dictionary Implementation","text":"<pre><code>BST&lt;String&gt; dictionary = new BST&lt;&gt;();\ndictionary.add(\"apple\");\ndictionary.add(\"banana\");\n// Fast lookups: O(log n) average\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-priority-management","title":"2. Priority Management","text":"<pre><code>BST&lt;Task&gt; tasks = new BST&lt;&gt;();\ntasks.add(new Task(1, \"High Priority\"));\ntasks.add(new Task(2, \"Medium Priority\"));\n// Natural ordering of tasks\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-symbol-tables","title":"3. Symbol Tables","text":"<pre><code>BST&lt;Symbol&gt; symbolTable = new BST&lt;&gt;();\nsymbolTable.add(new Symbol(\"x\", 10));\nsymbolTable.add(new Symbol(\"y\", 20));\n// Efficient symbol lookup\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_7","title":"References","text":"<p>Binary Search Trees Binary Search Tree Introduction Binary Search Tree Insertion Binary Search Tree Removal Binary Search Tree Traversal</p>"},{"location":"1.Fundamentals/b_data_structures/#advanced-tree-based-structures_1","title":"\ud83c\udf32 Advanced Tree-Based Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#avl-trees","title":"\ud83c\udf33 AVL Trees","text":"<p>An AVL Tree is a self-balancing bin tree where the heights of the left and right subtrees of any node differ by at most one. This balance ot ensures that the tree remains approximately balanced during insertion deletions, maintaining O(log n) time complexity for all operations.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_9","title":"Core Characteristics","text":"<ul> <li>\ud83d\udd04 Self-balancing mechanism</li> <li>\ud83d\udccf Height tracking</li> <li>\u2696\ufe0f Balance factor management</li> <li>\ud83c\udfaf BST properties maintained</li> <li>\ud83d\udd0d Guaranteed O(log n) operations</li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_9","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_9","title":"Structure","text":"<pre><code>public class AVLTree&lt;T extends Comparable&lt;? super T&gt;&gt; {\n     AVLNode&lt;T&gt; root;\n    private int size;\n\n    private static class AVLNode&lt;T&gt; {\n     T data;\n        AVLNode&lt;T&gt; left;\n     AVLNode&lt;T&gt; right;\n     int height;\n     int balanceFactor;\n            AVLNode(T data) {\n            this.data = data;\n            this.height = 0;\n            this.balanceFactor = 0;\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#node-properties","title":"Node Properties","text":"<ol> <li><code>data</code>: Stores the actual value/element</li> <li><code>left</code>: Reference to left child n lement etil ri clrenco right child node</li> <li><code>height</code>: Distance to the furthest leaf in its subtree</li> <li><code>balanceFactor</code>: Difference between left and right subtree heights</li> </ol>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_6","title":"\ud83d\udd27 Core Operations","text":"<p>Balance Helper Methods <pre><code>private int height(AVLNode&lt;T&gt; node) {\n    return node == null ? -1 : node.height;\n}\n\nprivate void updateHeightAndBF(AVLNode&lt;T&gt; node) {\n    int leftHeight = height(node.left);\n    int rightHeight = height(node.right);\n    node.height = Math.max(leftHeight, rightHeight) + 1;\n    node.balanceFactor = leftHeight - rightHeight;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(1) -   \ud83d\udcad When to Use: After any structural changes -   \u26a0\ufe0f Key Points:     -   Height of null node is -1     -   Balance factor = leftHeight - rightHeight     -   Must update after rotations</p>"},{"location":"1.Fundamentals/b_data_structures/#rotation-operations","title":"Rotation Operations","text":"<p><pre><code>private AVLNode&lt;T&gt; rotateLeft(AVLNode&lt;T&gt; node) {\n    AVLNode&lt;T&gt; newRoot = node.right;\n    node.right = newRoot.left;\n    newRoot.left = node;\n\n    updateHeightAndBF(node);\n    updateHeightAndBF(newRoot);\n    return newRoot;\n}\n\nprivate AVLNode&lt;T&gt; rotateRight(AVLNode&lt;T&gt; node) {\n    AVLNode&lt;T&gt; newRoot = node.left;\n    node.left = newRoot.right;\n    newRoot.right = node;\n\n    updateHeightAndBF(node);\n    updateHeightAndBF(newRoot);\n    return newRoot;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(1) -   \ud83d\udcad When to Use: Rebalancing after insertions/deletions -   \u26a0\ufe0f Key Points:     -   Update heights after rotation     -   Maintain BST properties     -   Return new root of subtree</p>"},{"location":"1.Fundamentals/b_data_structures/#balance-operation","title":"Balance Operation","text":"<p><pre><code>private AVLNode&lt;T&gt; balance(AVLNode&lt;T&gt; node) {\n    updateHeightAndBF(node);\n\n    if (node.balanceFactor &lt; -1) {  // Right heavy\n        if (node.right.balanceFactor &gt; 0) {  // Right-Left case\n            node.right = rotateRight(node.right);\n        }\n        return rotateLeft(node);\n    } else if (node.balanceFactor &gt; 1) {  // Left heavy\n        if (node.left.balanceFactor &lt; 0) {  // Left-Right case\n            node.left = rotateLeft(node.left);\n        }\n        return rotateRight(node);\n    }\n\n    return node;\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(1) -   \ud83d\udcad When to Use: After modifications that might affect balance -   \u26a0\ufe0f Key Points:     -   Handles all four rotation cases     -   Updates height before checking balance     -   Returns balanced subtree root</p>"},{"location":"1.Fundamentals/b_data_structures/#add-operation_2","title":"Add Operation","text":"<p><pre><code>public void add(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Data cannot be null\");\n    }\n    root = addHelper(data, root);\n}\n\nprivate AVLNode&lt;T&gt; addHelper(T data, AVLNode&lt;T&gt; node) {\n    if (node == null) {\n        size++;\n        return new AVLNode&lt;&gt;(data);\n    }\n\n    int compare = data.compareTo(node.data);\n    if (compare &lt; 0) {\n        node.left = addHelper(data, node.left);\n    } else if (compare &gt; 0) {\n        node.right = addHelper(data, node.right);\n    }\n\n    return balance(node);\n}\n</code></pre> -   \u23f1\ufe0f Time Complexity: O(log n) -   \ud83d\udcad When to Use: Adding new elements -   \u26a0\ufe0f Key Points:     -   BST properties maintained     -   Auto-balancing after insertion     -   Uses pointer reinforcement</p>"},{"location":"1.Fundamentals/b_data_structures/#performance-summary_11","title":"\ud83d\udcca Performance Summary","text":"Operation Average Case Worst Case Notes Add O(log n) O(log n) Includes rebalancing Remove O(log n) O(log n) Includes rebalancing Search O(log n) O(log n) Same as BST Rotation O(1) O(1) Height updates included Balance O(1) O(1) Maximum two rotations Height O(1) O(1) Cached in node"},{"location":"1.Fundamentals/b_data_structures/#visualization-of-rotations","title":"\ud83c\udfaf Visualization of Rotations","text":""},{"location":"1.Fundamentals/b_data_structures/#left-rotation","title":"Left Rotation","text":"<pre><code>Before:       After:\n  A            B\n   \\          / \\\n    B   =&gt;   A   C\n     \\\n      C\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#right-rotation","title":"Right Rotation","text":"<pre><code>Before:       After:\n    C          B\n   /          / \\\n  B    =&gt;    A   C\n /\nA\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#double-rotation-left-right","title":"Double Rotation (Left-Right)","text":"<pre><code>Before:       Middle:        After:\n  C            C              B\n /            /             /  \\\nA     =&gt;     B     =&gt;     A    C\n \\          /\n  B        A\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#double-rotation-right-left","title":"Double Rotation (Right-Left)","text":"<pre><code>Before:         Middle:         After:\n    A             A               B\n     \\             \\            /  \\\n      C     =&gt;      B    =&gt;    A    C\n     /               \\\n    B                 C\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#best-practices_8","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-height-management","title":"1. Height Management","text":"<pre><code>// Always update heights bottom-up\nupdateHeightAndBF(node);\nif (node.parent != null) {\n    updateHeightAndBF(node.parent);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-balance-factor-checks","title":"2. Balance Factor Checks","text":"<pre><code>// Check both balance factor and height\nif (Math.abs(node.balanceFactor) &gt; 1) {\n    return balance(node);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-rotation-selection","title":"3. Rotation Selection","text":"<pre><code>// Clear conditions for rotation type\nif (node.balanceFactor &gt; 1) {  // Left heavy\n    if (node.left.balanceFactor &lt; 0) {  // Left-Right case\n        node.left = rotateLeft(node.left);\n    }\n    return rotateRight(node);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_8","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-incorrect-height-updates","title":"1. Incorrect Height Updates","text":"<pre><code>// WRONG - Not updating ancestor heights\nnode = balance(node);\n\n// CORRECT - Update all affected nodes\nnode = balance(node);\nupdateAncestorHeights(node);\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-balance-factor-calculation","title":"2. Balance Factor Calculation","text":"<pre><code>// WRONG - Swapped height difference\nbalanceFactor = rightHeight - leftHeight;\n\n// CORRECT\nbalanceFactor = leftHeight - rightHeight;\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#references_8","title":"References","text":"<p>AVL Trees Simply Explained Red-Black Trees in 4 min 2-3 Trees K-D Trees M-Ary Trees</p>"},{"location":"1.Fundamentals/b_data_structures/#hash-based-structures_1","title":"\ud83c\udfaf Hash-Based Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#hashmaps","title":"#\ufe0f\u20e3 HashMaps","text":"<p>A HashMap is a data structure that implements the Map ADT, storing key-value pairs for O(1) average-case access time. This implementation uses separate chaining for collision resolution, where collisions are handled by maintaining linked lists at each array index.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_10","title":"Core Characteristics","text":"<ul> <li>\ud83d\udd11  Unique Key Mapping<ul> <li>Each key can map to only one value</li> <li>Keys must be immutable</li> <li>Values can be modified or duplicated</li> <li>Perfect for one-to-one relationships</li> </ul> </li> <li>\u26a1  Constant-Time Operations<ul> <li>O(1) average case for insertions</li> <li>O(1) average case for retrievals</li> <li>O(1) average case for deletions</li> <li>Performance dependent on hash function quality</li> </ul> </li> <li>\ud83c\udfaf  Hash Distribution<ul> <li>Converts keys to array indices via hashing</li> <li>Uses hashCode() method for initial hash</li> <li>Compresses hash to fit array bounds</li> <li>Aims for uniform distribution of keys</li> </ul> </li> <li>\u26d3\ufe0f  Collision Management<ul> <li>Handles key collisions using linked lists</li> <li>Each array index can store multiple entries</li> <li>Entries in same bucket form a chain</li> <li>Search within chain is O(n) worst case</li> </ul> </li> <li>\u2696\ufe0f  Load Factor Control<ul> <li>Maintains ratio of size to capacity</li> <li>Typically keeps load factor below 0.67</li> <li>Triggers resizing when threshold reached</li> <li>Prevents performance degradation</li> <li>Uses prime number capacities for better distribution</li> </ul> </li> <li>\ud83d\udd04  Dynamic Resizing<ul> <li>Doubles capacity when load factor exceeded</li> <li>Adds 1 to ensure prime capacity</li> <li>Rehashes all existing entries</li> <li>Maintains performance characteristics</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_10","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#node-structure","title":"Node Structure","text":"<pre><code>private static class Node&lt;K, V&gt; {\n    K key;\n    V value;\n    Node&lt;K, V&gt; next;\n\n    Node(K key, V value) {\n        this.key = key;\n        this.value = value;\n        this.next = null;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#basic-class-structure","title":"Basic Class Structure","text":"<pre><code>public class HashMap&lt;K, V&gt; {\n    private Node&lt;K, V&gt;[] table;\n    private int size;\n    private static final int INITIAL_CAPACITY = 13;  // Prime number\n    private static final double MAX_LOAD_FACTOR = 0.67;\n\n    @SuppressWarnings(\"unchecked\")\n    public HashMap() {\n        table = (Node&lt;K, V&gt;[]) new Node[INITIAL_CAPACITY];\n        size = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_7","title":"Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#put-operation","title":"Put Operation","text":"<pre><code>public V put(K key, V value) {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n\n    // Check if resize is needed\n    if ((double) (size + 1) / table.length &gt; MAX_LOAD_FACTOR) {\n        resize();\n    }\n\n    int index = getIndex(key);\n\n    // Check if key already exists\n    Node&lt;K, V&gt; current = table[index];\n    while (current != null) {\n        if (current.key.equals(key)) {\n            V oldValue = current.value;\n            current.value = value;\n            return oldValue;\n        }\n        current = current.next;\n    }\n\n    // Add new node at the beginning of the chain\n    Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);\n    newNode.next = table[index];\n    table[index] = newNode;\n    size++;\n\n    return null;\n}\n\nprivate int getIndex(K key) {\n    return Math.abs(key.hashCode() % table.length);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#get-operation","title":"Get Operation","text":"<pre><code>public V get(K key) {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n\n    int index = getIndex(key);\n    Node&lt;K, V&gt; current = table[index];\n\n    while (current != null) {\n        if (current.key.equals(key)) {\n            return current.value;\n        }\n        current = current.next;\n    }\n\n    return null;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#remove-operation_2","title":"Remove Operation","text":"<pre><code>public V remove(K key) {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n\n    int index = getIndex(key);\n    Node&lt;K, V&gt; current = table[index];\n    Node&lt;K, V&gt; prev = null;\n\n    while (current != null) {\n        if (current.key.equals(key)) {\n            if (prev == null) {\n                table[index] = current.next;\n            } else {\n                prev.next = current.next;\n            }\n            size--;\n            return current.value;\n        }\n        prev = current;\n        current = current.next;\n    }\n\n    return null;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#resize-operation","title":"Resize Operation","text":"<pre><code>@SuppressWarnings(\"unchecked\")\nprivate void resize() {\n    int newCapacity = (2 * table.length) + 1;  // Prime number\n    Node&lt;K, V&gt;[] oldTable = table;\n    table = (Node&lt;K, V&gt;[]) new Node[newCapacity];\n    size = 0;\n\n    // Rehash all existing entries\n    for (Node&lt;K, V&gt; head : oldTable) {\n        Node&lt;K, V&gt; current = head;\n        while (current != null) {\n            put(current.key, current.value);\n            current = current.next;\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#performance-characteristics","title":"Performance Characteristics","text":"Operation Average Case Worst Case Notes Put O(1) O(n) When chain degrades to linked list Get O(1) O(n) When chain degrades to linked list Remove O(1) O(n) When chain degrades to linked list Space O(n) O(n) n = number of key-value pairs"},{"location":"1.Fundamentals/b_data_structures/#best-practices_9","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-load-factor-management","title":"1. Load Factor Management","text":"<pre><code>private boolean needsResize() {\n    return (double) size / table.length &gt; MAX_LOAD_FACTOR;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-key-quality","title":"2. Key Quality","text":"<pre><code>// Override hashCode() in key objects\n@Override\npublic int hashCode() {\n    int hash = 17;\n    hash = 31 * hash + field1.hashCode();\n    hash = 31 * hash + field2.hashCode();\n    return hash;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-proper-equals-implementation","title":"3. Proper Equals Implementation","text":"<pre><code>@Override\npublic boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null || getClass() != obj.getClass()) return false;\n    MyKey other = (MyKey) obj;\n    return field1.equals(other.field1) &amp;&amp; field2.equals(other.field2);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_9","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-poor-hash-distribution","title":"1. Poor Hash Distribution","text":"<pre><code>// WRONG: Poor hash function\npublic int hashCode() {\n    return 1;  // All items hash to same bucket\n}\n\n// BETTER: Good distribution\npublic int hashCode() {\n    return Objects.hash(field1, field2);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-missing-null-checks","title":"2. Missing Null Checks","text":"<pre><code>// WRONG: No null check\npublic V put(K key, V value) {\n    int index = key.hashCode() % table.length;  // NullPointerException!\n\n// CORRECT: With null check\npublic V put(K key, V value) {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    int index = getIndex(key);\n</code></pre> <p>HashMaps provide efficient key-value storage with constant-time average case operations, making them ideal for lookup-intensive applications. The separate chaining implementation offers a good balance between simplicity and performance.</p>"},{"location":"1.Fundamentals/b_data_structures/#references_9","title":"References","text":"<p>HashTables with Collision Management</p>"},{"location":"1.Fundamentals/b_data_structures/#graph-based-structures_1","title":"\ud83d\udd78\ufe0f Graph-Based Structures","text":"<p> A Graph is a data structure that models relationships between elements using vertices (nodes) and edges. This implementation represents a directed graph using vertex and edge sets along with an adjacency list representation for efficient neighbor access.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_11","title":"Core Characteristics","text":"<ul> <li>\ud83d\udd0d  Vertex Management<ul> <li>Each vertex contains generic typed data</li> <li>Vertices are unique based on data equality</li> <li>Supports null-safe vertex operations</li> <li>Maintains a vertex set for O(1) lookups</li> </ul> </li> <li>\ud83d\udd17  Edge Properties<ul> <li>Directed edges from vertex u to v</li> <li>Weighted connections</li> <li>Maintains edge set for global access</li> <li>Supports undirected graphs via bidirectional edges</li> </ul> </li> <li>\ud83d\udcca  Adjacency Structure<ul> <li>Maps vertices to neighbor lists</li> <li>Includes edge weights in adjacency entries</li> <li>Efficient neighbor access</li> <li>Space-efficient for sparse graphs</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_11","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#vertex-class","title":"Vertex Class","text":"<pre><code>public class Vertex&lt;T&gt; {\n    private T data;\n\n    public Vertex(T data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Data cannot be null.\");\n        }\n        this.data = data;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o != null &amp;&amp; o instanceof Vertex) {\n            return data.equals(((Vertex&lt;?&gt;) o).data);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return data.hashCode();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#edge-class","title":"Edge Class","text":"<pre><code>public class Edge&lt;T&gt; implements Comparable&lt;Edge&lt;? super T&gt;&gt; {\n    private Vertex&lt;T&gt; u;  // Source vertex\n    private Vertex&lt;T&gt; v;  // Destination vertex\n    private int weight;   // Edge weight\n\n    public Edge(Vertex&lt;T&gt; u, Vertex&lt;T&gt; v, int weight) {\n        if (u == null || v == null) {\n            throw new IllegalArgumentException(\"Arguments cannot be null.\");\n        }\n        this.u = u;\n        this.v = v;\n        this.weight = weight;\n    }\n\n    public Vertex&lt;T&gt; getU() { return u; }\n    public Vertex&lt;T&gt; getV() { return v; }\n    public int getWeight() { return weight; }\n\n    @Override\n    public int compareTo(Edge&lt;? super T&gt; e) {\n        return weight - e.getWeight();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#graph-structure","title":"Graph Structure","text":"<pre><code>public class Graph&lt;T&gt; {\n    private Set&lt;Vertex&lt;T&gt;&gt; vertices;\n    private Set&lt;Edge&lt;T&gt;&gt; edges;\n    private Map&lt;Vertex&lt;T&gt;, List&lt;VertexDistance&lt;T&gt;&gt;&gt; adjList;\n\n    public Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {\n        if (vertices == null || edges == null) {\n            throw new IllegalArgumentException(\"Arguments cannot be null.\");\n        }\n\n        this.vertices = new HashSet&lt;&gt;(vertices);\n        this.edges = new HashSet&lt;&gt;(edges);\n        this.adjList = new HashMap&lt;&gt;();\n\n        // Initialize adjacency list\n        for (Vertex&lt;T&gt; v : vertices) {\n            adjList.put(v, new ArrayList&lt;&gt;());\n        }\n\n        // Populate adjacency list\n        for (Edge&lt;T&gt; e : edges) {\n            if (adjList.containsKey(e.getU())) {\n                adjList.get(e.getU()).add(\n                    new VertexDistance&lt;&gt;(e.getV(), e.getWeight())\n                );\n            } else {\n                throw new IllegalArgumentException(\n                    \"Vertex set must contain all vertices of the graph.\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#vertex-distance-helper","title":"Vertex Distance Helper","text":"<pre><code>public final class VertexDistance&lt;T&gt; \n    implements Comparable&lt;VertexDistance&lt;? super T&gt;&gt; {\n\n    private final Vertex&lt;T&gt; vertex;\n    private final int distance;\n\n    public VertexDistance(Vertex&lt;T&gt; vertex, int distance) {\n        this.vertex = vertex;\n        this.distance = distance;\n    }\n\n    @Override\n    public int compareTo(VertexDistance&lt;? super T&gt; pair) {\n        return this.distance - pair.getDistance();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#performance-characteristics_1","title":"Performance Characteristics","text":"Operation Average Case Worst Case Notes Add Vertex O(1) O(1) HashSet insertion Add Edge O(1) O(1) HashSet &amp; ArrayList insertion Find Vertex O(1) O(1) HashSet lookup Find Edge O(1) O(1) HashSet lookup Get Neighbors O(1) O(1) HashMap &amp; ArrayList access Space O(V + E) O(V + E) V vertices + E edges"},{"location":"1.Fundamentals/b_data_structures/#best-practices_10","title":"Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-creating-undirected-edges","title":"1. Creating Undirected Edges","text":"<pre><code>// Add both directions for undirected edges\nvertices.add(vertexA);\nvertices.add(vertexB);\nedges.add(new Edge&lt;&gt;(vertexA, vertexB, weight));\nedges.add(new Edge&lt;&gt;(vertexB, vertexA, weight));\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-vertex-creation","title":"2. Vertex Creation","text":"<pre><code>// Ensure data validity\npublic static &lt;T&gt; Vertex&lt;T&gt; createVertex(T data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Vertex data cannot be null\");\n    }\n    return new Vertex&lt;&gt;(data);\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#4-edge-validation","title":"4. Edge Validation","text":"<pre><code>private boolean isValidEdge(Edge&lt;T&gt; edge) {\n    return vertices.contains(edge.getU()) \n        &amp;&amp; vertices.contains(edge.getV());\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_10","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-missing-graph-initialization","title":"1. Missing Graph Initialization","text":"<pre><code>// WRONG: Uninitialized collections\npublic Graph() {\n    // Missing initialization\n}\n\n// CORRECT: Properly initialized collections\npublic Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {\n    this.vertices = new HashSet&lt;&gt;(vertices);\n    this.edges = new HashSet&lt;&gt;(edges);\n    this.adjList = new HashMap&lt;&gt;();\n    // ... rest of initialization\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-improper-edge-direction-handling","title":"2. Improper Edge Direction Handling","text":"<pre><code>// WRONG: Assuming bidirectional\nadjList.get(edge.getV()).add(\n    new VertexDistance&lt;&gt;(edge.getU(), edge.getWeight()));\n\n// CORRECT: Respecting edge direction\nadjList.get(edge.getU()).add(\n    new VertexDistance&lt;&gt;(edge.getV(), edge.getWeight()));\n</code></pre> <p>This implementation provides a robust foundation for directed graph operations while maintaining type safety and efficient operations through appropriate data structure choices.</p>"},{"location":"1.Fundamentals/b_data_structures/#references_10","title":"References","text":"<p>Introduction to Graphs</p>"},{"location":"1.Fundamentals/b_data_structures/#disjoint-sets-union-find","title":"\ud83c\udf33 Disjoint-Sets: Union-Find","text":"<p>A Disjoint Set (Union-Find) is a data structure that keeps track of elements partitioned into non-overlapping sets. It provides near-constant time operations to check if two elements are in the same set and to unite two sets, making it essential for algorithms like Kruskal's MST.</p>"},{"location":"1.Fundamentals/b_data_structures/#core-characteristics_12","title":"Core Characteristics","text":"<ul> <li>\ud83c\udf33  Tree-Based Structure<ul> <li>Each set is represented as a tree</li> <li>Elements point to their parent elements</li> <li>Root element represents the set identifier</li> <li>Path compression for efficiency</li> </ul> </li> <li>\ud83d\udd0d  Find Operation<ul> <li>Identifies the set an element belongs to</li> <li>Implements path compression</li> <li>Returns the root element</li> <li>Amortized O(1) time complexity</li> </ul> </li> <li>\ud83e\udd1d  Union Operation<ul> <li>Merges two different sets</li> <li>Uses union by rank</li> <li>Maintains tree balance</li> <li>Prevents deep hierarchies</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/b_data_structures/#implementation-details_12","title":"Implementation Details","text":""},{"location":"1.Fundamentals/b_data_structures/#structure_10","title":"Structure","text":"<pre><code>private static class DisjointSetNode&lt;T&gt; {\n    private DisjointSetNode&lt;T&gt; parent;\n    private T data;\n    private int rank;\n\n    public DisjointSetNode(T data) {\n        this.parent = this;  // Node initially points to itself\n        this.data = data;\n        this.rank = 0;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#base-structure","title":"Base Structure","text":"<pre><code>public class DisjointSet&lt;T&gt; {\n    private Map&lt;T, DisjointSetNode&lt;T&gt;&gt; disjointSet;\n\n    public DisjointSet() {\n        disjointSet = new HashMap&lt;&gt;();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#core-operations_8","title":"Core Operations","text":""},{"location":"1.Fundamentals/b_data_structures/#find-operation","title":"Find Operation","text":"<pre><code>public T find(T data) {\n    if (!disjointSet.containsKey(data)) {\n        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));\n    }\n    return find(disjointSet.get(data)).getData();\n}\n\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; curr) {\n    DisjointSetNode&lt;T&gt; parent = curr.getParent();\n\n    if (parent == curr) {\n        return curr;  // Found root\n    }\n\n    // Path compression: Make all nodes point to root\n    parent = find(curr.getParent());\n    curr.setParent(parent);\n    return parent;\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#performance-characteristics_2","title":"\ud83d\udcca Performance Characteristics","text":"Operation Amortized Time Worst Case Notes Make Set O(1) O(1) Creates new set Find O(\u03b1(n)) O(log n) With path compression Union O(\u03b1(n)) O(log n) With union by rank Space O(n) O(n) n elements <p>Note: \u03b1(n) is the inverse Ackermann function, which grows extremely slowly and is effectively constant for all practical values of n. </p>"},{"location":"1.Fundamentals/b_data_structures/#best-practices_11","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/b_data_structures/#1-path-compression","title":"1. Path Compression","text":"<pre><code>// Always update parent pointers during find\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {\n    if (node != node.getParent()) {\n        node.setParent(find(node.getParent())); // Compress path\n    }\n    return node.getParent();\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-union-by-rank","title":"2. Union by Rank","text":"<pre><code>// Always consider ranks when unioning\nif (firstParent.getRank() &lt; secondParent.getRank()) {\n    firstParent.setParent(secondParent);\n} else {\n    secondParent.setParent(firstParent);\n    if (firstParent.getRank() == secondParent.getRank()) {\n        firstParent.setRank(firstParent.getRank() + 1);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#3-lazy-initialization","title":"3. Lazy Initialization","text":"<pre><code>public T find(T data) {\n    if (!disjointSet.containsKey(data)) {\n        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));\n    }\n    // Continue with find operation\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#common-pitfalls_11","title":"\u26a0\ufe0f Common Pitfalls","text":""},{"location":"1.Fundamentals/b_data_structures/#1-missing-path-compression","title":"1. Missing Path Compression","text":"<pre><code>// WRONG: No path compression\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {\n    while (node != node.getParent()) {\n        node = node.getParent();\n    }\n    return node;\n}\n\n// CORRECT: With path compression\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {\n    if (node != node.getParent()) {\n        node.setParent(find(node.getParent()));\n    }\n    return node.getParent();\n}\n</code></pre>"},{"location":"1.Fundamentals/b_data_structures/#2-incorrect-union-operation","title":"2. Incorrect Union Operation","text":"<pre><code>// WRONG: No path compression\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {\n    while (node != node.getParent()) {\n        node = node.getParent();\n    }\n    return node;\n}\n\n// CORRECT: With path compression\nprivate DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {\n    if (node != node.getParent()) {\n        node.setParent(find(node.getParent()));\n    }\n    return node.getParent();\n}\n</code></pre> <p>This implementation provides an efficient foundation for set operations used in graph algorithms, particularly Kruskal's Minimum Spanning Tree algorithm, with optimizations for both time and space complexity.</p>"},{"location":"1.Fundamentals/b_data_structures/#references_11","title":"References","text":"<p>Union Find Data Structure</p>"},{"location":"1.Fundamentals/b_data_structures/#other-advanced-structures","title":"\ud83d\udcda Other Advanced Structures","text":""},{"location":"1.Fundamentals/b_data_structures/#trie","title":"\ud83d\udd0e Trie","text":"<p>Trie</p>"},{"location":"1.Fundamentals/b_data_structures/#skip-lists","title":"\ud83d\udd0e Skip Lists","text":"<p>Skip List Introduction Skip Lists Insertion and Deletion</p>"},{"location":"1.Fundamentals/c_algorithms/","title":"\ud83d\udcd8 Introduction to Algorithms","text":"<p>Algorithms are systematic procedures for solving computational problems and manipulating data. Understanding algorithms is crucial for developing efficient software solutions and optimizing program performance. This guide explores essential algorithms, their implementations, and practical applications in software engineering.</p>"},{"location":"1.Fundamentals/c_algorithms/#why-algorithms-matter","title":"\ud83c\udfaf Why Algorithms Matter","text":"<ul> <li>\ud83d\ude80  Performance Optimization: Choose the right algorithm to dramatically improve execution speed</li> <li>\ud83d\udcbb  System Scalability: Build solutions that efficiently handle growing data volumes</li> <li>\ud83d\udcbc  Technical Interviews: Essential knowledge for coding interviews at top tech companies</li> <li>\ud83d\udd04  Problem-Solving: Master fundamental approaches to computational challenges</li> <li>\ud83c\udf1f  Competitive Programming: Critical for algorithmic contests and competitions</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#guide-structure","title":"\ud83d\udcda Guide Structure","text":"<p>Each algorithm section covers:</p> <ul> <li>Step-by-step explanation</li> <li>Implementation details</li> <li>Time and space complexity analysis</li> <li>Common optimization techniques</li> <li>Best practices and use cases</li> <li>Code examples and gotchas</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#categories-of-algorithms","title":"\ud83d\uddc2\ufe0f Categories of Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#sorting-algorithms","title":"\ud83d\udcca Sorting Algorithms","text":"<p>Transform unordered collections into ordered sequences:</p> <ul> <li>Bubble Sort:<ul> <li>Simple comparison-based sorting</li> <li>Best for: Educational purposes, tiny datasets</li> </ul> </li> <li>Selection Sort:<ul> <li>In-place comparison sorting</li> <li>Best for: Small arrays, minimal memory</li> </ul> </li> <li>Insertion Sort:<ul> <li>Adaptive, stable sorting</li> <li>Best for: Nearly sorted data, online sorting</li> </ul> </li> <li>Heap Sort:<ul> <li>Comparison-based sorting using heap</li> <li>Best for: Large datasets, guaranteed performance</li> </ul> </li> <li>Quick Sort:<ul> <li>Divide-and-conquer approach</li> <li>Best for: General-purpose sorting, large datasets</li> </ul> </li> <li>Merge Sort:<ul> <li>Stable, divide-and-conquer sorting</li> <li>Best for: Linked lists, external sorting</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#searching-algorithms","title":"\ud83d\udd0d Searching Algorithms","text":"<p>Efficiently locate elements in datasets:</p> <ul> <li>Linear Search:<ul> <li>Sequential element checking</li> <li>Best for: Small or unsorted datasets</li> </ul> </li> <li>Binary Search:<ul> <li>Divide-and-conquer searching</li> <li>Best for: Sorted arrays, large datasets</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#graph-algorithms","title":"\ud83d\udd78\ufe0f Graph Algorithms","text":"<p>Navigate and analyze network structures:</p> <ul> <li>Breadth First Search (BFS):<ul> <li>Level-by-level traversal</li> <li>Best for: Shortest paths, web crawling</li> </ul> </li> <li>Depth First Search (DFS):<ul> <li>Deep traversal exploration</li> <li>Best for: Maze solving, topological sorting</li> </ul> </li> <li>Bellman Ford's Algorithm:<ul> <li>Single-source shortest paths</li> <li>Best for: Graphs with negative edges</li> </ul> </li> <li>Dijkstra's Algorithm:<ul> <li>Efficient shortest path finding</li> <li>Best for: GPS, network routing</li> </ul> </li> <li>__A_  Algorithm_*:<ul> <li>Heuristic pathfinding</li> <li>Best for: Game AI, navigation systems</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#greedy-algorithms","title":"\ud83c\udfaf Greedy Algorithms","text":"<p>Make locally optimal choices:</p> <ul> <li>Huffman Coding:<ul> <li>Data compression</li> <li>Best for: File compression, encoding</li> </ul> </li> <li>Kruskal's Algorithm:<ul> <li>Minimum spanning tree</li> <li>Best for: Network design</li> </ul> </li> <li>Ford-Fulkerson Algorithm:<ul> <li>Maximum flow problems</li> <li>Best for: Network flow optimization</li> </ul> </li> <li>Prim's Algorithm:<ul> <li>Minimum spanning tree</li> <li>Best for: Dense graphs</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#substring-search-algorithms","title":"\ud83d\udd24 Substring Search Algorithms","text":"<p>Pattern matching in text:</p> <ul> <li>Brute Force Search:<ul> <li>Simple pattern matching</li> <li>Best for: Short patterns</li> </ul> </li> <li>Rabin-Karp:<ul> <li>Hash-based pattern matching</li> <li>Best for: Multiple pattern search</li> </ul> </li> <li>Knuth-Morris-Pratt:<ul> <li>Efficient single pattern matching</li> <li>Best for: Single pattern in large text</li> </ul> </li> <li>Boyer-Moore:<ul> <li>Fast pattern matching</li> <li>Best for: Long patterns</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#time-complexity-overview","title":"\u23f1\ufe0f Time Complexity Overview","text":"Algorithm Best Case Average Case Worst Case Space Bubble Sort O(n) O(n\u00b2) O(n\u00b2) O(1) Selection Sort O(n\u00b2) O(n\u00b2) O(n\u00b2) O(1) Insertion Sort O(n) O(n\u00b2) O(n\u00b2) O(1) Heap Sort O(n log n) O(n log n) O(n log n) O(1) Quick Sort O(n log n) O(n log n) O(n\u00b2) O(log n) Merge Sort O(n log n) O(n log n) O(n log n) O(n) Linear Search O(1) O(n) O(n) O(1) Binary Search O(1) O(log n) O(log n) O(1) BFS O(V + E) O(V + E) O(V + E) O(V) DFS O(V + E) O(V + E) O(V + E) O(V) Bellman Ford O(VE) O(VE) O(VE) O(V) Dijkstra O(E log V) O(E log V) O(E log V) O(V) A* O(E) O(E) O(V\u00b2) O(V) Huffman Coding O(n log n) O(n log n) O(n log n) O(n) Kruskal's Algorithm O(E log E) O(E log E) O(E log E) O(V) Ford-Fulkerson O(EF)* O(EF)* O(EF)* O(V + E) Prim's Algorithm O(E log V) O(E log V) O(E log V) O(V) Brute Force Search O(n) O(mn) O(mn) O(1) Rabin-Karp O(m + n) O(m + n) O(mn) O(1) Knuth-Morris-Pratt O(m + n) O(m + n) O(m + n) O(m) Boyer-Moore O(n/m) O(n) O(mn) O(m)"},{"location":"1.Fundamentals/c_algorithms/#references","title":"References","text":"<p>Data Structures and Algorithms Notes</p>"},{"location":"1.Fundamentals/c_algorithms/#sorting-algorithms_1","title":"\ud83d\udd04 Sorting Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#introduction","title":"Introduction","text":"<p>Sorting algorithms are fundamental procedures that arrange elements in a specific order, typically in ascending or descending sequence. Understanding these algorithms is crucial for efficient data manipulation and problem-solving in software development.</p>"},{"location":"1.Fundamentals/c_algorithms/#overview","title":"\ud83d\udcd8 Overview","text":"<p>Sorting algorithms are fundamental procedures that organize data in a specific order. Understanding these algorithms is crucial for:</p> <ul> <li>\ud83c\udfaf  Efficient Data Organization: Transform unordered data into ordered sequences</li> <li>\ud83d\udcbb  Performance Optimization: Choose the right algorithm for your data size and type</li> <li>\ud83d\udd0d  Interview Preparation: Common technical interview topic</li> <li>\ud83e\uddee  Algorithm Foundation: Building block for more complex algorithms</li> <li>\ud83d\udcca  Data Analysis: Essential for data processing and analysis</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-characteristics","title":"\ud83d\udcdd Common Characteristics","text":""},{"location":"1.Fundamentals/c_algorithms/#algorithm-properties","title":"\ud83c\udfaf Algorithm Properties","text":"<ul> <li>Stability: Whether relative order of equal elements is preserved</li> <li>In-Place: Whether additional space is required</li> <li>Adaptivity: Whether performance improves with partially sorted data</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#performance-metrics","title":"\u26a1 Performance Metrics","text":"<ul> <li>Time Complexity: How runtime scales with input size</li> <li>Space Complexity: How memory usage scales with input size</li> <li>Best/Worst Cases: Performance bounds under different conditions</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#basic-sorting-algorithms","title":"\ud83d\udd0d Basic Sorting Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#implementation-details","title":"\ud83d\udd0e Implementation Details","text":""},{"location":"1.Fundamentals/c_algorithms/#1-bubble-sort","title":"1\ufe0f\u20e3 Bubble Sort","text":"<p>A simple comparison-based algorithm that repeatedly steps through the list.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 In-place sorting</li> <li>\u2705 Stable algorithm</li> <li>\u2705 Adaptive behavior</li> <li>\ud83d\udd04 Time: O(n\u00b2) worst/average, O(n) best</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Educational purposes</li> <li>Tiny datasets</li> <li>When simplicity is preferred over efficiency</li> <li>Teaching sorting concepts <pre><code>public static &lt;T&gt; void bubbleSort(T[] arr, Comparator&lt;T&gt; comparator) {\n    if (arr == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    for (int i = 0; i &lt; arr.length - 1; i++) {\n        boolean swapped = false;\n        for (int j = 0; j &lt; arr.length - i - 1; j++) {\n            if (comparator.compare(arr[j], arr[j + 1]) &gt; 0) {\n                // Swap elements\n                T temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n                swapped = true;\n            }\n        }\n        // If no swapping occurred, array is sorted\n        if (!swapped) break;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use swapped flag to optimize for already sorted arrays</li> <li>Each pass bubbles up the largest element</li> <li>Consider cocktail sort variation for better performance</li> <li>Good for visualizing sorting algorithms</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#reference","title":"Reference","text":"<p>Bubble Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#2-selection-sort","title":"2\ufe0f\u20e3 Selection Sort","text":"<p>An in-place comparison sorting algorithm that divides the input into a sorted and unsorted region.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_1","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 In-place sorting</li> <li>\u274c Not stable</li> <li>\u274c Not adaptive</li> <li>\ud83d\udd04 Time: O(n\u00b2) all cases</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_1","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Small arrays</li> <li>When memory is limited</li> <li>When number of swaps needs to be minimized</li> <li>Systems where write operations are costly</li> </ul> <pre><code>public static &lt;T&gt; void selectionSort(T[] arr, Comparator&lt;T&gt; comparator) {\n    if (arr == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    for (int i = 0; i &lt; arr.length - 1; i++) {\n        int minIndex = i;\n        for (int j = i + 1; j &lt; arr.length; j++) {\n            if (comparator.compare(arr[j], arr[minIndex]) &lt; 0) {\n                minIndex = j;\n            }\n        }\n        // Swap with minimum element\n        T temp = arr[minIndex];\n        arr[minIndex] = arr[i];\n        arr[i] = temp;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_1","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Makes minimum number of swaps (O(n))</li> <li>Good when memory writes are expensive</li> <li>Always performs O(n\u00b2) comparisons</li> <li>Can be modified to be stable with additional space</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_1","title":"References","text":"<p>Selection Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#3-insertion-sort","title":"3\ufe0f\u20e3 Insertion Sort","text":"<p>A simple and adaptive sorting algorithm that builds the final sorted array one element at a time.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_2","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 In-place sorting</li> <li>\u2705 Stable algorithm</li> <li>\u2705 Adaptive behavior</li> <li>\ud83d\udd04 Time: O(n\u00b2) worst/average, O(n) best</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_2","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Small datasets (&lt; 50 elements)</li> <li>Nearly sorted arrays</li> <li>Online sorting (real-time data)</li> <li>When simplicity is required</li> </ul> <pre><code>public static &lt;T&gt; void insertionSort(T[] arr, Comparator&lt;T&gt; comparator) {\n    if (arr == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    for (int i = 1; i &lt; arr.length; i++) {\n        T key = arr[i];\n        int j = i - 1;\n        while (j &gt;= 0 &amp;&amp; comparator.compare(arr[j], key) &gt; 0) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_2","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Excellent for small datasets</li> <li>Very efficient for nearly sorted arrays</li> <li>Works well with continuous insertions</li> <li>Often used in hybrid sorting algorithms</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-implementation-pitfalls","title":"\ud83d\udcda Common Implementation Pitfalls","text":"<ul> <li>\u26a0\ufe0f Forgetting null checks for array and comparator</li> <li>\u26a0\ufe0f Incorrect boundary conditions in loops</li> <li>\u26a0\ufe0f Unnecessary swaps that can be avoided</li> <li>\u26a0\ufe0f Not considering stability requirements</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_2","title":"References","text":"<p>Insertion Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#quick-tips-for-basic-sorting","title":"\ud83d\udca1 Quick Tips for Basic Sorting","text":"<ul> <li>\ud83c\udfaf Choose Insertion Sort for tiny arrays or nearly sorted data</li> <li>\ud83d\udd04 Use Selection Sort when memory writes are expensive</li> <li>\ud83d\udcca Bubble Sort is mainly for educational purposes</li> <li>\ud83e\uddea Test with different input sizes and patterns</li> <li>\ud83d\udcdd Consider stability requirements when choosing an algorithm</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-sorting-algorithms","title":"\ud83d\udd04 Advanced Sorting Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#overview_1","title":"\ud83d\ude80 Overview","text":"<p>These algorithms represent more sophisticated sorting approaches, offering better performance for larger datasets:</p> <ul> <li>\ud83d\udcc8  Scalable Performance: Efficient for large datasets</li> <li>\ud83d\udd04  Divide &amp; Conquer: Break complex problems into smaller ones</li> <li>\ud83d\udcab  Advanced Techniques: Utilize sophisticated sorting strategies</li> <li>\ud83c\udfaf  Production Ready: Commonly used in real-world applications</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#implementation-details_1","title":"\ud83d\udd0d Implementation Details","text":""},{"location":"1.Fundamentals/c_algorithms/#1-heap-sort","title":"1\ufe0f\u20e3 Heap Sort","text":"<p>A comparison-based sorting algorithm using a binary heap data structure.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_3","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 In-place sorting</li> <li>\u274c Not stable</li> <li>\u274c Not adaptive</li> <li>\ud83d\udd04 Time: O(n log n) all cases</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_3","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Large datasets</li> <li>Memory-constrained systems</li> <li>When stable sorting isn't required</li> <li>Systems requiring guaranteed O(n log n)</li> </ul> <pre><code>public static int[] heapSort(List&lt;Integer&gt; data) {\n    if (data == null) {\n        throw new IllegalArgumentException(\"List cannot be null\");\n    }\n\n    // Using Java's PriorityQueue for heap implementation\n    PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(data);\n    int[] sorted = new int[data.size()];\n\n    // Extract elements from heap in sorted order\n    for (int i = 0; !heap.isEmpty(); i++) {\n        sorted[i] = heap.remove();\n    }\n\n    return sorted;\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_3","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use built-in PriorityQueue for simple implementation</li> <li>Helpful for implementing priority scheduling</li> <li>Excellent for top-K problems</li> <li>In-place sorting saves memory</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_3","title":"References","text":"<p>Heap Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#2-quick-sort","title":"2\ufe0f\u20e3 Quick Sort","text":"<p>A highly efficient, comparison-based algorithm using divide-and-conquer strategy.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_4","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 In-place sorting</li> <li>\u274c Not stable</li> <li>\u274c Not adaptive</li> <li>\ud83d\udd04 Time: O(n\u00b2) worst, O(n log n) average/best</li> <li>\ud83d\udcbe Space: O(log n)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_4","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Large datasets</li> <li>Systems with good cache locality</li> <li>General-purpose sorting</li> <li>When average case performance is important <pre><code>public static &lt;T&gt; void quickSort(T[] arr, Comparator&lt;T&gt; comparator, Random rand) {\n    if (arr == null || comparator == null || rand == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n    quickSortHelper(arr, comparator, rand, 0, arr.length - 1);\n}\n\nprivate static &lt;T&gt; void quickSortHelper(T[] arr, Comparator&lt;T&gt; comp, \n    Random rand, int start, int end) {\n    if (start &lt; end) {\n        // Choose random pivot\n        int pivotIdx = rand.nextInt(end - start + 1) + start;\n        T pivot = arr[pivotIdx];\n\n        // Move pivot to start\n        swap(arr, start, pivotIdx);\n\n        // Partition\n        int i = start + 1;\n        int j = end;\n        while (i &lt;= j) {\n            while (i &lt;= j &amp;&amp; comp.compare(arr[i], pivot) &lt;= 0) i++;\n            while (i &lt;= j &amp;&amp; comp.compare(arr[j], pivot) &gt; 0) j--;\n            if (i &lt; j) swap(arr, i, j);\n        }\n\n        // Place pivot in correct position\n        swap(arr, start, j);\n\n        // Recursive calls\n        quickSortHelper(arr, comp, rand, start, j - 1);\n        quickSortHelper(arr, comp, rand, j + 1, end);\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_4","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use random pivot selection to avoid worst case</li> <li>Consider median-of-three for pivot selection</li> <li>Switch to insertion sort for small subarrays</li> <li>Be cautious with already sorted arrays</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_4","title":"References","text":"<p>Quick Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#3-merge-sort","title":"3\ufe0f\u20e3 Merge Sort","text":"<p>A stable, divide-and-conquer algorithm with guaranteed performance.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_5","title":"\ud83d\udcca Properties","text":"<ul> <li>\u274c Not in-place</li> <li>\u2705 Stable algorithm</li> <li>\u274c Not adaptive</li> <li>\ud83d\udd04 Time: O(n log n) all cases</li> <li>\ud83d\udcbe Space: O(n)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_5","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Large datasets</li> <li>When stability is required</li> <li>External sorting</li> <li>Linked list sorting</li> </ul> <pre><code>public static &lt;T&gt; void mergeSort(T[] arr, Comparator&lt;T&gt; comparator) {\n    if (arr == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    if (arr.length &gt; 1) {\n        T[] firstHalf = (T[]) new Object[arr.length / 2];\n        T[] secondHalf = (T[]) new Object[arr.length - arr.length / 2];\n\n        // Split array into halves\n        System.arraycopy(arr, 0, firstHalf, 0, firstHalf.length);\n        System.arraycopy(arr, firstHalf.length, secondHalf, 0, secondHalf.length);\n\n        // Recursive sorting\n        mergeSort(firstHalf, comparator);\n        mergeSort(secondHalf, comparator);\n        merge(firstHalf, secondHalf, arr, comparator);\n    }\n}\n\nprivate static &lt;T&gt; void merge(T[] firstHalf, T[] secondHalf, T[] arr, \n                            Comparator&lt;T&gt; comparator) {\n    int i = 0;  // Index for firstHalf array\n    int j = 0;  // Index for secondHalf array\n    int k = 0;  // Index for merged array\n\n    // Compare and merge elements from both halves\n    while (i &lt; firstHalf.length &amp;&amp; j &lt; secondHalf.length) {\n        if (comparator.compare(firstHalf[i], secondHalf[j]) &lt;= 0) {\n            arr[k++] = firstHalf[i++];\n        } else {\n            arr[k++] = secondHalf[j++];\n        }\n    }\n\n    // Copy remaining elements from firstHalf (if any)\n    while (i &lt; firstHalf.length) {\n        arr[k++] = firstHalf[i++];\n    }\n\n    // Copy remaining elements from secondHalf (if any)\n    while (j &lt; secondHalf.length) {\n        arr[k++] = secondHalf[j++];\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_5","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Perfect for external sorting</li> <li>Great for parallel processing</li> <li>Stable sorting guaranteed</li> <li>Consider in-place merge for space optimization</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#additional-merge-tips","title":"\ud83d\udd11 Additional Merge Tips:","text":"<ul> <li>The  <code>&lt;=</code>  in the comparison ensures stability</li> <li>Using separate arrays avoids complex in-place merging</li> <li>Sequential access pattern is cache-friendly</li> <li>Can be optimized for nearly sorted arrays</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_5","title":"References","text":"<p>Merge Sort</p>"},{"location":"1.Fundamentals/c_algorithms/#advanced-implementation-strategies","title":"\ud83c\udfaf Advanced Implementation Strategies","text":""},{"location":"1.Fundamentals/c_algorithms/#optimization-tips","title":"\ud83d\udca1 Optimization Tips","text":"<ul> <li>\ud83d\udd04 Use hybrid approaches for better performance</li> <li>\ud83d\udcca Consider input size for algorithm selection</li> <li>\ud83d\udcbe Balance memory usage vs. speed</li> <li>\u26a1 Optimize for cache efficiency</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Memory management in recursive implementations</li> <li>Pivot selection in QuickSort</li> <li>Improper handling of equal elements</li> <li>Not considering stability requirements</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#merge-function-pitfalls","title":"\u26a0\ufe0f Merge Function Pitfalls:","text":"<ul> <li>Not handling empty arrays properly</li> <li>Incorrect index management</li> <li>Forgetting to copy remaining elements</li> <li>Improper comparison for stability</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#searching-algorithms_1","title":"\ud83d\udd0d Searching Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#introduction_1","title":"\ud83d\udcd8 Introduction","text":"<p>Searching algorithms are fundamental techniques for finding specific elements within data structures. Understanding these algorithms is crucial for:</p> <ul> <li>\ud83c\udfaf  Data Retrieval: Efficiently locate specific elements</li> <li>\ud83d\udcbb  Algorithm Design: Foundation for more complex algorithms</li> <li>\ud83d\udd0d  Interview Preparation: Common technical interview topic</li> <li>\ud83e\uddee  Problem Solving: Essential for many programming tasks</li> <li>\ud83d\udcca  Performance Optimization: Choose right approach for your data</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#basic-search-algorithms","title":"\ud83d\udd0d Basic Search Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#1-linear-search","title":"1\ufe0f\u20e3 Linear Search","text":"<p>A simple sequential search algorithm that checks each element until a match is found.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_6","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Works on unsorted data</li> <li>\u2705 Simple implementation</li> <li>\u2705 Minimal space requirement</li> <li>\ud83d\udd04 Time: O(n) worst/average, O(1) best</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_6","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Small datasets</li> <li>Unsorted collections</li> <li>One-time searches</li> <li>When simplicity is preferred</li> <li>Finding all occurrences <pre><code>public static &lt;T&gt; int linearSearch(T[] arr, T target, Comparator&lt;T&gt; comparator) {\n    if (arr == null || target == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    for (int i = 0; i &lt; arr.length; i++) {\n        if (comparator.compare(arr[i], target) == 0) {\n            return i;  // Element found, return index\n        }\n    }\n    return -1;  // Element not found\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_6","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Consider early termination if possible</li> <li>Use for unsorted or small datasets</li> <li>Good for finding multiple occurrences</li> <li>Consider parallel search for large datasets</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#2-binary-search","title":"2\ufe0f\u20e3 Binary Search","text":"<p>An efficient algorithm that requires sorted data and uses divide-and-conquer strategy.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_7","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Very efficient for large datasets</li> <li>\u274c Requires sorted data</li> <li>\u2705 Logarithmic time complexity</li> <li>\ud83d\udd04 Time: O(log n) worst/average, O(1) best</li> <li>\ud83d\udcbe Space: O(1) iterative, O(log n) recursive</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_7","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Large sorted datasets</li> <li>Frequent searches</li> <li>When data is already sorted</li> <li>Finding insertion points</li> <li>Range queries <pre><code>// Iterative Implementation\npublic static &lt;T&gt; int binarySearch(T[] arr, T target, Comparator&lt;T&gt; comparator) {\n    if (arr == null || target == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n\n    int left = 0;\n    int right = arr.length - 1;\n\n    while (left &lt;= right) {\n        int mid = left + (right - left) / 2;\n        int comparison = comparator.compare(arr[mid], target);\n\n        if (comparison == 0) {\n            return mid;  // Element found\n        } else if (comparison &lt; 0) {\n            left = mid + 1;  // Search right half\n        } else {\n            right = mid - 1;  // Search left half\n        }\n    }\n    return -1;  // Element not found\n}\n\n// Recursive Implementation\npublic static &lt;T&gt; int binarySearchRecursive(T[] arr, T target, \n                                          Comparator&lt;T&gt; comparator) {\n    if (arr == null || target == null || comparator == null) {\n        throw new IllegalArgumentException(\"Inputs cannot be null\");\n    }\n    return binarySearchHelper(arr, target, comparator, 0, arr.length - 1);\n}\n\nprivate static &lt;T&gt; int binarySearchHelper(T[] arr, T target, \n                                        Comparator&lt;T&gt; comparator, \n                                        int left, int right) {\n    if (left &gt; right) {\n        return -1;\n    }\n\n    int mid = left + (right - left) / 2;\n    int comparison = comparator.compare(arr[mid], target);\n\n    if (comparison == 0) {\n        return mid;\n    } else if (comparison &lt; 0) {\n        return binarySearchHelper(arr, target, comparator, mid + 1, right);\n    } else {\n        return binarySearchHelper(arr, target, comparator, left, mid - 1);\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_7","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use  <code>left + (right - left) / 2</code>  to avoid integer overflow</li> <li>Consider iterative vs recursive based on needs</li> <li>Useful for finding insertion points</li> <li>Can be modified for fuzzy searching</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_6","title":"References","text":"<p>Binary Search</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison","title":"\ud83d\udcca Algorithm Comparison","text":"Feature Linear Search Binary Search Time Complexity (Worst) O(n) O(log n) Time Complexity (Best) O(1) O(1) Space Complexity O(1) O(1) iterative, O(log n) recursive Sorted Data Required No Yes Multiple Occurrences Easy to find all Finds one occurrence Implementation Complexity Simple Moderate Cache Performance Good for small data May have cache misses"},{"location":"1.Fundamentals/c_algorithms/#implementation-best-practices","title":"\ud83d\udca1 Implementation Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Always validate input parameters</li> <li>Handle edge cases (empty arrays, null values)</li> <li>Consider return type (index vs boolean vs element)</li> <li>Use appropriate comparator functions</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_1","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Off-by-one errors in binary search</li> <li>Not checking for null values</li> <li>Assuming data is sorted for binary search</li> <li>Integer overflow in mid-point calculation</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-considerations","title":"\ud83d\udd0d Advanced Considerations","text":"<ul> <li>Duplicate elements handling</li> <li>Custom comparison logic</li> <li>Parallel search for large datasets</li> <li>Cache-friendly implementations</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#when-to-use-each","title":"\ud83c\udfaf When to Use Each","text":"<ul> <li>\ud83d\udccc  Linear Search:<ul> <li>Small datasets</li> <li>Unsorted data</li> <li>Finding all occurrences</li> <li>Simple implementation needed</li> </ul> </li> <li>\ud83d\udccc  Binary Search:<ul> <li>Large sorted datasets</li> <li>Frequent searches</li> <li>Finding insertion points</li> <li>Performance critical operations</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#graph-algorithms_1","title":"\ud83d\udd78\ufe0f Graph Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#introduction_2","title":"\ud83d\udcd8 Introduction","text":"<p>Graph algorithms are essential techniques for solving problems that involve network-like structures. Understanding these algorithms is crucial for:</p> <ul> <li>\ud83d\uddfa\ufe0f  Network Analysis: Navigate and analyze complex networks</li> <li>\ud83d\udd0d  Path Finding: Find optimal routes between nodes</li> <li>\ud83c\udf10  Web Crawling: Systematically browse and analyze web pages</li> <li>\ud83c\udfae  Game Development: Power AI and navigation systems</li> <li>\ud83d\udcf1  Social Networks: Analyze relationships and connections</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-graph-concepts","title":"\ud83d\udd11 Key Graph Concepts","text":"<ul> <li>Vertex (Node): Points in the graph</li> <li>Edge: Connections between vertices</li> <li>Path: Sequence of vertices connected by edges</li> <li>Cycle: Path that starts and ends at same vertex</li> <li>Connected Component: Group of connected vertices</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#basic-graph-traversal","title":"\ud83d\udd0d Basic Graph Traversal","text":""},{"location":"1.Fundamentals/c_algorithms/#1-breadth-first-search-bfs","title":"1\ufe0f\u20e3 Breadth First Search (BFS)","text":"<p>A traversal algorithm that explores a graph level by level.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_8","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Finds shortest path in unweighted graphs</li> <li>\u2705 Explores nodes level by level</li> <li>\u2705 Uses queue data structure</li> <li>\ud83d\udd04 Time: O(V + E)</li> <li>\ud83d\udcbe Space: O(V)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_8","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Finding shortest paths</li> <li>Level-order traversal</li> <li>Web crawling</li> <li>Network broadcasting</li> <li>Finding connected components <pre><code>public class Graph {\n    private Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    public void bfs(Vertex start) {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Start vertex cannot be null\");\n        }\n\n        Queue&lt;Vertex&gt; queue = new LinkedList&lt;&gt;();\n        Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n\n        // Start the traversal\n        queue.offer(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            Vertex current = queue.poll();\n            System.out.println(\"Visiting: \" + current.getValue());\n\n            // Process all neighbors\n            for (Vertex neighbor : adjList.get(current)) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n    }\n\n    // Version that tracks paths\n    public Map&lt;Vertex, Vertex&gt; bfsWithPaths(Vertex start) {\n        Queue&lt;Vertex&gt; queue = new LinkedList&lt;&gt;();\n        Map&lt;Vertex, Vertex&gt; parentMap = new HashMap&lt;&gt;();\n\n        queue.offer(start);\n        parentMap.put(start, null);\n\n        while (!queue.isEmpty()) {\n            Vertex current = queue.poll();\n\n            for (Vertex neighbor : adjList.get(current)) {\n                if (!parentMap.containsKey(neighbor)) {\n                    parentMap.put(neighbor, current);\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return parentMap;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_8","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use for shortest path in unweighted graphs</li> <li>Great for level-by-level exploration</li> <li>Consider space requirements for large graphs</li> <li>Can be modified to find shortest path</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_7","title":"References","text":"<p>Breadth First Search</p>"},{"location":"1.Fundamentals/c_algorithms/#2-depth-first-search-dfs","title":"2\ufe0f\u20e3 Depth First Search (DFS)","text":"<p>A traversal algorithm that explores a graph by going as deep as possible before backtracking.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_9","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Memory efficient for deep graphs</li> <li>\u2705 Natural recursive implementation</li> <li>\u2705 Can detect cycles</li> <li>\ud83d\udd04 Time: O(V + E)</li> <li>\ud83d\udcbe Space: O(V) worst case</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_9","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Topological sorting</li> <li>Cycle detection</li> <li>Maze solving</li> <li>Path finding</li> <li>Connected components</li> </ul> <pre><code>public class Graph {\n    private Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;\n\n    // Recursive DFS\n    public void dfs(Vertex start) {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Start vertex cannot be null\");\n        }\n\n        Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n        dfsHelper(start, visited);\n    }\n\n    private void dfsHelper(Vertex current, Set&lt;Vertex&gt; visited) {\n        visited.add(current);\n        System.out.println(\"Visiting: \" + current.getValue());\n\n        for (Vertex neighbor : adjList.get(current)) {\n            if (!visited.contains(neighbor)) {\n                dfsHelper(neighbor, visited);\n            }\n        }\n    }\n\n    // Iterative DFS using Stack\n    public void dfsIterative(Vertex start) {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Start vertex cannot be null\");\n        }\n\n        Stack&lt;Vertex&gt; stack = new Stack&lt;&gt;();\n        Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();\n\n        stack.push(start);\n\n        while (!stack.isEmpty()) {\n            Vertex current = stack.pop();\n\n            if (!visited.contains(current)) {\n                visited.add(current);\n                System.out.println(\"Visiting: \" + current.getValue());\n\n                // Add all unvisited neighbors to stack\n                for (Vertex neighbor : adjList.get(current)) {\n                    if (!visited.contains(neighbor)) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_9","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Choose between recursive and iterative based on graph depth</li> <li>Use for finding paths in mazes</li> <li>Efficient for deep graph structures</li> <li>Can be modified for cycle detection</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_8","title":"References","text":"<p>Depth First Search</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_1","title":"\ud83d\udcca Algorithm Comparison","text":"Feature BFS DFS Time Complexity O(V + E) O(V + E) Space Complexity O(V) O(V) Implementation Queue-based Stack/Recursive Path Finding Shortest in unweighted Any valid path Memory Usage More for wide graphs More for deep graphs Use Case Level-wise traversal Deep traversal Completeness Complete Complete"},{"location":"1.Fundamentals/c_algorithms/#implementation-best-practices_1","title":"\ud83d\udca1 Implementation Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips_1","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Always validate input parameters</li> <li>Handle disconnected components</li> <li>Consider space-time tradeoffs</li> <li>Use appropriate data structures</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_2","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Forgetting to mark nodes as visited</li> <li>Infinite loops in cyclic graphs</li> <li>Stack overflow in recursive DFS</li> <li>Not handling disconnected components</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-considerations_1","title":"\ud83d\udd0d Advanced Considerations","text":"<ul> <li>Graph representation choice</li> <li>Memory management</li> <li>Performance optimization</li> <li>Edge case handling</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#shortest-path-algorithms","title":"\ud83d\udee3\ufe0f Shortest Path Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#overview_2","title":"\ud83d\udcd8 Overview","text":"<p>Shortest path algorithms are essential for finding optimal routes between vertices in a graph. These algorithms are crucial for:</p> <ul> <li>\ud83d\uddfa\ufe0f  Navigation Systems: Finding optimal routes</li> <li>\ud83c\udf10  Network Routing: Optimizing network traffic</li> <li>\ud83d\udcb0  Financial Markets: Currency exchange optimization</li> <li>\ud83c\udfae  Game Development: Path-finding for AI</li> <li>\ud83d\udce1  Network Design: Infrastructure planning</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-path-finding-algorithms","title":"\ud83d\udd0d Advanced Path-Finding Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#1-bellman-ford-algorithm","title":"1\ufe0f\u20e3 Bellman-Ford Algorithm","text":"<p>An algorithm that finds shortest paths from a source vertex to all other vertices, even with negative edge weights.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_10","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Handles negative edge weights</li> <li>\u2705 Detects negative cycles</li> <li>\u2705 Simple implementation</li> <li>\ud83d\udd04 Time: O(VE)</li> <li>\ud83d\udcbe Space: O(V)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_10","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Graphs with negative weights</li> <li>Detecting negative cycles</li> <li>Currency exchange calculations</li> <li>Network routing protocols</li> <li>When edge weights can be negative <pre><code>public class Graph {\n    private List&lt;Edge&gt; edges;\n    private int V; // Number of vertices\n\n    public class Edge {\n        int source, destination, weight;\n\n        Edge(int source, int destination, int weight) {\n            this.source = source;\n            this.destination = destination;\n            this.weight = weight;\n        }\n    }\n\n    public int[] bellmanFord(int source) {\n        // Initialize distances\n        int[] distances = new int[V];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[source] = 0;\n\n        // Relax all edges V-1 times\n        for (int i = 0; i &lt; V - 1; i++) {\n            for (Edge edge : edges) {\n                int u = edge.source;\n                int v = edge.destination;\n                int weight = edge.weight;\n\n                if (distances[u] != Integer.MAX_VALUE &amp;&amp; \n                    distances[u] + weight &lt; distances[v]) {\n                    distances[v] = distances[u] + weight;\n                }\n            }\n        }\n\n        // Check for negative weight cycles\n        for (Edge edge : edges) {\n            int u = edge.source;\n            int v = edge.destination;\n            int weight = edge.weight;\n\n            if (distances[u] != Integer.MAX_VALUE &amp;&amp; \n                distances[u] + weight &lt; distances[v]) {\n                throw new IllegalStateException(\"Graph contains negative weight cycle\");\n            }\n        }\n\n        return distances;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_10","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use for detecting negative cycles</li> <li>Good for small to medium graphs</li> <li>Consider memory efficiency</li> <li>Handle infinity values carefully</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_9","title":"References","text":"<p>Shortest Path Algorithms (Bellman Ford &amp; Dijkstra)</p>"},{"location":"1.Fundamentals/c_algorithms/#2-dijkstras-algorithm","title":"2\ufe0f\u20e3 Dijkstra's Algorithm","text":"<p>A greedy algorithm that finds the shortest path between nodes in a graph with non-negative edge weights.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_11","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Efficient for non-negative weights</li> <li>\u2705 Finds optimal paths</li> <li>\u274c Doesn't work with negative weights</li> <li>\ud83d\udd04 Time: O(E log V) with binary heap</li> <li>\ud83d\udcbe Space: O(V)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_11","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Road navigation systems</li> <li>Network routing</li> <li>Social networks</li> <li>Games pathfinding</li> <li>Resource distribution <pre><code>public class Graph {\n    private Map&lt;Integer, List&lt;Edge&gt;&gt; adjList;\n\n    public class Edge {\n        int destination;\n        int weight;\n\n        Edge(int destination, int weight) {\n            this.destination = destination;\n            this.weight = weight;\n        }\n    }\n\n    public Map&lt;Integer, Integer&gt; dijkstra(int source) {\n        // Priority queue for vertices with their distances\n        PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;(\n            Comparator.comparingInt(node -&gt; node.distance)\n        );\n\n        // Track distances and previous nodes\n        Map&lt;Integer, Integer&gt; distances = new HashMap&lt;&gt;();\n        Map&lt;Integer, Integer&gt; previous = new HashMap&lt;&gt;();\n\n        // Initialize distances\n        for (int vertex : adjList.keySet()) {\n            distances.put(vertex, Integer.MAX_VALUE);\n        }\n        distances.put(source, 0);\n        pq.offer(new Node(source, 0));\n\n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int u = current.vertex;\n\n            // Skip if we've found a better path\n            if (current.distance &gt; distances.get(u)) {\n                continue;\n            }\n\n            // Check all neighboring vertices\n            for (Edge edge : adjList.get(u)) {\n                int v = edge.destination;\n                int newDist = distances.get(u) + edge.weight;\n\n                if (newDist &lt; distances.get(v)) {\n                    distances.put(v, newDist);\n                    previous.put(v, u);\n                    pq.offer(new Node(v, newDist));\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    private class Node {\n        int vertex;\n        int distance;\n\n        Node(int vertex, int distance) {\n            this.vertex = vertex;\n            this.distance = distance;\n        }\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_11","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use priority queue for efficiency</li> <li>Only works with non-negative weights</li> <li>Consider path reconstruction</li> <li>Can be optimized for specific use cases</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_2","title":"\ud83d\udcca Algorithm Comparison","text":"Feature Bellman-Ford Dijkstra Time Complexity O(VE) O(E log V) Space Complexity O(V) O(V) Handles Negative Weights Yes No Detects Negative Cycles Yes N/A Implementation Simple Moderate Use Case Negative weights Positive weights Performance Slower Faster Memory Usage Lower Higher ### \ud83d\udca1 Implementation Best Practices"},{"location":"1.Fundamentals/c_algorithms/#general-tips_2","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Validate input graphs and weights</li> <li>Handle unreachable vertices</li> <li>Consider path reconstruction</li> <li>Implement proper error handling</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_3","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Integer overflow in distance calculations</li> <li>Not handling disconnected components</li> <li>Improper handling of infinity values</li> <li>Forgetting to check for negative cycles</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-optimizations","title":"\ud83d\udd0d Advanced Optimizations","text":"<ul> <li>Use Fibonacci heap for better theoretical performance</li> <li>Bidirectional search for specific endpoints</li> <li>A* modifications for heuristic improvements</li> <li>Early termination for single-target searches</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_10","title":"References","text":"<p>Shortest Path Algorithms (Bellman Ford &amp; Dijkstras)</p>"},{"location":"1.Fundamentals/c_algorithms/#greedy-algorithms_1","title":"\ud83d\udcab Greedy Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#introduction_3","title":"\ud83d\udcd8 Introduction","text":"<p>Greedy algorithms make locally optimal choices at each step, aiming for a global optimum. These algorithms are essential for:</p> <ul> <li>\ud83c\udfaf  Optimization Problems: Finding best solutions efficiently</li> <li>\ud83d\udcbb  Resource Management: Allocating resources optimally</li> <li>\ud83c\udf10  Network Design: Creating efficient network structures</li> <li>\ud83d\udcca  Data Compression: Reducing data size effectively</li> <li>\ud83d\udd04  Dynamic Solutions: Solving problems step by step</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-deep-dive","title":"\ud83d\udd0d Algorithm Deep Dive","text":""},{"location":"1.Fundamentals/c_algorithms/#1-huffman-coding","title":"1\ufe0f\u20e3 Huffman Coding","text":"<p>A data compression technique that assigns variable-length codes to characters based on their frequencies.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_12","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Optimal prefix codes</li> <li>\u2705 Lossless compression</li> <li>\u2705 Variable-length encoding</li> <li>\ud83d\udd04 Time: O(n log n)</li> <li>\ud83d\udcbe Space: O(n)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#how-it-works","title":"\ud83d\udca1 How It Works","text":"<ol> <li>Frequency Analysis:<ul> <li>Count frequency of each character</li> <li>Create leaf nodes for each character</li> </ul> </li> <li>Tree Construction:<ul> <li>Create min-heap of nodes</li> <li>Repeatedly merge two lowest frequency nodes</li> <li>New node's frequency = sum of children</li> </ul> </li> <li>Code Generation:<ul> <li>Traverse tree from root to leaves</li> <li>Left edge = 0, Right edge = 1</li> <li>Path to leaf = character's code</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/c_algorithms/#example","title":"\ud83c\udfaf Example","text":"<p>For string: \"HELLO WORLD\" <pre><code>Character frequencies:\nH: 1, E: 1, L: 3, O: 2, W: 1, R: 1, D: 1, (space): 1\n\nResulting codes might be:\nL: 00\nO: 01\nH: 100\nE: 101\nW: 110\nR: 1110\nD: 1111\n(space): 1000\n</code></pre></p>"},{"location":"1.Fundamentals/c_algorithms/#key-applications","title":"\ud83d\udd11 Key Applications","text":"<ul> <li>Text file compression</li> <li>Data transmission</li> <li>Multimedia encoding</li> <li>Network protocols</li> <li>Storage optimization</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_11","title":"References","text":"<p>Huffman Coding</p>"},{"location":"1.Fundamentals/c_algorithms/#2-kruskals-algorithm","title":"2\ufe0f\u20e3 Kruskal's Algorithm","text":"<p>A minimum spanning tree algorithm that builds the tree by selecting edges in increasing order of weight.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_13","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Finds global minimum</li> <li>\u2705 Works on disconnected graphs</li> <li>\u2705 Edge-focused approach</li> <li>\ud83d\udd04 Time: O(E log E)</li> <li>\ud83d\udcbe Space: O(V)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#how-it-works_1","title":"\ud83d\udca1 How It Works","text":"<ol> <li>Sort all edges by weight</li> <li>Process edges in ascending order</li> <li>Add edge if it doesn't create cycle</li> <li>Use Union-Find data structure to detect cycles</li> </ol> <pre><code>public class KruskalMST {\n    private static class Edge implements Comparable&lt;Edge&gt; {\n        int src, dest, weight;\n\n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n\n    private static class UnionFind {\n        private final int[] parent;\n        private final int[] rank;\n\n        UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n\n            // Initialize each vertex as its own set\n            for (int i = 0; i &lt; size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        // Find with path compression\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        // Union by rank\n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX != rootY) {\n                if (rank[rootX] &lt; rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else if (rank[rootX] &gt; rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n            }\n        }\n    }\n\n    public List&lt;Edge&gt; findMST(int V, List&lt;Edge&gt; edges) {\n        List&lt;Edge&gt; mst = new ArrayList&lt;&gt;();\n        UnionFind uf = new UnionFind(V);\n\n        // Sort edges by weight\n        edges.sort(Edge::compareTo);\n\n        for (Edge edge : edges) {\n            // If including this edge doesn't create a cycle\n            if (uf.find(edge.src) != uf.find(edge.dest)) {\n                mst.add(edge);\n                uf.union(edge.src, edge.dest);\n            }\n        }\n\n        return mst;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_12","title":"\ud83d\udd11 Key Tips","text":"<ul> <li>Edge Sorting:<ul> <li>Sort edges first for optimal selection</li> <li>Consider custom comparator for complex weights</li> </ul> </li> <li>Union-Find Optimization:<ul> <li>Use path compression</li> <li>Implement union by rank</li> <li>Keep track of set sizes</li> </ul> </li> <li>Implementation Considerations:<ul> <li>Handle disconnected components</li> <li>Validate input edges</li> <li>Consider edge cases (empty graph, single vertex)</li> </ul> </li> <li>Performance Optimization:<ul> <li>Use efficient sorting algorithm</li> <li>Optimize Union-Find operations</li> <li>Consider early termination</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_12","title":"References","text":"<p>Kruskal's Algorithm Introduction Kruskal's Algorithm in 2 mins</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_3","title":"\ud83d\udcca Algorithm Comparison","text":"Feature Huffman Coding Kruskal's Algorithm Time Complexity O(n log n) O(E log E) Space Complexity O(n) O(V) Primary Use Data Compression Network Design Data Structure Priority Queue &amp; Tree Union-Find Approach Bottom-up Global Greedy Implementation Moderate Moderate Output Prefix Codes Minimum Spanning Tree"},{"location":"1.Fundamentals/c_algorithms/#best-practices","title":"\ud83d\udca1 Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips_3","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Validate input data</li> <li>Handle edge cases</li> <li>Use appropriate data structures</li> <li>Consider performance optimizations</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_4","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Not handling empty inputs</li> <li>Incorrect cycle detection</li> <li>Inefficient set operations</li> <li>Poor edge weight handling</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-greedy-algorithms","title":"\ud83c\udf0a Advanced Greedy Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#network-flow-and-spanning-tree-algorithms","title":"\ud83d\udcd8 Network Flow and Spanning Tree Algorithms","text":"<p>These algorithms solve complex network optimization problems, essential for:</p> <ul> <li>\ud83c\udf10  Network Flow: Maximizing throughput in networks</li> <li>\ud83d\udd04  Resource Allocation: Optimal distribution of resources</li> <li>\ud83c\udf33  Tree Construction: Building optimal spanning trees</li> <li>\ud83d\udcca  Network Design: Creating efficient network topologies</li> <li>\ud83d\udeb0  Flow Networks: Modeling pipeline and traffic systems</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-details","title":"\ud83d\udd0d Algorithm Details","text":""},{"location":"1.Fundamentals/c_algorithms/#1-ford-fulkerson-algorithm","title":"1\ufe0f\u20e3 Ford-Fulkerson Algorithm","text":"<p>A method for computing maximum flow in a flow network.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_14","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Finds maximum flow</li> <li>\u2705 Uses augmenting paths</li> <li>\u2705 Iterative improvement</li> <li>\ud83d\udd04 Time: O(EF) where F is max flow</li> <li>\ud83d\udcbe Space: O(V + E)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_12","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Network capacity planning</li> <li>Traffic routing</li> <li>Resource distribution</li> <li>Bipartite matching</li> <li>Pipeline optimization <pre><code>public class FordFulkerson {\n    private static class Edge {\n        int dest, capacity, flow;\n        Edge reverse;  // Reference to reverse edge\n\n        Edge(int dest, int capacity) {\n            this.dest = dest;\n            this.capacity = capacity;\n            this.flow = 0;\n        }\n\n        int remainingCapacity() {\n            return capacity - flow;\n        }\n\n        void addFlow(int amount) {\n            flow += amount;\n            reverse.flow -= amount;\n        }\n    }\n\n    private final List&lt;List&lt;Edge&gt;&gt; graph;\n    private final int V;\n\n    public FordFulkerson(int vertices) {\n        this.V = vertices;\n        this.graph = new ArrayList&lt;&gt;(V);\n        for (int i = 0; i &lt; V; i++) {\n            graph.add(new ArrayList&lt;&gt;());\n        }\n    }\n\n    public void addEdge(int from, int to, int capacity) {\n        // Create forward and reverse edges\n        Edge forward = new Edge(to, capacity);\n        Edge reverse = new Edge(from, 0);\n\n        // Link the edges\n        forward.reverse = reverse;\n        reverse.reverse = forward;\n\n        // Add edges to graph\n        graph.get(from).add(forward);\n        graph.get(to).add(reverse);\n    }\n\n    public int maxFlow(int source, int sink) {\n        int maxFlow = 0;\n\n        while (true) {\n            // Find augmenting path using BFS\n            int[] parent = new int[V];\n            Edge[] parentEdge = new Edge[V];\n            Arrays.fill(parent, -1);\n\n            Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n            queue.offer(source);\n            parent[source] = source;\n\n            while (!queue.isEmpty() &amp;&amp; parent[sink] == -1) {\n                int current = queue.poll();\n\n                for (Edge edge : graph.get(current)) {\n                    if (parent[edge.dest] == -1 &amp;&amp; edge.remainingCapacity() &gt; 0) {\n                        parent[edge.dest] = current;\n                        parentEdge[edge.dest] = edge;\n                        queue.offer(edge.dest);\n                    }\n                }\n            }\n\n            // If no augmenting path found, break\n            if (parent[sink] == -1) break;\n\n            // Find minimum residual capacity along the path\n            int bottleneck = Integer.MAX_VALUE;\n            for (int v = sink; v != source; v = parent[v]) {\n                bottleneck = Math.min(bottleneck, parentEdge[v].remainingCapacity());\n            }\n\n            // Update flow along the path\n            for (int v = sink; v != source; v = parent[v]) {\n                parentEdge[v].addFlow(bottleneck);\n            }\n\n            maxFlow += bottleneck;\n        }\n\n        return maxFlow;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_13","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Implement residual graph carefully</li> <li>Use BFS for finding augmenting paths</li> <li>Track reverse edges</li> <li>Handle bottleneck calculations properly</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_13","title":"References","text":"<p>Ford-Fulkerson Algorithm Ford-Fulkerson Algorithm</p>"},{"location":"1.Fundamentals/c_algorithms/#2-prims-algorithm","title":"2\ufe0f\u20e3 Prim's Algorithm","text":"<p>A greedy approach for finding minimum spanning tree, growing from a single vertex.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_15","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Optimal solution</li> <li>\u2705 Local optimization</li> <li>\u2705 Vertex-based approach</li> <li>\ud83d\udd04 Time: O(E log V)</li> <li>\ud83d\udcbe Space: O(V)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_13","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Network design</li> <li>Cluster analysis</li> <li>Circuit design</li> <li>Cost minimization</li> <li>Network optimization <pre><code>public class PrimMST {\n    private static class Edge {\n        int dest, weight;\n\n        Edge(int dest, int weight) {\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n\n    private static class Vertex implements Comparable&lt;Vertex&gt; {\n        int id, key;\n\n        Vertex(int id, int key) {\n            this.id = id;\n            this.key = key;\n        }\n\n        @Override\n        public int compareTo(Vertex other) {\n            return Integer.compare(this.key, other.key);\n        }\n    }\n\n    public List&lt;Edge&gt; findMST(List&lt;List&lt;Edge&gt;&gt; graph) {\n        int V = graph.size();\n        List&lt;Edge&gt; mst = new ArrayList&lt;&gt;();\n\n        // Priority queue for selecting minimum weight edge\n        PriorityQueue&lt;Vertex&gt; pq = new PriorityQueue&lt;&gt;();\n        int[] key = new int[V];\n        int[] parent = new int[V];\n        boolean[] inMST = new boolean[V];\n\n        // Initialize keys and parent\n        Arrays.fill(key, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n\n        // Start with vertex 0\n        key[0] = 0;\n        pq.offer(new Vertex(0, 0));\n\n        while (!pq.isEmpty()) {\n            int u = pq.poll().id;\n\n            // Skip if already processed\n            if (inMST[u]) continue;\n\n            inMST[u] = true;\n\n            // Add edge to MST if not root\n            if (parent[u] != -1) {\n                mst.add(new Edge(u, key[u]));\n            }\n\n            // Update keys of adjacent vertices\n            for (Edge edge : graph.get(u)) {\n                int v = edge.dest;\n                if (!inMST[v] &amp;&amp; edge.weight &lt; key[v]) {\n                    key[v] = edge.weight;\n                    parent[v] = u;\n                    pq.offer(new Vertex(v, key[v]));\n                }\n            }\n        }\n\n        return mst;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_14","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Use priority queue for efficiency</li> <li>Maintain key values properly</li> <li>Handle disconnected components</li> <li>Consider dense vs sparse graphs</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_14","title":"References","text":"<p>Prim's Algorithm Prim's MST Algorithm</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_4","title":"\ud83d\udcca Algorithm Comparison","text":"Feature Ford-Fulkerson Prim's Algorithm Time Complexity O(EF) O(E log V) Space Complexity O(V + E) O(V) Primary Use Max Flow Minimum Spanning Tree Data Structure Residual Graph Priority Queue Approach Iterative Improvement Greedy Growth Graph Type Directed Undirected Key Feature Augmenting Paths Local Optimization"},{"location":"1.Fundamentals/c_algorithms/#implementation-best-practices_2","title":"\ud83d\udca1 Implementation Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips_4","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Validate input graphs</li> <li>Handle edge cases</li> <li>Use efficient data structures</li> <li>Consider performance optimizations</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_5","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Incorrect flow updates</li> <li>Memory management issues</li> <li>Infinite loops</li> <li>Edge weight handling</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#substring-search-algorithms-guide","title":"\ud83d\udd0d Substring Search Algorithms Guide","text":""},{"location":"1.Fundamentals/c_algorithms/#introduction_4","title":"\ud83d\udcd8 Introduction","text":"<p>Substring search algorithms are fundamental techniques for finding pattern matches within text. These algorithms are essential for:</p> <ul> <li>\ud83d\udcdd  Text Processing: Finding words or patterns in documents</li> <li>\ud83d\udd0e  Search Engines: Locating specific content</li> <li>\ud83e\uddec  DNA Sequence Analysis: Finding genetic patterns</li> <li>\ud83d\udcda  Plagiarism Detection: Identifying text matches</li> <li>\ud83d\udd04  Data Validation: Pattern matching in strings</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#basic-search-algorithms_1","title":"\ud83d\udd0d Basic Search Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#1-brute-force-search","title":"1\ufe0f\u20e3 Brute Force Search","text":"<p>A straightforward approach that checks every possible position in the text.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_16","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Simple implementation</li> <li>\u2705 No preprocessing required</li> <li>\u2705 Works with any pattern</li> <li>\ud83d\udd04 Time: O(mn)</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_14","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Short patterns</li> <li>Short texts</li> <li>Simple implementations</li> <li>When preprocessing overhead isn't worth it</li> <li>When pattern varies frequently <pre><code>public static List&lt;Integer&gt; bruteForce(CharSequence pattern, CharSequence text,\n                                     CharacterComparator comparator) {\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern cannot be null or empty\");\n    }\n    if (text == null || comparator == null) {\n        throw new IllegalArgumentException(\"Text and comparator cannot be null\");\n    }\n\n    List&lt;Integer&gt; matches = new ArrayList&lt;&gt;();\n    int n = text.length();\n    int m = pattern.length();\n\n    // Check each possible position in text\n    for (int i = 0; i &lt;= n - m; i++) {\n        boolean found = true;\n        // Check pattern match starting at position i\n        for (int j = 0; j &lt; m; j++) {\n            if (comparator.compare(pattern.charAt(j), \n                                 text.charAt(i + j)) != 0) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            matches.add(i);\n        }\n    }\n    return matches;\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_15","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Early termination on mismatch</li> <li>Handle edge cases properly</li> <li>Consider text/pattern lengths</li> <li>Validate inputs carefully</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#2-rabin-karp-algorithm","title":"2\ufe0f\u20e3 Rabin-Karp Algorithm","text":"<p>Uses hashing to find exact pattern matches in text.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_17","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Efficient for multiple patterns</li> <li>\u2705 Rolling hash function</li> <li>\u2705 Good average case</li> <li>\ud83d\udd04 Time: Average O(n+m), Worst O(mn)</li> <li>\ud83d\udcbe Space: O(1)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_15","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Multiple pattern matching</li> <li>Long texts</li> <li>Pattern finding in streams</li> <li>Plagiarism detection</li> <li>When preprocessing pattern is beneficial <pre><code>public static List&lt;Integer&gt; rabinKarp(CharSequence pattern, CharSequence text,\n                                    CharacterComparator comparator) {\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern cannot be null or empty\");\n    }\n    if (text == null || comparator == null) {\n        throw new IllegalArgumentException(\"Text and comparator cannot be null\");\n    }\n\n    List&lt;Integer&gt; matches = new ArrayList&lt;&gt;();\n    int m = pattern.length();\n    int n = text.length();\n\n    if (m &gt; n) return matches;\n\n    // Calculate pattern hash and first window hash\n    int base = 113;  // Prime base\n    int patternHash = 0;\n    int windowHash = 0;\n    int highestPow = 1;\n\n    // Calculate highest power of base needed\n    for (int i = 0; i &lt; m - 1; i++) {\n        highestPow = highestPow * base;\n    }\n\n    // Calculate initial hashes\n    for (int i = 0; i &lt; m; i++) {\n        patternHash = patternHash * base + pattern.charAt(i);\n        windowHash = windowHash * base + text.charAt(i);\n    }\n\n    // Slide window and check matches\n    for (int i = 0; i &lt;= n - m; i++) {\n        if (patternHash == windowHash) {\n            // Verify character by character\n            boolean match = true;\n            for (int j = 0; j &lt; m; j++) {\n                if (comparator.compare(pattern.charAt(j), \n                                     text.charAt(i + j)) != 0) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                matches.add(i);\n            }\n        }\n\n        // Calculate hash for next window\n        if (i &lt; n - m) {\n            windowHash = (windowHash - text.charAt(i) * highestPow) * base\n                        + text.charAt(i + m);\n        }\n    }\n\n    return matches;\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_16","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Choose appropriate hash function</li> <li>Handle hash collisions</li> <li>Use efficient rolling hash</li> <li>Consider modulo operations for large texts</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_15","title":"References","text":"<p>Rabin Karp Algorithm</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_5","title":"\ud83d\udcca Algorithm Comparison","text":"Feature Brute Force Rabin-Karp Time Complexity (Worst) O(mn) O(mn) Time Complexity (Average) O(mn) O(n+m) Space Complexity O(1) O(1) Preprocessing No Yes Multiple Patterns Inefficient Efficient Implementation Simple Moderate Best Case O(n) O(n+m) Hash Function N/A Yes"},{"location":"1.Fundamentals/c_algorithms/#implementation-best-practices_3","title":"\ud83d\udca1 Implementation Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips_5","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Validate input parameters</li> <li>Handle edge cases</li> <li>Consider pattern/text lengths</li> <li>Use appropriate data structures</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_6","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Integer overflow in hash calculation</li> <li>Not handling collisions</li> <li>Inefficient hash updates</li> <li>Missing edge cases</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-substring-search-algorithms","title":"\ud83d\udd0d Advanced Substring Search Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#overview_3","title":"\ud83d\udcd8 Overview","text":"<p>These advanced substring search algorithms use preprocessing for more efficient pattern matching. They are crucial for:</p> <ul> <li>\ud83d\ude80  High Performance Search: Fast pattern matching</li> <li>\ud83d\udcca  Big Data Analysis: Processing large text efficiently</li> <li>\ud83d\udd04  Real-time Matching: Stream processing</li> <li>\ud83d\udcdd  Text Editors: Efficient find/replace operations</li> <li>\ud83e\uddec  Bioinformatics: DNA sequence matching</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#advanced-algorithms","title":"\ud83d\udd0d Advanced Algorithms","text":""},{"location":"1.Fundamentals/c_algorithms/#1-knuth-morris-pratt-kmp","title":"1\ufe0f\u20e3 Knuth-Morris-Pratt (KMP)","text":"<p>An efficient pattern matching algorithm that utilizes a failure table to avoid unnecessary comparisons.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_18","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Linear time complexity</li> <li>\u2705 Preprocesses pattern</li> <li>\u2705 No backward movement in text</li> <li>\ud83d\udd04 Time: O(n + m)</li> <li>\ud83d\udcbe Space: O(m)</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_16","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Long patterns</li> <li>Repetitive patterns</li> <li>Streaming data</li> <li>Real-time matching</li> <li>When text cannot be buffered <pre><code>public static List&lt;Integer&gt; kmp(CharSequence pattern, CharSequence text,\n                              CharacterComparator comparator) {\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern cannot be null or empty\");\n    }\n    if (text == null || comparator == null) {\n        throw new IllegalArgumentException(\"Text and comparator cannot be null\");\n    }\n\n    List&lt;Integer&gt; matches = new ArrayList&lt;&gt;();\n    if (pattern.length() &gt; text.length()) {\n        return matches;\n    }\n\n    // Build failure table\n    int[] failureTable = buildFailureTable(pattern, comparator);\n\n    int i = 0;  // text index\n    int j = 0;  // pattern index\n\n    while (i &lt;= text.length() - pattern.length()) {\n        while (j &lt; pattern.length() &amp;&amp; \n               comparator.compare(text.charAt(i + j), pattern.charAt(j)) == 0) {\n            j++;\n        }\n\n        if (j == 0) {\n            i++;\n        } else {\n            if (j == pattern.length()) {\n                matches.add(i);\n            }\n            int nextAlignment = failureTable[j - 1];\n            i = i + j - nextAlignment;\n            j = nextAlignment;\n        }\n    }\n    return matches;\n}\n\npublic static int[] buildFailureTable(CharSequence pattern, \n                                    CharacterComparator comparator) {\n    int[] failureTable = new int[pattern.length()];\n\n    int i = 0;\n    int j = 1;\n    failureTable[0] = 0;\n\n    while (j &lt; pattern.length()) {\n        if (comparator.compare(pattern.charAt(i), pattern.charAt(j)) == 0) {\n            failureTable[j] = i + 1;\n            i++;\n            j++;\n        } else {\n            if (i == 0) {\n                failureTable[j] = 0;\n                j++;\n            } else {\n                i = failureTable[i - 1];\n            }\n        }\n    }\n\n    return failureTable;\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_17","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Build failure table efficiently</li> <li>Handle pattern prefixes</li> <li>Avoid backing up in text</li> <li>Consider pattern preprocessing time</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_16","title":"References","text":"<p>Knuth-Morris-Pratt Algorithm</p>"},{"location":"1.Fundamentals/c_algorithms/#2-boyer-moore-algorithm","title":"2\ufe0f\u20e3 Boyer-Moore Algorithm","text":"<p>A pattern matching algorithm that uses two heuristics: bad character and good suffix rules.</p>"},{"location":"1.Fundamentals/c_algorithms/#properties_19","title":"\ud83d\udcca Properties","text":"<ul> <li>\u2705 Sublinear time in practice</li> <li>\u2705 Two preprocessing tables</li> <li>\u2705 Right-to-left scanning</li> <li>\ud83d\udd04 Time: O(n/m) best, O(mn) worst</li> <li>\ud83d\udcbe Space: O(k) where k is alphabet size</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#best-used-for_17","title":"\ud83d\udca1 Best Used For:","text":"<ul> <li>Long patterns</li> <li>Large alphabets</li> <li>Natural language text</li> <li>When pattern is rare in text</li> <li>When preprocessing time is acceptable <pre><code>public static List&lt;Integer&gt; boyerMoore(CharSequence pattern, CharSequence text,\n                                     CharacterComparator comparator) {\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Pattern cannot be null or empty\");\n    }\n    if (text == null || comparator == null) {\n        throw new IllegalArgumentException(\"Text and comparator cannot be null\");\n    }\n\n    List&lt;Integer&gt; matches = new ArrayList&lt;&gt;();\n    if (pattern.length() &gt; text.length()) {\n        return matches;\n    }\n\n    // Build last occurrence table\n    Map&lt;Character, Integer&gt; lastTable = buildLastTable(pattern);\n\n    int i = 0;\n    while (i &lt;= text.length() - pattern.length()) {\n        int j = pattern.length() - 1;\n\n        // Match pattern from right to left\n        while (j &gt;= 0 &amp;&amp; \n               comparator.compare(pattern.charAt(j), text.charAt(i + j)) == 0) {\n            j--;\n        }\n\n        if (j == -1) {\n            matches.add(i);\n            i++;\n        } else {\n            // Get last occurrence of mismatched character\n            char mismatchChar = text.charAt(i + j);\n            int lastOccurrence = lastTable.getOrDefault(mismatchChar, -1);\n\n            // Calculate shift\n            if (lastOccurrence &lt; j) {\n                i += j - lastOccurrence;\n            } else {\n                i++;\n            }\n        }\n    }\n    return matches;\n}\n\npublic static Map&lt;Character, Integer&gt; buildLastTable(CharSequence pattern) {\n    Map&lt;Character, Integer&gt; lastTable = new HashMap&lt;&gt;();\n\n    // Record last occurrence of each character in pattern\n    for (int i = 0; i &lt; pattern.length(); i++) {\n        lastTable.put(pattern.charAt(i), i);\n    }\n\n    return lastTable;\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#key-tips_18","title":"\ud83d\udd11 Key Tips:","text":"<ul> <li>Implement both heuristics correctly</li> <li>Handle character set efficiently</li> <li>Consider preprocessing overhead</li> <li>Use appropriate shift calculations</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#references_17","title":"References","text":"<p>Boyer-Moore Algorithm</p>"},{"location":"1.Fundamentals/c_algorithms/#algorithm-comparison_6","title":"\ud83d\udcca Algorithm Comparison","text":"Feature KMP Boyer-Moore Time Complexity (Worst) O(n + m) O(mn) Time Complexity (Average) O(n + m) O(n/m) Space Complexity O(m) O(k) Pattern Scan Direction Left to Right Right to Left Preprocessing Failure Table Last Occurrence Table Best Case O(n) O(n/m) Text Scan Direction Forward Only Can Skip Characters Implementation Moderate Complex"},{"location":"1.Fundamentals/c_algorithms/#implementation-best-practices_4","title":"\ud83d\udca1 Implementation Best Practices","text":""},{"location":"1.Fundamentals/c_algorithms/#general-tips_6","title":"\ud83c\udfaf General Tips","text":"<ul> <li>Use efficient preprocessing</li> <li>Handle border cases</li> <li>Consider alphabet size</li> <li>Choose algorithm based on pattern characteristics</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#common-pitfalls_7","title":"\u26a0\ufe0f Common Pitfalls","text":"<ul> <li>Incorrect preprocessing tables</li> <li>Inefficient character comparisons</li> <li>Wrong shift calculations</li> <li>Missing edge cases</li> </ul>"},{"location":"1.Fundamentals/c_algorithms/#final-reference-to-algorithm-notes","title":"Final Reference to Algorithm Notes","text":"<p>CS 1332 Data Structures and Algorithms</p>"},{"location":"1.Fundamentals/d_python/","title":"Python Programming Language","text":""},{"location":"1.Fundamentals/d_python/#1-introduction-to-python","title":"1. Introduction to Python","text":"<p>Python stands as one of the most influential programming languages in modern software development. Created by Guido van Rossum and first released in 1991, Python embodies a philosophy that emphasizes code readability and simplicity, captured in \"The Zen of Python\" - a collection of guiding principles that shape the language's design and usage.</p>"},{"location":"1.Fundamentals/d_python/#historical-background","title":"Historical Background","text":"<p>The journey of Python began in the late 1980s at the Centrum Wiskunde &amp; Informatica (CWI) in the Netherlands. Van Rossum envisioned a successor to the ABC programming language that would emphasize code readability while maintaining powerful programming capabilities. He chose the name \"Python\" inspired by the British comedy series \"Monty Python's Flying Circus,\" setting the tone for a community that often embraces both serious programming and playful creativity.</p> <p>The language evolved through several significant versions:</p> <p>Python 1.0 (1994) introduced functional programming tools like  <code>lambda</code>,  <code>map</code>,  <code>filter</code>, and  <code>reduce</code>.</p> <p>Python 2.0 (2000) brought list comprehensions and garbage collection, marking Python's maturation into a fully-featured programming language.</p> <p>Python 3.0 (2008) represented a major reformation of the language, breaking backward compatibility to address fundamental design flaws and modernize Python's infrastructure. While this transition took nearly a decade to complete, it demonstrated the community's commitment to maintaining Python's relevance and technical excellence.</p>"},{"location":"1.Fundamentals/d_python/#core-philosophy","title":"Core Philosophy","text":"<p>Python's design philosophy emphasizes:</p> <ol> <li>Readability Matters: Python uses significant whitespace and clear, explicit syntax that makes code structure visible and intuitive. This design choice encourages developers to write organized, maintainable code.</li> <li>Simplicity Over Complexity: The language favors straightforward solutions over complicated ones. As stated in The Zen of Python: \"Simple is better than complex. Complex is better than complicated.\"</li> <li>Batteries Included: Python comes with a comprehensive standard library, providing tools for diverse programming tasks without requiring additional installations.</li> <li>Duck Typing: Python employs dynamic typing where the type or class of an object is less important than the methods it defines. This flexibility allows for more generic and reusable code.</li> </ol>"},{"location":"1.Fundamentals/d_python/#modern-relevance","title":"Modern Relevance","text":"<p>Today, Python has established itself as a versatile language used across various domains:</p> <ul> <li>Data Science and Machine Learning: Libraries like NumPy, Pandas, and TensorFlow have made Python the de facto language for data analysis and artificial intelligence.</li> <li>Web Development: Frameworks such as Django and Flask enable rapid development of web applications.</li> <li>Automation and Scripting: Python's simplicity makes it ideal for system administration and process automation.</li> <li>Education: The language's readable syntax and gentle learning curve make it an excellent choice for teaching programming concepts.</li> </ul>"},{"location":"1.Fundamentals/d_python/#technical-foundation","title":"Technical Foundation","text":"<p>Python is an interpreted, high-level programming language that supports multiple programming paradigms:</p> <ul> <li>Object-Oriented Programming: Everything in Python is an object, allowing for clean and modular code organization.</li> <li>Functional Programming: Support for functions as first-class objects enables functional programming patterns.</li> <li>Procedural Programming: Traditional structured programming approaches are fully supported.</li> </ul> <p>The language features automatic memory management through garbage collection, dynamic typing, and a rich ecosystem of third-party packages available through the Python Package Index (PyPI).</p> <p>In the following sections, we'll explore Python's fundamental concepts, syntax, and best practices, providing a comprehensive guide for both newcomers and experienced developers seeking to deepen their Python expertise.</p> <p>Reference: https://roadmap.sh/python</p>"},{"location":"1.Fundamentals/d_python/#2-python-syntax-guide","title":"2. Python Syntax Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction","title":"Introduction","text":"<p>Python's syntax is designed with readability and simplicity in mind, setting it apart from other programming languages through its use of significant whitespace and clear, expressive constructs. This guide will explore the fundamental syntax rules that govern how we write Python code.</p>"},{"location":"1.Fundamentals/d_python/#code-structure-and-execution-modes","title":"Code Structure and Execution Modes","text":"<p>Python offers two primary modes of execution, each serving different purposes in development:</p>"},{"location":"1.Fundamentals/d_python/#interactive-mode-repl","title":"Interactive Mode (REPL)","text":"<p>The Interactive Mode, also known as REPL (Read-Eval-Print Loop), provides an immediate feedback loop for testing code snippets: <pre><code>$ python3\n&gt;&gt;&gt; print(\"Hello, World!\")\nHello, World!\n</code></pre> This mode is particularly valuable for:</p> <ul> <li>Quick experimentation with Python expressions</li> <li>Testing small code snippets</li> <li>Learning and exploring Python features</li> <li>Debugging and troubleshooting</li> </ul>"},{"location":"1.Fundamentals/d_python/#script-mode","title":"Script Mode","text":"<p>Script Mode allows you to write and execute complete Python programs stored in files with the <code>.py</code> extension: <pre><code># hello.py\n#!/usr/bin/python3\nprint(\"Hello, World!\")\n</code></pre> To execute a script, you can use either: <pre><code>$ python3 hello.py\n# or after making the file executable\n$ chmod +x hello.py\n$ ./hello.py\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#language-fundamentals","title":"Language Fundamentals","text":""},{"location":"1.Fundamentals/d_python/#identifiers-and-naming-conventions","title":"Identifiers and Naming Conventions","text":"<p>Python identifiers follow specific rules that maintain code clarity and consistency: <pre><code># Valid identifier examples\nstudent_name    # Snake case for variables and functions\nClassName       # Pascal case for classes\n_private        # Single underscore prefix for private attributes\n__very_private  # Double underscore prefix for name mangling\n</code></pre> The naming system in Python is carefully designed to convey meaning through convention:</p> <ul> <li>Variables and functions use lowercase with underscores (snake_case)</li> <li>Classes use capitalized words (PascalCase)</li> <li>Constants are typically uppercase with underscores (MAX_VALUE)</li> <li>Protected attributes start with a single underscore</li> <li>Private attributes start with double underscores</li> </ul>"},{"location":"1.Fundamentals/d_python/#indentation-and-block-structure","title":"Indentation and Block Structure","text":"<p>Unlike many programming languages that use braces <code>{}</code>, Python uses indentation to define code blocks. This enforces clean, readable code structure: <pre><code>def calculate_grade(score):\n    if score &gt;= 90:\n        return \"A\"\n    elif score &gt;= 80:\n        return \"B\"\n    else:\n        return \"C\"\n</code></pre> The indentation level visually represents the code's logical structure. While the number of spaces can vary (typically 4 spaces), consistency within a project is crucial.</p>"},{"location":"1.Fundamentals/d_python/#multi-line-statements","title":"Multi-line Statements","text":"<p>Python provides several ways to handle long statements: <pre><code># Using the line continuation character (\\)\ntotal = first_number + \\\n        second_number + \\\n        third_number\n\n# Implicit line continuation within parentheses\ncoordinates = (x_position,\n               y_position,\n               z_position)\n\n# List spanning multiple lines\ndays = ['Monday', 'Tuesday',\n        'Wednesday', 'Thursday',\n        'Friday']\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#string-literals-and-quotation","title":"String Literals and Quotation","text":"<p>Python offers flexible string notation to accommodate different needs: <pre><code>single_quote = 'Simple string'\ndouble_quote = \"String with 'internal' quotes\"\ntriple_quote = '''Multi-line\nstring that preserves\nformatting'''\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#comments-and-documentation","title":"Comments and Documentation","text":"<p>Comments in Python serve as crucial documentation tools: <pre><code># Single-line comment\n\n\"\"\"\nMulti-line comment or docstring\nUsed for function and class documentation\nCan span multiple lines\n\"\"\"\n\ndef calculate_average(numbers):\n    \"\"\"\n    Calculate the average of a list of numbers.\n\n    Args:\n        numbers (list): A list of numeric values\n\n    Returns:\n        float: The average of the input numbers\n    \"\"\"\n    return sum(numbers) / len(numbers)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#statement-groups-and-suites","title":"Statement Groups and Suites","text":"<p>Complex statements in Python follow a consistent pattern: <pre><code># Basic structure of compound statements\nif condition:\n    suite_of_statements\nelif another_condition:\n    another_suite\nelse:\n    final_suite\n\n# Function definition example\ndef process_data(data):\n    # Suite of statements\n    cleaned_data = clean(data)\n    analyzed_data = analyze(cleaned_data)\n    return analyzed_data\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices","title":"Best Practices","text":"<ol> <li>Always maintain consistent indentation (4 spaces is the standard)</li> <li>Use clear, descriptive names for variables and functions</li> <li>Keep lines reasonably short (PEP 8 suggests 79 characters)</li> <li>Include docstrings for functions, classes, and modules</li> <li>Use comments to explain complex logic, not obvious code</li> </ol>"},{"location":"1.Fundamentals/d_python/#3-python-variables-a-complete-guide","title":"3. Python Variables: A Complete Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_1","title":"Introduction","text":"<p>Variables are foundational to Python programming - they allow us to store, track, and manipulate data throughout our code. At their core, variables act as labels or names that reference values stored in a computer's memory. Understanding how variables work is essential for writing effective Python programs.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts","title":"Core Concepts","text":""},{"location":"1.Fundamentals/d_python/#references-vs-values","title":"References vs Values","text":"<p>One of Python's distinguishing features is that variables don't directly store values - instead, they hold references (pointers) to objects in memory. For example: <pre><code>x = 42  # Creates an integer object with value 42 and makes x reference it\ny = x   # y now references the same object as x\n</code></pre> This reference model has important implications:</p> <ol> <li>Multiple variables can reference the same object: <pre><code>x = [1, 2, 3]\ny = x  # Both x and y point to the same list\ny.append(4)  # Modifies the list that both variables reference\nprint(x)  # Output: [1, 2, 3, 4]\n</code></pre> </li> <li>Reassignment makes variables reference new objects: <pre><code>x = 10\ny = x\nx = 20  # x now references a new integer object\nprint(y)  # Still outputs 10\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#dynamic-typing","title":"Dynamic Typing","text":"<p>Python uses dynamic typing, meaning variables can reference different types of objects throughout their lifetime: <pre><code>age = 25        # age references an integer\nage = \"twenty\"  # Now age references a string\nage = True      # Now age references a boolean\n</code></pre></p> <p>This flexibility can be powerful but requires careful handling to prevent type-related bugs: <pre><code>def process_payment(amount):\n    # Good practice: validate type early\n    if not isinstance(amount, (int, float)):\n        raise TypeError(\"Payment amount must be a number\")\n    return amount * 1.2  # Add 20% service fee\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#variable-creation-and-assignment","title":"Variable Creation and Assignment","text":""},{"location":"1.Fundamentals/d_python/#standard-assignment","title":"Standard Assignment","text":"<p>The most common way to create variables is through direct assignment: <pre><code>name = \"Alice\"\nage = 30\nscores = [95, 87, 92]\n</code></pre> </p>"},{"location":"1.Fundamentals/d_python/#multiple-assignment-patterns","title":"Multiple Assignment Patterns","text":"<p>Python offers several elegant ways to assign multiple variables:</p> <ol> <li>Parallel assignment: <pre><code>x, y, z = 1, 2, 3  # Each variable gets corresponding value\n</code></pre></li> <li>Sequence unpacking: <pre><code># Unpack a sequence into individual variables\nfirst, *rest, last = [1, 2, 3, 4, 5]\nprint(first)  # 1\nprint(rest)   # [2, 3, 4]\nprint(last)   # 5\n</code></pre></li> <li>Augmented assignment: <pre><code>count = 0\ncount += 1  # Increment with augmented assignment\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#variable-scope-and-lifetime","title":"Variable Scope and Lifetime","text":""},{"location":"1.Fundamentals/d_python/#scope-rules","title":"Scope Rules","text":"<p>Python uses the LEGB rule for variable scope resolution:</p> <ol> <li>Local (L): Variables defined within the current function</li> <li>Enclosing (E): Variables in any enclosing functions</li> <li>Global (G): Variables at the module level</li> <li>Built-in (B): Python's built-in names</li> </ol> <p>Here's a comprehensive example: <pre><code>global_var = \"I'm global\"  # Global scope\n\ndef outer_function():\n    enclosing_var = \"I'm from outer\"  # Enclosing scope\n\n    def inner_function():\n        local_var = \"I'm local\"  # Local scope\n        print(local_var)        # Accesses local\n        print(enclosing_var)    # Accesses enclosing\n        print(global_var)       # Accesses global\n\n    inner_function()\n\nouter_function()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#modifying-variables-in-different-scopes","title":"Modifying Variables in Different Scopes","text":"<p>To modify variables in outer scopes, Python requires explicit declarations: <pre><code>counter = 0  # Global variable\n\ndef update_counter():\n    global counter  # Declare intention to modify global\n    counter += 1\n\ndef outer():\n    total = 0  # Enclosing scope variable\n\n    def inner():\n        nonlocal total  # Declare intention to modify enclosing\n        total += 1\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-variable-usage","title":"Best Practices for Variable Usage","text":""},{"location":"1.Fundamentals/d_python/#naming-conventions","title":"Naming Conventions","text":"<p>Following PEP 8 guidelines for variable names improves code readability:</p> <ol> <li>Use snake_case for variable names: <pre><code>user_name = \"Alice\"\ntotal_count = 42\n</code></pre></li> <li>Choose descriptive names that reveal intent: <pre><code># Less clear\nn = 0\nlst = []\n\n# More clear\ncount = 0\nactive_users = []\n</code></pre></li> <li>Use prefix 'is_' or 'has_' for boolean variables: <pre><code>is_valid = True\nhas_permission = False\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#type-hints","title":"Type Hints","text":"<p>Modern Python supports optional type hints to make code more maintainable: <pre><code>from typing import List, Dict\n\ndef process_scores(scores: List[int]) -&gt; float:\n    \"\"\"Calculate average score.\"\"\"\n    return sum(scores) / len(scores)\n\nuser_data: Dict[str, str] = {\n    \"name\": \"Alice\",\n    \"email\": \"alice@example.com\"\n}\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#memory-management","title":"Memory Management","text":"<p>Python handles memory management automatically through reference counting and garbage collection: <pre><code>def demo_memory():\n    # Create some objects\n    x = [1, 2, 3]\n    y = x\n\n    # Delete reference\n    del x\n    # List still exists because y references it\n    print(y)  # [1, 2, 3]\n\n    # When y goes out of scope, the list will be garbage collected\n</code></pre> Understanding these concepts helps write more efficient and bug-free code while letting Python handle the low-level details of memory management.</p>"},{"location":"1.Fundamentals/d_python/#4-python-conditional-statements-guide","title":"4. Python Conditional Statements Guide","text":""},{"location":"1.Fundamentals/d_python/#understanding-control-flow-with-if-statements","title":"Understanding Control Flow with <code>if</code> Statements","text":"<p>Control flow is a fundamental concept in programming that determines how a program executes based on different conditions and choices. Python's <code>if</code> statement serves as the primary mechanism for implementing conditional logic, allowing programs to make decisions and adapt their behavior dynamically.</p>"},{"location":"1.Fundamentals/d_python/#basic-syntax-and-structure","title":"Basic Syntax and Structure","text":"<p>The foundational form of an <code>if</code> statement follows this pattern: <pre><code>if condition:\n    # Code to execute if condition is True\n    statement_1\n    statement_2\n</code></pre> Let's explore how this works with a practical example: <pre><code>temperature = 25\n\nif temperature &gt; 20:\n    print(\"It's a warm day\")\n    print(\"Remember to stay hydrated\")\n</code></pre> The condition <code>temperature &gt; 20</code> is evaluated first. Since 25 is indeed greater than 20, both print statements within the indented block will execute. This demonstrates Python's use of significant whitespace \u2013 the indentation isn't just for readability; it defines the scope of the conditional block.</p>"},{"location":"1.Fundamentals/d_python/#compound-conditions-with-elif-and-else","title":"Compound Conditions with <code>elif</code> and <code>else</code>","text":"<p>Real-world decisions often involve multiple conditions. Python provides <code>elif</code> (else if) and <code>else</code> clauses to handle these scenarios: <pre><code>def check_temperature(temp):\n    if temp &gt; 30:\n        print(\"It's hot - consider staying indoors\")\n    elif temp &gt; 20:\n        print(\"It's pleasantly warm\")\n    elif temp &gt; 10:\n        print(\"It's cool - bring a jacket\")\n    else:\n        print(\"It's cold - dress warmly\")\n</code></pre>  This structure creates a decision tree where:</p> <ol> <li>Conditions are evaluated from top to bottom</li> <li>Only one block executes, even if multiple conditions are true</li> <li>The  <code>else</code>  block serves as a catch-all for when no conditions are met</li> </ol>"},{"location":"1.Fundamentals/d_python/#the-significance-of-indentation","title":"The Significance of Indentation","text":"<p>Python uses indentation to define code blocks, which is a departure from languages that use braces or keywords. For example: <pre><code>score = 85\n\nif score &gt;= 90:\n    print(\"Grade: A\")\n    print(\"Excellent work!\")\nelif score &gt;= 80:\n    print(\"Grade: B\")\n    print(\"Good job!\")    # These statements are part of the elif block\n    print(\"Keep it up!\")  # because they share the same indentation\nprint(\"End of grading\")   # This will always execute (no indentation)\n</code></pre> The indentation:</p> <ul> <li>Makes code structure visually clear</li> <li>Enforces consistent formatting</li> <li>Reduces the likelihood of scope-related errors</li> <li>Eliminates the need for explicit block delimiters</li> </ul>"},{"location":"1.Fundamentals/d_python/#conditional-expressions-ternary-operator","title":"Conditional Expressions (Ternary Operator)","text":"<p>Python offers a concise way to write simple if-else conditions in a single line: <pre><code>def get_status(age):\n    status = \"adult\" if age &gt;= 18 else \"minor\"\n    return status\n\n# More complex example\nmessage = (\n    \"high priority\" if urgency &gt; 9\n    else \"medium priority\" if urgency &gt; 5\n    else \"low priority\"\n)\n</code></pre> This syntax is particularly useful when:</p> <ul> <li>The condition is simple</li> <li>You're assigning one of two values to a variable</li> <li>You want to make the code more concise without sacrificing readability</li> </ul>"},{"location":"1.Fundamentals/d_python/#best-practices-for-conditional-logic","title":"Best Practices for Conditional Logic","text":"<ol> <li>Clarity First: Make conditions readable and explicit <pre><code># Better\nif user.has_permission() and not user.is_blocked():\n    allow_access()\n\n# Avoid\nif user.has_permission() and not user.blocked:\n    allow_access()\n</code></pre></li> <li>Avoid Deeply Nested Conditions: <pre><code># Instead of:\nif condition1:\n    if condition2:\n        if condition3:\n            do_something()\n\n# Consider:\nif not all([condition1, condition2, condition3]):\n    return\ndo_something()\n</code></pre></li> <li>Use Positive Conditions when possible: <pre><code># Better\nif is_valid and is_active:\n    process_user()\n\n# Avoid\nif not (not is_valid or not is_active):\n    process_user()\n</code></pre></li> <li>Leverage the Power of Truthiness: <pre><code># Better\nif user_list:\n    process_users()\n\n# Less Pythonic\nif len(user_list) &gt; 0:\n    process_users()\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#handling-empty-blocks-with-pass","title":"Handling Empty Blocks with <code>pass</code>","text":"<p>When you need a placeholder for code that will be implemented later, use the <code>pass</code> statement: <pre><code>def process_data(data):\n    if data.is_valid():\n        pass  # TODO: Implement data processing\n    else:\n        raise ValueError(\"Invalid data\")\n</code></pre> This documentation provides a comprehensive overview of Python's conditional statements, emphasizing both the technical aspects and the idiomatic ways to use them effectively in your code. Remember that clear, readable code is often more valuable than clever, condensed solutions.</p>"},{"location":"1.Fundamentals/d_python/#5-python-loop-structures","title":"5. Python Loop Structures","text":""},{"location":"1.Fundamentals/d_python/#introduction_2","title":"Introduction","text":"<p>Loops are fundamental control structures that enable code reuse and iteration in Python programs. By understanding how to effectively use loops, developers can write more efficient and maintainable code for processing collections, implementing algorithms, and handling repetitive tasks.</p>"},{"location":"1.Fundamentals/d_python/#while-loops-indefinite-iteration","title":"While Loops: Indefinite Iteration","text":"<p>While loops provide indefinite iteration, executing a block of code as long as a condition remains true. They are particularly useful when the number of iterations isn't known beforehand.</p>"},{"location":"1.Fundamentals/d_python/#basic-structure","title":"Basic Structure","text":"<p><pre><code>while condition:\n    # Loop body executed while condition is True\n    statement_1\n    statement_2\n    # Update condition state\n</code></pre>  The execution flow follows this pattern:</p> <ol> <li>Evaluate the condition</li> <li>If True, execute the loop body</li> <li>Return to step 1</li> <li>If False, exit loop and continue program execution</li> </ol> <p>Here's a practical example illustrating a counter: <pre><code>def count_down(start):\n    \"\"\"\n    Demonstrates while loop with a simple countdown\n    \"\"\"\n    counter = start\n    while counter &gt; 0:\n        print(f\"T-minus {counter}\")\n        counter -= 1  # Update condition state\n    print(\"Liftoff!\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#loop-control-with-break-and-continue","title":"Loop Control with break and continue","text":"<p>Python provides two important statements for controlling loop execution: <pre><code>def process_data(items):\n    \"\"\"\n    Demonstrates break and continue usage in while loops\n    \"\"\"\n    index = 0\n    while index &lt; len(items):\n        current = items[index]\n\n        if current == 'skip':\n            index += 1\n            continue  # Skip remaining loop body, start next iteration\n\n        if current == 'stop':\n            break  # Immediately exit the loop\n\n        print(f\"Processing {current}\")\n        index += 1\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#for-loops-definite-iteration","title":"For Loops: Definite Iteration","text":"<p>For loops provide definite iteration over sequences or collections. They're the preferred way to process items in a known sequence.</p>"},{"location":"1.Fundamentals/d_python/#basic-structure_1","title":"Basic Structure","text":"<p><pre><code>for element in iterable:\n    # Process element\n    statement_1\n    statement_2\n</code></pre> The execution steps are:</p> <ol> <li>Get next item from iterable</li> <li>Assign item to loop variable</li> <li>Execute loop body</li> <li>Repeat until iterable is exhausted</li> </ol> <p>Here's a practical example showing sequence processing: <pre><code>def calculate_metrics(values):\n    \"\"\"\n    Demonstrates for loop with collection processing\n    \"\"\"\n    total = 0\n    count = 0\n\n    for value in values:\n        total += value\n        count += 1\n\n    return {\n        'sum': total,\n        'count': count,\n        'average': total / count if count &gt; 0 else 0\n    }\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#range-based-iteration","title":"Range-Based Iteration","text":"<p>The  <code>range()</code>  function enables numeric iteration: <pre><code>def print_multiplication_table(n):\n    \"\"\"\n    Demonstrates range-based for loop\n    \"\"\"\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            print(f\"{i * j:4}\", end='')\n        print()  # New line after each row\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-loop-techniques","title":"Advanced Loop Techniques","text":""},{"location":"1.Fundamentals/d_python/#loop-with-else-clause","title":"Loop with else Clause","text":"<p>Python uniquely allows an else clause that executes when a loop completes normally: <pre><code>def find_element(sequence, target):\n    \"\"\"\n    Demonstrates loop else clause for search operations\n    \"\"\"\n    for element in sequence:\n        if element == target:\n            print(f\"Found {target}\")\n            break\n    else:\n        # Executes if no break occurred\n        print(f\"{target} not found\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#nested-loops","title":"Nested Loops","text":"<p>Loops can be nested to handle multi-dimensional data or complex iterations: <pre><code>def process_matrix(matrix):\n    \"\"\"\n    Demonstrates nested loop handling of 2D data\n    \"\"\"\n    rows = len(matrix)\n    cols = len(matrix[0]) if rows &gt; 0 else 0\n\n    for i in range(rows):\n        row_sum = 0\n        for j in range(cols):\n            row_sum += matrix[i][j]\n        print(f\"Sum of row {i}: {row_sum}\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-optimization","title":"Best Practices and Optimization","text":"<ol> <li>Choose the Right Loop Type:<ul> <li>Use  <code>for</code>  when iterating over a known sequence</li> <li>Use  <code>while</code>  when the iteration condition is dynamic</li> </ul> </li> <li>Avoid Modifying Loop Variables: <pre><code># Bad practice\nfor i in range(len(items)):\n    if condition:\n        i += 1  # Don't modify loop variable\n\n# Better approach\ni = 0\nwhile i &lt; len(items):\n    if condition:\n        i += 1\n    i += 1\n</code></pre></li> <li>Use Comprehensions for Simple Transformations: <pre><code># Instead of:\nsquares = []\nfor x in range(10):\n    squares.append(x ** 2)\n\n# Use:\nsquares = [x ** 2 for x in range(10)]\n</code></pre></li> <li>Consider Iterator Functions: <pre><code>from itertools import islice\n\ndef process_large_dataset(data_iterator, chunk_size=1000):\n    \"\"\"\n    Demonstrates efficient processing of large datasets\n    \"\"\"\n    while chunk := list(islice(data_iterator, chunk_size)):\n        process_chunk(chunk)\n</code></pre> </li> </ol>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"<ol> <li>Infinite Loops: Always ensure a clear exit condition: <pre><code>def wait_for_event():\n    while True:\n        if check_event():\n            break\n        # Always include a small delay in polling loops\n        time.sleep(0.1)\n</code></pre></li> <li>Memory Management: Use generators for large sequences: <pre><code>def process_large_file(filename):\n    with open(filename) as f:\n        # Don't do: lines = f.readlines()\n        for line in f:  # File is read line by line\n            process_line(line)\n</code></pre> This documentation provides a comprehensive overview of Python's loop structures, from basic usage to advanced techniques. Remember that choosing the right loop structure and following best practices can significantly impact your code's readability and performance.</li> </ol>"},{"location":"1.Fundamentals/d_python/#6-python-type-conversion","title":"6. Python Type Conversion","text":""},{"location":"1.Fundamentals/d_python/#understanding-type-conversion-in-python","title":"Understanding Type Conversion in Python","text":"<p>Type conversion is a fundamental concept in Python where we transform data from one type to another, enabling our code to work with different data representations. This capability is essential for building robust applications that can handle various forms of input and data processing.</p>"},{"location":"1.Fundamentals/d_python/#two-approaches-to-type-conversion","title":"Two Approaches to Type Conversion","text":"<p>Python provides two distinct mechanisms for type conversion, each serving different needs in our applications:</p>"},{"location":"1.Fundamentals/d_python/#1-implicit-type-conversion-type-coercion","title":"1. Implicit Type Conversion (Type Coercion)","text":"<p>Python automatically handles certain type conversions behind the scenes, a process known as implicit conversion or type coercion. This happens when Python can safely convert values without risking data loss. Let's explore how this works: <pre><code>def demonstrate_implicit_conversion():\n    integer_value = 42\n    float_value = 3.14\n\n    # Python automatically converts integer to float\n    result = integer_value + float_value\n\n    print(f\"Type of result: {type(result)}\")  # Will show float\n    print(f\"Value: {result}\")  # 45.14\n\n    return result\n</code></pre> In this example, Python automatically converts the integer  <code>42</code>  to a float before performing the addition. This happens because:</p> <ol> <li>Floats can represent integers without loss of precision</li> <li>Converting from int to float is considered a \"safe\" widening conversion</li> </ol>"},{"location":"1.Fundamentals/d_python/#2-explicit-type-conversion-type-casting","title":"2. Explicit Type Conversion (Type Casting)","text":"<p>When we need direct control over type conversion, we use explicit conversion functions. This is particularly important when:</p> <ul> <li>Working with user input</li> <li>Ensuring data consistency</li> <li>Performing calculations that require specific types</li> </ul> <p>Here's a comprehensive look at common type conversions: <pre><code>def demonstrate_explicit_conversion():\n    \"\"\"\n    Shows various explicit type conversions and their effects\n    \"\"\"\n    # String to numeric conversions\n    numeric_string = \"123\"\n    integer_value = int(numeric_string)    # Converts to 123\n    float_value = float(numeric_string)    # Converts to 123.0\n\n    # Numeric to string conversion\n    number = 456\n    string_value = str(number)    # Converts to \"456\"\n\n    # Float to integer (truncates decimal part)\n    float_number = 78.9\n    integer_from_float = int(float_number)    # Converts to 78\n\n    return {\n        'integer': integer_value,\n        'float': float_value,\n        'string': string_value,\n        'truncated': integer_from_float\n    }\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#handling-edge-cases-and-errors","title":"Handling Edge Cases and Errors","text":"<p>Type conversion isn't always straightforward. Here's how to handle common challenges: <pre><code>def safe_type_conversion(value, target_type):\n    \"\"\"\n    Safely converts values to target type with error handling\n\n    Args:\n        value: The value to convert\n        target_type: The desired type (int, float, or str)\n\n    Returns:\n        Converted value or None if conversion fails\n    \"\"\"\n    try:\n        if target_type == int:\n            # Handle float strings by first converting to float\n            if isinstance(value, str) and '.' in value:\n                return int(float(value))\n            return int(value)\n\n        elif target_type == float:\n            return float(value)\n\n        elif target_type == str:\n            return str(value)\n\n    except (ValueError, TypeError) as e:\n        print(f\"Conversion error: {e}\")\n        return None\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-type-conversion","title":"Best Practices for Type Conversion","text":"<ol> <li>Always Validate Input Before Converting: <pre><code>def process_numeric_input(value):\n    \"\"\"\n    Safely process numeric input with validation\n    \"\"\"\n    if not value:\n        raise ValueError(\"Input cannot be empty\")\n\n    # Remove whitespace and check if numeric\n    cleaned = value.strip()\n    if not cleaned.replace('.', '').replace('-', '').isdigit():\n        raise ValueError(\"Input must be numeric\")\n\n    return float(cleaned)\n</code></pre></li> <li>Handle Precision with Care: <pre><code>from decimal import Decimal\n\ndef handle_financial_calculation(amount_str):\n    \"\"\"\n    Convert string amounts to Decimal for precise financial calculations\n    \"\"\"\n    try:\n        # Use Decimal for precise monetary calculations\n        amount = Decimal(amount_str)\n        return amount\n    except (ValueError, decimal.InvalidOperation):\n        raise ValueError(\"Invalid monetary amount\")\n</code></pre></li> <li>Consider Type Hints for Better Code Clarity: <pre><code>from typing import Union, Optional\n\ndef convert_temperature(value: Union[int, float, str], \n                       from_unit: str = 'C') -&gt; Optional[float]:\n    \"\"\"\n    Convert temperature between Celsius and Fahrenheit\n    \"\"\"\n    try:\n        temp = float(value)\n        if from_unit.upper() == 'C':\n            return (temp * 9/5) + 32\n        elif from_unit.upper() == 'F':\n            return (temp - 32) * 5/9\n        else:\n            return None\n    except ValueError:\n        return None\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#key-considerations","title":"Key Considerations","text":"<p>When working with type conversion, keep in mind:</p> <ol> <li>Data Loss: Converting between types may result in data loss (e.g., float to int truncates decimals)</li> <li>Performance: Excessive type conversions can impact performance. Cache converted values when appropriate: <pre><code>class DataProcessor:\n    def __init__(self, raw_value: str):\n        self._raw = raw_value\n        self._int_value = None  # Cache for converted value\n\n    @property\n    def as_int(self) -&gt; int:\n        if self._int_value is None:\n            self._int_value = int(self._raw)\n        return self._int_value\n</code></pre></li> <li>Unicode Considerations: When converting strings, be aware of encoding: <pre><code>def parse_user_input(raw_input: str) -&gt; str:\n    \"\"\"\n    Ensure string input is properly handled for unicode\n    \"\"\"\n    return raw_input.encode('utf-8').decode('utf-8')\n</code></pre> By understanding these concepts and following these practices, you can handle type conversions safely and effectively in your Python applications, leading to more robust and maintainable code.</li> </ol>"},{"location":"1.Fundamentals/d_python/#7-python-exception-handling","title":"7. Python Exception Handling","text":""},{"location":"1.Fundamentals/d_python/#introduction-to-error-handling","title":"Introduction to Error Handling","text":"<p>Error handling is a critical aspect of writing robust Python applications. When things go wrong in our code, Python provides a sophisticated mechanism for detecting, reporting, and handling errors through exceptions. Understanding this system is essential for writing reliable software.</p>"},{"location":"1.Fundamentals/d_python/#understanding-pythons-error-types","title":"Understanding Python's Error Types","text":""},{"location":"1.Fundamentals/d_python/#syntax-errors","title":"Syntax Errors","text":"<p>Syntax errors occur when Python cannot understand your code's structure. These are parsing errors that prevent your program from running at all. Let's examine a common example: <pre><code># This code contains a syntax error\ndef demonstrate_syntax_error():\n    while True print('Hello')  # Missing colon after True\n\n# Python's response:\n# SyntaxError: invalid syntax\n# The parser shows where it got confused with a ^ marker\n</code></pre> Syntax errors must be fixed before your code can run. They typically indicate:</p> <ul> <li>Missing colons after control statements</li> <li>Incorrect indentation</li> <li>Unmatched parentheses or brackets</li> <li>Invalid variable names</li> </ul>"},{"location":"1.Fundamentals/d_python/#runtime-exceptions","title":"Runtime Exceptions","text":"<p>Runtime exceptions occur during program execution when something unexpected happens. Here's a comprehensive example that demonstrates common exceptions: <pre><code>def demonstrate_runtime_exceptions():\n    \"\"\"Shows how different runtime errors manifest and should be handled\"\"\"\n\n    try:\n        # ZeroDivisionError: Division by zero\n        result = 10 / 0\n\n        # TypeError: Incompatible types\n        text = \"123\" + 456  \n\n        # NameError: Using undefined variable\n        print(undefined_variable)\n\n        # IndexError: Accessing invalid list index\n        my_list = [1, 2, 3]\n        value = my_list[10]\n\n    except ZeroDivisionError as zde:\n        print(f\"Math error: {zde}\")\n    except TypeError as te:\n        print(f\"Type mismatch: {te}\")\n    except NameError as ne:\n        print(f\"Variable issue: {ne}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#implementing-exception-handling","title":"Implementing Exception Handling","text":""},{"location":"1.Fundamentals/d_python/#the-try-except-pattern","title":"The try-except Pattern","text":"<p>The core of Python's exception handling is the try-except block. Here's a practical example: <pre><code>def process_user_input():\n    \"\"\"Safely process user input with comprehensive error handling\"\"\"\n\n    while True:\n        try:\n            # Attempt to get and process user input\n            age = input(\"Please enter your age: \")\n            age = int(age)\n\n            if age &lt; 0:\n                raise ValueError(\"Age cannot be negative\")\n\n            return age\n\n        except ValueError as ve:\n            # Handle both invalid numbers and negative values\n            print(f\"Invalid input: {ve}\")\n            print(\"Please enter a positive number\")\n\n        except KeyboardInterrupt:\n            # Handle user interruption (Ctrl+C)\n            print(\"\\nInput cancelled by user\")\n            return None\n\n        finally:\n            # This code runs whether an exception occurred or not\n            print(\"Input processing completed\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#using-multiple-exception-handlers","title":"Using Multiple Exception Handlers","text":"<p>Sometimes we need to handle different exceptions differently. Here's how to structure that: <pre><code>def load_and_process_data(filename):\n    \"\"\"Demonstrates handling multiple exception types with different responses\"\"\"\n\n    try:\n        # Multiple things could go wrong here\n        with open(filename, 'r') as file:\n            data = file.read()\n            result = process_data(data)\n            return result\n\n    except FileNotFoundError:\n        # Handle missing file\n        print(f\"Could not find {filename}\")\n        return None\n\n    except PermissionError:\n        # Handle access issues\n        print(f\"No permission to access {filename}\")\n        return None\n\n    except json.JSONDecodeError:\n        # Handle invalid data format\n        print(f\"Invalid data format in {filename}\")\n        return None\n\n    except Exception as e:\n        # Handle any unexpected errors\n        print(f\"Unexpected error: {e}\")\n        # Re-raise to allow higher-level handling\n        raise\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#the-finally-clause","title":"The Finally Clause","text":"<p>The finally clause ensures certain code runs no matter what happens: <pre><code>def work_with_resource():\n    \"\"\"Shows proper resource management with finally\"\"\"\n\n    resource = None\n    try:\n        resource = acquire_resource()\n        do_work_with_resource(resource)\n\n    except ResourceError as re:\n        print(f\"Error working with resource: {re}\")\n        raise  # Re-raise to inform caller\n\n    finally:\n        # This cleanup code runs whether there was an error or not\n        if resource:\n            resource.close()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#creating-custom-exceptions","title":"Creating Custom Exceptions","text":"<p>For domain-specific error handling, create custom exceptions: <pre><code>class DataValidationError(Exception):\n    \"\"\"Raised when data fails validation requirements\"\"\"\n\n    def __init__(self, message, invalid_fields=None):\n        super().__init__(message)\n        self.invalid_fields = invalid_fields or []\n\nclass DatabaseConnectionError(Exception):\n    \"\"\"Raised when database connection fails\"\"\"\n\n    def __init__(self, message, retry_count=0):\n        super().__init__(message)\n        self.retry_count = retry_count\n\ndef validate_user_data(data):\n    \"\"\"Example using custom exceptions for better error handling\"\"\"\n\n    invalid_fields = []\n    if not data.get('name'):\n        invalid_fields.append('name')\n    if not data.get('email'):\n        invalid_fields.append('email')\n\n    if invalid_fields:\n        raise DataValidationError(\n            \"Missing required fields\", \n            invalid_fields=invalid_fields\n        )\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices_1","title":"Best Practices","text":"<ol> <li>Be Specific: Catch the most specific exception possible rather than using bare  <code>except</code>  clauses.</li> <li>Don't Suppress Exceptions: Unless you have a good reason, avoid empty except blocks: <pre><code># Bad\ntry:\n    process_data()\nexcept Exception:\n    pass  # Suppresses all errors!\n\n# Good\ntry:\n    process_data()\nexcept ValueError as ve:\n    logger.error(f\"Invalid data format: {ve}\")\n    raise  # Re-raise if you can't handle it\n</code></pre></li> <li>Clean Up Resources: Use context managers (with statements) or finally clauses to ensure resources are properly cleaned up: <pre><code># Preferred way to handle file operations\nwith open('file.txt', 'r') as file:\n    data = file.read()\n</code></pre></li> <li>Add Context: Use exception chaining to provide additional context: <pre><code>try:\n    process_data()\nexcept ValueError as ve:\n    raise RuntimeError(\"Failed to process user input\") from ve\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#8-python-functions","title":"8. Python Functions","text":""},{"location":"1.Fundamentals/d_python/#introduction_3","title":"Introduction","text":"<p>Functions are the fundamental building blocks of modular and maintainable Python code. They allow us to encapsulate reusable logic, make our code more readable, and create abstractions that help manage complexity. In this comprehensive guide, we'll explore how to define and use functions effectively in Python.</p>"},{"location":"1.Fundamentals/d_python/#core-function-concepts","title":"Core Function Concepts","text":""},{"location":"1.Fundamentals/d_python/#basic-function-structure","title":"Basic Function Structure","text":"<p>The essence of a Python function is defined by its components: <pre><code>def function_name(parameter1, parameter2):\n    \"\"\"Docstring explaining what the function does.\n\n    Args:\n        parameter1: Description of first parameter\n        parameter2: Description of second parameter\n\n    Returns:\n        Description of what the function returns\n    \"\"\"\n    # Function body\n    result = parameter1 + parameter2\n    return result  # Return statement\n</code></pre> Each element serves a specific purpose:</p> <ol> <li>The  <code>def</code>  keyword indicates a function definition</li> <li>Parameters define the function's inputs</li> <li>The docstring documents the function's purpose and usage</li> <li>The function body contains the actual logic</li> <li>The return statement specifies what data to send back</li> </ol>"},{"location":"1.Fundamentals/d_python/#function-arguments-and-parameter-types","title":"Function Arguments and Parameter Types","text":"<p>Python offers exceptional flexibility in how functions can accept arguments: <pre><code>def demonstrate_parameter_types(\n    required,                 # Positional parameter - required\n    optional=\"default\",       # Optional parameter with default value\n    *args,                   # Variable positional arguments\n    keyword_only=None,       # Keyword-only parameter\n    **kwargs                 # Variable keyword arguments\n):\n    \"\"\"Shows the various ways parameters can be defined and used.\"\"\"\n    print(f\"Required: {required}\")\n    print(f\"Optional: {optional}\")\n    print(f\"Args: {args}\")\n    print(f\"Keyword-only: {keyword_only}\")\n    print(f\"Kwargs: {kwargs}\")\n</code></pre> This function demonstrates the five main parameter types:</p> <ol> <li>Required positional parameters must be provided</li> <li>Optional parameters can be omitted (using default values)</li> <li>*args collects additional positional arguments into a tuple</li> <li>Keyword-only parameters must be specified by name</li> <li>**kwargs collects additional keyword arguments into a dictionary</li> </ol>"},{"location":"1.Fundamentals/d_python/#advanced-function-features","title":"Advanced Function Features","text":""},{"location":"1.Fundamentals/d_python/#return-values-and-multiple-returns","title":"Return Values and Multiple Returns","text":"<p>Functions can return multiple values using tuple packing: <pre><code>def analyze_data(numbers):\n    \"\"\"Analyzes a list of numbers.\n\n    Returns multiple values showing different statistical measures.\n    \"\"\"\n    total = sum(numbers)\n    average = total / len(numbers)\n    minimum = min(numbers)\n    maximum = max(numbers)\n\n    # Multiple returns are packed into a tuple\n    return total, average, minimum, maximum\n\n# Unpack the returned values\nsum_val, avg, min_val, max_val = analyze_data([1, 2, 3, 4, 5])\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#using-function-annotations","title":"Using Function Annotations","text":"<p>Type hints provide clarity about expected types: <pre><code>def calculate_discount(\n    price: float,\n    discount_percent: float = 10.0\n) -&gt; float:\n    \"\"\"Calculates the final price after applying a discount.\n\n    Args:\n        price: The original price\n        discount_percent: Percentage to discount (default 10%)\n\n    Returns:\n        The price after applying the discount\n    \"\"\"\n    if not 0 &lt;= discount_percent &lt;= 100:\n        raise ValueError(\"Discount must be between 0 and 100\")\n\n    discount = price * (discount_percent / 100)\n    return price - discount\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-design-patterns","title":"Best Practices and Design Patterns","text":""},{"location":"1.Fundamentals/d_python/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Functions should do one thing and do it well: <pre><code># Bad: Function does too many things\ndef process_user_data(data):\n    validate_data(data)  # Validation\n    clean_data(data)     # Cleaning\n    save_to_db(data)     # Database operation\n    send_email(data)     # Email notification\n\n# Better: Split into focused functions\ndef process_user_data(data):\n    \"\"\"Orchestrates user data processing.\"\"\"\n    validated_data = validate_user_data(data)\n    clean_data = clean_user_data(validated_data)\n    save_user_data(clean_data)\n    notify_user_registration(data['email'])\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#pure-functions","title":"Pure Functions","text":"<p>Prefer pure functions that don't have side effects: <pre><code># Impure function - modifies global state\ntotal = 0\ndef add_to_total(value):\n    global total\n    total += value  # Side effect: modifies global variable\n    return total\n\n# Pure function - same input always gives same output\ndef add_numbers(a, b):\n    \"\"\"Returns the sum of two numbers without side effects.\"\"\"\n    return a + b\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#error-handling","title":"Error Handling","text":"<p>Implement robust error handling: <pre><code>def divide_numbers(a: float, b: float) -&gt; float:\n    \"\"\"Safely divides two numbers with error handling.\n\n    Args:\n        a: Numerator\n        b: Denominator\n\n    Raises:\n        ValueError: If denominator is zero\n        TypeError: If inputs aren't numeric\n\n    Returns:\n        The result of a/b\n    \"\"\"\n    try:\n        # Validate input types\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            raise TypeError(\"Inputs must be numeric\")\n\n        # Check for division by zero\n        if b == 0:\n            raise ValueError(\"Cannot divide by zero\")\n\n        return a / b\n\n    except (TypeError, ValueError) as e:\n        # Log the error for debugging\n        logger.error(f\"Error dividing {a} by {b}: {str(e)}\")\n        raise\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"1.Fundamentals/d_python/#function-decorators","title":"Function Decorators","text":"<p>Use decorators to modify or enhance function behavior: <pre><code>import time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    \"\"\"Decorator that measures function execution time.\"\"\"\n\n    @wraps(func)  # Preserves metadata of decorated function\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n\n        print(f\"{func.__name__} took {end - start:.6f} seconds\")\n        return result\n\n    return wrapper\n\n@timing_decorator\ndef slow_function():\n    \"\"\"Example function that takes time to execute.\"\"\"\n    time.sleep(1)\n    return \"Done!\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#function-factories","title":"Function Factories","text":"<p>Create functions that generate other functions: <pre><code>def create_multiplier(factor):\n    \"\"\"Creates a function that multiplies by a specific factor.\"\"\"\n\n    def multiplier(x):\n        return x * factor\n\n    return multiplier\n\n# Create specialized multiplication functions\ndouble = create_multiplier(2)\ntriple = create_multiplier(3)\n\nprint(double(5))  # Output: 10\nprint(triple(5))  # Output: 15\n</code></pre> By following these patterns and practices, you'll create more maintainable, readable, and robust Python code. Remember that functions are the building blocks of your programs - investing time in writing them well will pay dividends in code quality and developer productivity.</p>"},{"location":"1.Fundamentals/d_python/#9-python-collections-guide-lists-sets-and-tuples","title":"9. Python Collections Guide: Lists, Sets, and Tuples","text":""},{"location":"1.Fundamentals/d_python/#introduction_4","title":"Introduction","text":"<p>Python provides several built-in collection types to store and organize data. Understanding their characteristics, trade-offs, and best use cases is crucial for writing efficient and maintainable code. This guide explores the three main sequence types: lists, sets, and tuples.</p>"},{"location":"1.Fundamentals/d_python/#core-collection-types-overview","title":"Core Collection Types Overview","text":""},{"location":"1.Fundamentals/d_python/#lists-mutable-and-ordered-sequences","title":"Lists: Mutable and Ordered Sequences","text":"<p><pre><code># Lists are created with square brackets\nnumbers = [1, 2, 3, 4, 5]\nfruits = [\"apple\", \"banana\", \"orange\"]\n\n# Lists can be modified after creation\nnumbers.append(6)\nfruits[0] = \"pear\"  # Direct index assignment\n</code></pre> Key characteristics:</p> <ul> <li>Mutable: Elements can be added, removed, or modified</li> <li>Ordered: Elements maintain insertion order</li> <li>Indexed: Elements can be accessed by position</li> <li>Allow duplicates: The same value can appear multiple times</li> </ul>"},{"location":"1.Fundamentals/d_python/#sets-unique-and-unordered-collections","title":"Sets: Unique and Unordered Collections","text":"<p><pre><code># Sets are created with curly braces or the set() constructor\nunique_numbers = {1, 2, 3, 4, 5}\nunique_fruits = set([\"apple\", \"banana\", \"orange\"])\n\n# Duplicates are automatically removed\nnumbers_with_dupes = {1, 2, 2, 3, 3, 3}  # Results in {1, 2, 3}\n</code></pre> Key characteristics:</p> <ul> <li>Mutable: Elements can be added or removed</li> <li>Unordered: No guaranteed element order</li> <li>No indexing: Elements cannot be accessed by position</li> <li>Unique elements: Duplicates are automatically removed</li> <li>Hash-based: Extremely fast membership testing</li> </ul>"},{"location":"1.Fundamentals/d_python/#tuples-immutable-and-ordered-sequences","title":"Tuples: Immutable and Ordered Sequences","text":"<p><pre><code># Tuples are created with parentheses or just commas\ncoordinates = (1, 2, 3)\nrgb = 255, 128, 0  # Parentheses are optional\nsingle_element = (42,)  # Note the comma for single-element tuples\n\n# Attempting modification raises an error\ntry:\n    coordinates[0] = 5  # TypeError: tuple object does not support item assignment\nexcept TypeError as e:\n    print(f\"Cannot modify tuples: {e}\")\n</code></pre> Key characteristics:</p> <ul> <li>Immutable: Elements cannot be modified after creation</li> <li>Ordered: Elements maintain insertion order</li> <li>Indexed: Elements can be accessed by position</li> <li>Allow duplicates: The same value can appear multiple times</li> <li>Hashable: Can be used as dictionary keys or set elements</li> </ul>"},{"location":"1.Fundamentals/d_python/#performance-characteristics-and-use-cases","title":"Performance Characteristics and Use Cases","text":""},{"location":"1.Fundamentals/d_python/#memory-usage-and-performance","title":"Memory Usage and Performance","text":"<p><pre><code>def compare_memory_usage():\n    \"\"\"Compare memory footprint of different collections\"\"\"\n    import sys\n\n    # Create equivalent collections\n    data = list(range(1000))\n    list_size = sys.getsizeof(data)\n    tuple_size = sys.getsizeof(tuple(data))\n    set_size = sys.getsizeof(set(data))\n\n    print(f\"List size: {list_size} bytes\")\n    print(f\"Tuple size: {tuple_size} bytes\")  # Usually smaller than list\n    print(f\"Set size: {set_size} bytes\")  # Larger due to hash table\n</code></pre> Operation time complexities:</p> <ul> <li>Lists:<ul> <li>Indexing and assigning: O(1)</li> <li>Insertion/deletion at end: O(1)</li> <li>Insertion/deletion at beginning: O(n)</li> <li>Search: O(n)</li> </ul> </li> <li>Sets:<ul> <li>Add/remove: O(1) average</li> <li>Membership testing: O(1) average</li> <li>Union/intersection: O(min(len(s), len(t)))</li> </ul> </li> <li>Tuples:<ul> <li>Indexing: O(1)</li> <li>Search: O(n)</li> <li>Cannot modify after creation</li> </ul> </li> </ul>"},{"location":"1.Fundamentals/d_python/#choosing-the-right-collection-type","title":"Choosing the Right Collection Type","text":"<ol> <li>Choose Lists when you need: <pre><code>def list_use_cases():\n    # 1. Ordered sequence that will be modified\n    task_queue = [\"task1\", \"task2\", \"task3\"]\n    task_queue.append(\"task4\")\n    completed = task_queue.pop(0)\n\n    # 2. Duplicate elements are meaningful\n    readings = [22.5, 22.5, 22.6, 22.5]  # Temperature measurements\n\n    # 3. Random access by index is important\n    matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    center = matrix[1][1]  # Accessing grid positions\n</code></pre></li> <li>Choose Sets when you need: <pre><code>def set_use_cases():\n    # 1. Fast membership testing\n    valid_users = {\"alice\", \"bob\", \"charlie\"}\n    is_valid = \"alice\" in valid_users  # O(1) lookup\n\n    # 2. Removing duplicates\n    unique_visitors = set(visitor_log)\n\n    # 3. Set operations\n    employees = {\"alice\", \"bob\", \"charlie\"}\n    managers = {\"bob\", \"diana\"}\n    regular_employees = employees - managers  # Set difference\n    all_staff = employees | managers  # Set union\n</code></pre></li> <li>Choose Tuples when you need: <pre><code>def tuple_use_cases():\n    # 1. Immutable sequences\n    DAYS = (\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n\n    # 2. Dictionary keys\n    locations = {\n        (40.7128, -74.0060): \"New York City\",\n        (51.5074, -0.1278): \"London\"\n    }\n\n    # 3. Named collections (consider collections.namedtuple for clarity)\n    from collections import namedtuple\n    Point = namedtuple('Point', ['x', 'y', 'z'])\n    origin = Point(0, 0, 0)\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#advanced-usage-and-tips","title":"Advanced Usage and Tips","text":""},{"location":"1.Fundamentals/d_python/#type-conversions","title":"Type Conversions","text":"<p><pre><code>def demonstrate_conversions():\n    \"\"\"Show common collection type conversions\"\"\"\n    # Converting between types\n    numbers = [1, 2, 2, 3, 3, 3]\n    unique_numbers = set(numbers)  # Remove duplicates\n    immutable_numbers = tuple(unique_numbers)  # Make immutable\n\n    return len(numbers), len(unique_numbers), immutable_numbers\n\nif __name__ == \"__main__\":\n  numbers, unique_nums, immut_nums = demonstrate_conversions()\n  print(numbers)\n  print(unique_nums)\n  print(immut_nums)\n</code></pre> Output:</p> <p>6 3 (1, 2, 3)</p>"},{"location":"1.Fundamentals/d_python/#nested-collections","title":"Nested Collections","text":"<pre><code>def demonstrate_nesting():\n    \"\"\"Show how collections can be nested\"\"\"\n    # Grid using tuples (immutable)\n    grid = (\n        (1, 2, 3),\n        (4, 5, 6),\n        (7, 8, 9)\n    )\n\n    # Set of tuples (valid because tuples are immutable/hashable)\n    points = {(0, 0), (1, 0), (0, 1)}\n\n    # List of sets (useful for tracking groups)\n    teams = [\n        {\"alice\", \"bob\"},\n        {\"charlie\", \"diana\"},\n        {\"eve\", \"frank\"}\n    ]\n</code></pre>"},{"location":"1.Fundamentals/d_python/#10-python-list-methods-and-data-structures-a-comprehensive-guide","title":"10. Python List Methods and Data Structures: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_5","title":"Introduction","text":"<p>Python's list data structure is one of its most versatile and commonly used features. Lists provide a flexible way to store and manipulate sequences of data, offering a rich set of methods to modify, analyze, and transform their contents. Let's explore how these methods work and how we can effectively use lists in different scenarios.</p>"},{"location":"1.Fundamentals/d_python/#core-list-methods","title":"Core List Methods","text":""},{"location":"1.Fundamentals/d_python/#adding-and-removing-elements","title":"Adding and Removing Elements","text":"<p>The foundation of working with lists is understanding how to add and remove elements. Python provides several intuitive methods for these operations: <pre><code>def demonstrate_list_modifications():\n    \"\"\"Shows the common ways to modify list contents.\"\"\"\n    fruits = ['apple', 'banana', 'orange']\n\n    # Adding elements\n    fruits.append('grape')        # Adds single item at end\n    fruits.extend(['kiwi', 'mango'])  # Adds multiple items at end\n    fruits.insert(1, 'pear')     # Adds item at specific position\n\n    print(f\"After adding: {fruits}\")\n    # Output: ['apple', 'pear', 'banana', 'orange', 'grape', 'kiwi', 'mango']\n\n    # Removing elements\n    fruits.remove('banana')       # Removes first matching item\n    last_fruit = fruits.pop()     # Removes and returns last item\n    first_fruit = fruits.pop(0)   # Removes and returns item at index\n\n    print(f\"After removing: {fruits}\")\n    # Output: ['pear', 'orange', 'grape', 'kiwi']\n\n    return first_fruit, last_fruit  # Returns removed items for potential use\n</code></pre> Notice how each modification method serves a different purpose:</p> <ul> <li><code>append()</code>  is perfect for adding single items</li> <li><code>extend()</code>  efficiently adds multiple items</li> <li><code>insert()</code>  gives precise control over placement</li> <li><code>remove()</code>  targets specific values</li> <li><code>pop()</code>  lets you both remove and use the removed value</li> </ul>"},{"location":"1.Fundamentals/d_python/#searching-and-analyzing","title":"Searching and Analyzing","text":"<p>Lists provide methods to examine their contents: <pre><code>def analyze_list_contents(items):\n    \"\"\"Demonstrates methods for examining list contents.\"\"\"\n    # Count occurrences\n    apple_count = items.count('apple')\n\n    # Find positions (with error handling)\n    try:\n        first_orange = items.index('orange')\n        # Can also search in a slice\n        next_orange = items.index('orange', first_orange + 1)\n    except ValueError:\n        print(\"Item not found\")\n\n    # Get information about numeric contents\n    if all(isinstance(x, (int, float)) for x in items):\n        total = sum(items)\n        average = total / len(items)\n        return total, average\n\n    return None\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#ordering-and-arranging","title":"Ordering and Arranging","text":"<p>Python lists can be reordered in various ways: <pre><code>def demonstrate_ordering():\n    \"\"\"Shows different ways to order list contents.\"\"\"\n    numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\n\n    # Sorting in place (modifies original list)\n    numbers.sort()  # Natural order\n    print(f\"Sorted naturally: {numbers}\")\n\n    # Sort with custom key function\n    words = ['banana', 'apple', 'Cherry', 'date']\n    words.sort(key=str.lower)  # Case-insensitive sort\n    print(f\"Sorted case-insensitive: {words}\")\n\n    # Reversing\n    numbers.reverse()\n    print(f\"Reversed: {numbers}\")\n\n    # Creating new sorted lists (original unchanged)\n    sorted_copy = sorted(numbers)\n    reversed_copy = list(reversed(numbers))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-list-usage-patterns","title":"Advanced List Usage Patterns","text":""},{"location":"1.Fundamentals/d_python/#lists-as-stacks","title":"Lists as Stacks","text":"<p>Lists can efficiently implement a stack (last-in, first-out) data structure: <pre><code>class Stack:\n    \"\"\"Implements a stack using a Python list.\"\"\"\n\n    def __init__(self):\n        self._items = []  # Using list as underlying storage\n\n    def push(self, item):\n        \"\"\"Add item to top of stack.\"\"\"\n        self._items.append(item)\n\n    def pop(self):\n        \"\"\"Remove and return top item.\"\"\"\n        if not self._items:\n            raise IndexError(\"Pop from empty stack\")\n        return self._items.pop()\n\n    def peek(self):\n        \"\"\"View top item without removing it.\"\"\"\n        if not self._items:\n            raise IndexError(\"Peek at empty stack\")\n        return self._items[-1]\n\n    def is_empty(self):\n        return len(self._items) == 0\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#list-comprehensions-for-transformation","title":"List Comprehensions for Transformation","text":"<p>List comprehensions provide a powerful way to create new lists by transforming or filtering data: <pre><code>def demonstrate_list_comprehensions():\n    \"\"\"Shows various ways to use list comprehensions.\"\"\"\n    numbers = range(-5, 6)  # -5 to 5\n\n    # Transformation\n    squares = [x**2 for x in numbers]\n\n    # Filtering\n    positive = [x for x in numbers if x &gt; 0]\n\n    # Combining filtering and transformation\n    even_squares = [x**2 for x in numbers if x % 2 == 0]\n\n    # Working with strings\n    words = ['hello', 'world', 'python', 'programming']\n    capitals = [word.upper() for word in words if len(word) &gt; 5]\n\n    # Creating nested structures\n    matrix = [[1 if i == j else 0 for j in range(3)] for i in range(3)]\n\n    return squares, positive, even_squares, capitals, matrix\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#memory-and-performance-considerations","title":"Memory and Performance Considerations","text":"<p>When working with lists, it's important to understand their performance characteristics: <pre><code>def demonstrate_performance_patterns():\n    \"\"\"Shows efficient and inefficient list operations.\"\"\"\n    large_list = list(range(10000))\n\n    # Efficient: Adding/removing at end\n    large_list.append(42)      # O(1)\n    large_list.pop()           # O(1)\n\n    # Less efficient: Adding/removing at beginning\n    large_list.insert(0, 42)   # O(n)\n    large_list.pop(0)          # O(n)\n\n    # Efficient: Slicing to copy\n    first_half = large_list[:5000]  # O(k) where k is slice size\n\n    # Memory-efficient: Using iterators for large lists\n    def process_large_list():\n        return sum(x for x in large_list if x % 2 == 0)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-patterns","title":"Best Practices and Common Patterns","text":"<ol> <li>Use list methods instead of manual index manipulation when possible</li> <li>Consider using list comprehensions for clarity and performance</li> <li>Be mindful of operations that require shifting elements (like insert at beginning)</li> <li>Use the right tool for the job - consider alternative data structures like  <code>collections.deque</code>  for queue-like operations</li> <li>Take advantage of Python's built-in functions like  <code>map()</code>,  <code>filter()</code>, and  <code>reduce()</code>  for functional programming patterns</li> </ol> <p>Lists are a fundamental building block in Python, and mastering their methods and patterns is essential for writing efficient and maintainable code. By understanding these concepts, you can choose the right approaches for your specific use cases and write more elegant solutions to complex problems.</p>"},{"location":"1.Fundamentals/d_python/#11-python-dictionaries-a-comprehensive-guide","title":"11. Python Dictionaries: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#understanding-dictionary-fundamentals","title":"Understanding Dictionary Fundamentals","text":"<p>Dictionaries are one of Python's most powerful built-in data structures. At their core, they provide a way to store and retrieve values using keys instead of numeric indices. Let's explore how they work and when to use them.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts_1","title":"Core Concepts","text":"<p>A dictionary represents a collection of key-value mappings, similar to how a real dictionary maps words to their definitions. Here's a simple example: <pre><code>def demonstrate_dictionary_basics():\n    \"\"\"Shows fundamental dictionary concepts and operations.\"\"\"\n    # Creating a dictionary of book information\n    book = {\n        \"title\": \"The Python Guide\",\n        \"author\": \"Jane Smith\",\n        \"year\": 2024,\n        \"topics\": [\"basics\", \"advanced\", \"best practices\"]\n    }\n\n    # Key characteristics demonstrated:\n    # 1. Keys must be immutable (strings, numbers, tuples)\n    # 2. Values can be any type\n    # 3. Items maintain insertion order (Python 3.7+)\n    # 4. Keys must be unique\n\n    return book\n</code></pre> Think of each key-value pair as a labeled container. The key acts as a unique identifier to access its associated value, much like how a label on a filing cabinet helps you find specific documents.</p>"},{"location":"1.Fundamentals/d_python/#creating-and-modifying-dictionaries","title":"Creating and Modifying Dictionaries","text":"<p>There are several ways to create and modify dictionaries: <pre><code>def show_dictionary_operations():\n    \"\"\"Demonstrates different ways to work with dictionaries.\"\"\"\n\n    # Method 1: Dictionary literal syntax\n    config = {\n        \"debug\": True,\n        \"port\": 8080,\n        \"host\": \"localhost\"\n    }\n\n    # Method 2: Dict constructor with keyword arguments\n    user = dict(\n        username=\"admin\",\n        email=\"admin@example.com\",\n        active=True\n    )\n\n    # Method 3: Creating from sequences\n    keys = [\"a\", \"b\", \"c\"]\n    values = [1, 2, 3]\n    mapped = dict(zip(keys, values))\n\n    # Modifying dictionaries\n    config[\"debug\"] = False  # Updating existing key\n    config[\"timeout\"] = 30   # Adding new key\n\n    # Safely getting values\n    port = config.get(\"port\", 80)  # Returns 80 if key doesn't exist\n\n    return config, user, mapped\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#working-with-dictionary-data","title":"Working with Dictionary Data","text":"<p>Dictionaries offer several methods for accessing and manipulating their contents: <pre><code>def explore_dictionary_methods():\n    \"\"\"Shows common dictionary operations and methods.\"\"\"\n\n    inventory = {\n        \"apple\": 5,\n        \"banana\": 8,\n        \"orange\": 3\n    }\n\n    # Getting all keys, values, or items\n    print(\"Available fruits:\", list(inventory.keys()))\n    print(\"Stock levels:\", list(inventory.values()))\n\n    # Iterating over items\n    for fruit, quantity in inventory.items():\n        if quantity &lt; 5:\n            print(f\"Low stock alert: {fruit}\")\n\n    # Updating with another dictionary\n    new_stock = {\"mango\": 4, \"apple\": 7}\n    inventory.update(new_stock)\n\n    # Removing items\n    sold_out = inventory.pop(\"banana\")  # Removes and returns value\n\n    return inventory\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-dictionary-patterns","title":"Advanced Dictionary Patterns","text":""},{"location":"1.Fundamentals/d_python/#nested-dictionaries","title":"Nested Dictionaries","text":"<p>Dictionaries can contain other dictionaries, enabling complex data structures: <pre><code>def demonstrate_nested_structures():\n    \"\"\"Shows how to work with nested dictionaries.\"\"\"\n\n    # Organization structure representation\n    company = {\n        \"engineering\": {\n            \"team_lead\": \"Alice Johnson\",\n            \"members\": [\"Bob\", \"Charlie\", \"Diana\"],\n            \"projects\": {\n                \"backend\": {\"status\": \"active\", \"priority\": 1},\n                \"frontend\": {\"status\": \"planning\", \"priority\": 2}\n            }\n        },\n        \"marketing\": {\n            \"team_lead\": \"Eve Wilson\",\n            \"members\": [\"Frank\", \"Grace\"],\n            \"campaigns\": {\n                \"q1\": {\"budget\": 50000, \"status\": \"completed\"},\n                \"q2\": {\"budget\": 75000, \"status\": \"active\"}\n            }\n        }\n    }\n\n    # Accessing nested data safely\n    def get_nested_value(dictionary, keys, default=None):\n        \"\"\"Safely navigate nested dictionary structures.\"\"\"\n        current = dictionary\n        for key in keys:\n            if isinstance(current, dict):\n                current = current.get(key, default)\n            else:\n                return default\n        return current\n\n    # Example usage:\n    backend_status = get_nested_value(\n        company, \n        [\"engineering\", \"projects\", \"backend\", \"status\"]\n    )\n\n    return company, backend_status\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#dictionary-comprehensions","title":"Dictionary Comprehensions","text":"<p>Similar to list comprehensions, dictionary comprehensions provide a concise way to create dictionaries: <pre><code>def show_dictionary_comprehensions():\n    \"\"\"Demonstrates the power of dictionary comprehensions.\"\"\"\n\n    # Creating a mapping of numbers to their squares\n    squares = {x: x**2 for x in range(5)}\n\n    # Filtering and transforming existing dictionaries\n    scores = {\"Alice\": 92, \"Bob\": 85, \"Charlie\": 78, \"Diana\": 95}\n    honor_roll = {\n        name: score \n        for name, score in scores.items() \n        if score &gt;= 90\n    }\n\n    # Creating dictionary from two lists\n    keys = [\"a\", \"b\", \"c\"]\n    values = [1, 2, 3]\n    mapping = {k: v for k, v in zip(keys, values)}\n\n    return squares, honor_roll, mapping\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-patterns_1","title":"Best Practices and Common Patterns","text":"<ol> <li>Use dictionary methods for safe operations: <pre><code>def demonstrate_safe_patterns():\n    \"\"\"Shows safe dictionary usage patterns.\"\"\"\n\n    config = {\"host\": \"localhost\", \"port\": 8080}\n\n    # Better: Use .get() with default value\n    port = config.get(\"port\", 80)\n\n    # Better: Use .setdefault() to initialize\n    config.setdefault(\"timeout\", 30)\n\n    # Better: Use .update() for multiple updates\n    new_settings = {\"debug\": True, \"port\": 9000}\n    config.update(new_settings)\n</code></pre></li> <li>Consider using collections.defaultdict for special cases: <pre><code>from collections import defaultdict\n\ndef show_defaultdict_usage():\n    \"\"\"Demonstrates using defaultdict for automatic default values.\"\"\"\n\n    # Counting occurrences\n    word_counts = defaultdict(int)\n    text = \"the quick brown fox jumps over the lazy dog\"\n\n    for word in text.split():\n        word_counts[word] += 1\n\n    # Grouping related items\n    animals = defaultdict(list)\n    pets = [(\"dog\", \"Rex\"), (\"cat\", \"Whiskers\"), (\"dog\", \"Buddy\")]\n\n    for species, name in pets:\n        animals[species].append(name)\n\n    return word_counts, animals\n</code></pre> Understanding dictionaries is crucial for Python development, as they're used extensively in configuration, caching, counting, and data organization. By mastering these concepts and patterns, you'll be better equipped to write more efficient and maintainable Python code.</li> </ol>"},{"location":"1.Fundamentals/d_python/#12-python-modules-a-complete-guide-to-code-organization","title":"12. Python Modules: A Complete Guide to Code Organization","text":""},{"location":"1.Fundamentals/d_python/#understanding-modules-the-building-blocks-of-python-programs","title":"Understanding Modules: The Building Blocks of Python Programs","text":"<p>When our Python programs grow beyond a few dozen lines, we need a way to organize code into logical, reusable pieces. This is where modules come in - they're Python's fundamental mechanism for code organization and reuse.</p> <p>Think of modules like chapters in a book: each one contains related content, and together they form a complete story. Let's explore how they work and how to use them effectively.</p>"},{"location":"1.Fundamentals/d_python/#creating-your-first-module","title":"Creating Your First Module","text":"<p>Let's start with a simple example. Here's a module called  <code>calculator.py</code>  that provides basic math operations: <pre><code># calculator.py\n\"\"\"\nA simple calculator module providing basic mathematical operations.\n\"\"\"\n\ndef add(a, b):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return a + b\n\ndef multiply(a, b):\n    \"\"\"Multiply two numbers and return the result.\"\"\"\n    return a * b\n\n# Module-level variable\nPI = 3.14159\n\n# This section only runs if the module is executed directly\nif __name__ == \"__main__\":\n    print(\"Running calculator module directly\")\n    print(f\"2 + 3 = {add(2, 3)}\")\n</code></pre> This module demonstrates several key concepts:</p> <ol> <li>Functions that encapsulate reusable logic</li> <li>Module-level constants (like  <code>PI</code>)</li> <li>Documentation using docstrings</li> <li>Special  <code>__name__</code>  check for direct execution</li> </ol>"},{"location":"1.Fundamentals/d_python/#using-modules-in-your-code","title":"Using Modules in Your Code","text":"<p>There are several ways to import and use modules. Let's explore each approach: <pre><code># Method 1: Import the entire module\nimport calculator\nresult = calculator.add(5, 3)  # Must use module name as prefix\n\n# Method 2: Import specific items\nfrom calculator import add, PI\nresult = add(5, 3)  # Can use function directly\ncircle_area = PI * radius**2\n\n# Method 3: Import with an alias\nimport calculator as calc  # Useful for long module names\nresult = calc.multiply(4, 2)\n\n# Method 4: Import all names (generally discouraged)\nfrom calculator import *  # Makes code harder to understand\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#module-search-path-and-importing","title":"Module Search Path and Importing","text":"<p>Python uses a specific search strategy to find modules. Understanding this helps prevent common import errors: <pre><code>import sys\n\ndef explain_module_path():\n    \"\"\"Show where Python looks for modules.\"\"\"\n    print(\"Python searches these locations in order:\")\n    for path in sys.path:\n        print(f\"- {path}\")\n\n    # You can add custom paths\n    custom_path = \"/path/to/my/modules\"\n    sys.path.append(custom_path)  # Add to end of search path\n    sys.path.insert(0, custom_path)  # Add to beginning (higher priority)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#creating-a-package","title":"Creating a Package","text":"<p>As projects grow, you might want to organize related modules into packages. Here's a typical structure: <pre><code>math_toolkit/\n    \u2502\n    \u251c\u2500\u2500 __init__.py           # Makes the directory a package\n    \u251c\u2500\u2500 basic/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 arithmetic.py     # Basic operations\n    \u2502   \u2514\u2500\u2500 trigonometry.py   # Trig functions\n    \u2502\n    \u2514\u2500\u2500 advanced/\n        \u251c\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 statistics.py     # Statistical operations\n        \u2514\u2500\u2500 calculus.py       # Calculus operations\n</code></pre> The <code>__init__.py</code> files can be empty or can contain initialization code: <pre><code># math_toolkit/__init__.py\n\"\"\"\nMath Toolkit: A comprehensive package for mathematical operations.\n\"\"\"\n\n# Import commonly used items for easier access\nfrom .basic.arithmetic import add, subtract\nfrom .basic.trigonometry import sin, cos\n\n# Define package-level variables\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n\n# Define what gets imported with \"from math_toolkit import *\"\n__all__ = ['add', 'subtract', 'sin', 'cos']\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-module-design","title":"Best Practices for Module Design","text":"<ol> <li>Keep modules focused and cohesive: <pre><code># Good: Single responsibility\n# geometry.py\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return pi * self.radius**2\n\n# Bad: Mixed responsibilities\n# mixed.py\nclass Circle:\n    # Geometry mixed with database operations\n    def save_to_database(self):\n        # Database code here\n        pass\n</code></pre></li> <li>Use clear, descriptive names and documentation: <pre><code># Good\ndef calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"Calculate the area of a rectangle.\n\n    Args:\n        length: The length of the rectangle\n        width: The width of the rectangle\n\n    Returns:\n        The area of the rectangle\n    \"\"\"\n    return length * width\n\n# Bad\ndef calc(l, w):\n    return l * w\n</code></pre></li> <li>Handle imports cleanly: <pre><code># Good: Organized imports\nimport os\nimport sys\nfrom typing import List, Optional\n\nimport numpy as np\nimport pandas as pd\n\nfrom .utils import helper_function\n\n# Bad: Messy imports\nfrom os import *\nimport sys, math, re\nfrom some_module import a,b,c,d,e,f,g\n</code></pre></li> <li>Use relative imports within packages: <pre><code># In math_toolkit/advanced/statistics.py\n# Good: Relative imports are clear and maintainable\nfrom ..basic.arithmetic import add\nfrom .helper import calculate_variance\n\n# Bad: Absolute imports are more fragile\nfrom math_toolkit.basic.arithmetic import add\n</code></pre> Following these guidelines helps create maintainable, reusable code that others (including your future self) will thank you for. Remember that modules and packages are not just about organizing code - they're about creating clear, logical boundaries that make your code easier to understand and maintain.</li> </ol> <p>By mastering Python's module system, you'll be able to create well-organized, professional-quality code that's a pleasure to work with and maintain.</p>"},{"location":"1.Fundamentals/d_python/#13-python-built-in-and-custom-modules-a-comprehensive-guide","title":"13. Python Built-in and Custom Modules: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#understanding-pythons-module-system","title":"Understanding Python's Module System","text":"<p>Python's module system is like a well-organized library, where each module is a book containing specific functions and tools. Let's explore the most useful built-in modules and learn how to create our own custom modules.</p>"},{"location":"1.Fundamentals/d_python/#essential-built-in-modules","title":"Essential Built-in Modules","text":"<p>Python has a rich standard library of built-in modules that provide a wide range of functionality. Some of the most commonly used built-in modules include: sys, os, math, datetime, random, re, itertools, etc.</p> <p>The following resource can be used to view all of Python's built-in modules and their functionalities: Python's Built-In Modules</p>"},{"location":"1.Fundamentals/d_python/#creating-custom-modules","title":"Creating Custom Modules","text":"<p>Custom modules help organize related code into separate files. Here's how to create and use them effectively:</p>"},{"location":"1.Fundamentals/d_python/#example-custom-math-operations-module","title":"Example: Custom Math Operations Module","text":"<pre><code># math_operations.py\n\n\"\"\"\nA custom module for specialized mathematical operations.\n\"\"\"\n\ndef factorial(n: int) -&gt; int:\n    \"\"\"Calculate factorial using recursion with memoization.\"\"\"\n    if not hasattr(factorial, '_cache'):\n        factorial._cache = {}\n\n    if n in factorial._cache:\n        return factorial._cache[n]\n\n    if n &lt;= 1:\n        return 1\n\n    result = n * factorial(n - 1)\n    factorial._cache[n] = result\n    return result\n\ndef fibonacci(n: int) -&gt; int:\n    \"\"\"Calculate nth Fibonacci number using dynamic programming.\"\"\"\n    if n &lt;= 1:\n        return n\n\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    return b\n</code></pre>"},{"location":"1.Fundamentals/d_python/#using-custom-modules","title":"Using Custom Modules","text":"<pre><code># main.py\nimport math_operations as mo\n\ndef demonstrate_custom_module():\n    \"\"\"Shows how to use a custom module.\"\"\"\n\n    # Calculate factorial of 5\n    fact_5 = mo.factorial(5)\n\n    # Get 10th Fibonacci number\n    fib_10 = mo.fibonacci(10)\n\n    print(f\"\"\"Custom Module Results:\n    5! = {fact_5}\n    10th Fibonacci number = {fib_10}\n    \"\"\")\n</code></pre>"},{"location":"1.Fundamentals/d_python/#module-best-practices","title":"Module Best Practices","text":"<ol> <li>Module Structure: <pre><code>\"\"\"Module docstring explaining purpose and usage.\"\"\"\n\n# Standard library imports\nimport os\nimport sys\n\n# Third-party imports\nimport numpy as np\n\n# Local/custom imports\nfrom .utils import helper_function\n\n# Module-level constants\nMAX_RETRIES = 3\nDEFAULT_TIMEOUT = 30\n\n# Module-level variables (use sparingly)\n_cache = {}\n\n# Main functionality\ndef main_function():\n    \"\"\"Core functionality of the module.\"\"\"\n    pass\n\n# Helper functions\ndef _internal_helper():\n    \"\"\"Internal helper function (note the underscore prefix).\"\"\"\n    pass\n\nif __name__ == \"__main__\":\n    # Module self-test code\n    main_function()\n</code></pre></li> <li>Module Documentation: <pre><code># example_module.py\n\"\"\"\nExample Module\n=============\n\nThis module provides utilities for [specific purpose].\n\nFunctions\n---------\nprocess_data(data: list) -&gt; dict\n    Process input data and return results\n\nClasses\n-------\nDataProcessor\n    Main class for data processing\n\nUsage\n-----\n&gt;&gt;&gt; from example_module import process_data\n&gt;&gt;&gt; result = process_data([1, 2, 3])\n\"\"\"\n\n# Rest of module code...\n</code></pre></li> <li>Module Path Management: <pre><code>def setup_module_path():\n    \"\"\"\n    Configure Python's module search path intelligently.\n    \"\"\"\n    import sys\n    from pathlib import Path\n\n    # Get the directory containing current file\n    current_dir = Path(__file__).parent.resolve()\n\n    # Add parent directory to Python path for sibling module imports\n    parent_dir = current_dir.parent\n    if str(parent_dir) not in sys.path:\n        sys.path.insert(0, str(parent_dir))\n\n    # Add custom module directory\n    custom_modules = current_dir / \"custom_modules\"\n    if custom_modules.exists() and str(custom_modules) not in sys.path:\n        sys.path.insert(0, str(custom_modules))\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#advanced-module-features","title":"Advanced Module Features","text":"<ol> <li>Module Reloading for Development: <pre><code>import importlib\n\ndef reload_module(module):\n    \"\"\"\n    Reload a module during development to pick up changes.\n    \"\"\"\n    try:\n        importlib.reload(module)\n        print(f\"Successfully reloaded {module.__name__}\")\n    except Exception as e:\n        print(f\"Error reloading {module.__name__}: {e}\")\n</code></pre> By following these patterns and practices, you can create well-organized, maintainable, and reusable Python modules that make your code more structured and easier to understand. Remember that modules are not just about organizing code\u2014they're about creating clear boundaries and interfaces that make your code more maintainable and reusable.</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-python-lambda-functions-a-deep-dive","title":"Understanding Python Lambda Functions: A Deep Dive","text":""},{"location":"1.Fundamentals/d_python/#introduction-to-lambda-functions-and-their-origins","title":"Introduction to Lambda Functions and Their Origins","text":"<p>Lambda functions in Python represent a fascinating intersection of computer science theory and practical programming. They derive their name and concept from lambda calculus, a formal system of computation developed by mathematician Alonzo Church in the 1930s. By understanding both their theoretical foundations and practical applications, we can better appreciate when and how to use them effectively.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts-of-lambda-functions","title":"Core Concepts of Lambda Functions","text":"<p>A lambda function is essentially a small, anonymous function that can be created inline. Think of it as a tiny machine that takes some input, performs a single operation, and returns a result. Here's how they work: <pre><code>def explain_lambda_concepts():\n    \"\"\"Demonstrates the core concepts of lambda functions through examples.\"\"\"\n\n    # A traditional function for squaring a number\n    def square(x):\n        return x * x\n\n    # The equivalent lambda function\n    square_lambda = lambda x: x * x\n\n    # Let's compare their behavior\n    number = 5\n    print(f\"Traditional function result: {square(number)}\")\n    print(f\"Lambda function result: {square_lambda(number)}\")\n\n    # Multiple arguments work too\n    add = lambda x, y: x + y\n    print(f\"Adding 3 and 4: {add(3, 4)}\")\n</code></pre> In this example, you can see that lambda functions provide a more concise way to write simple functions. Think of them like mathematical expressions:  <code>f(x) = x * x</code>  becomes  <code>lambda x: x * x</code>  in Python.</p>"},{"location":"1.Fundamentals/d_python/#when-to-use-lambda-functions","title":"When to Use Lambda Functions","text":"<p>Lambda functions shine in specific situations. Let's explore when they're most appropriate: <pre><code>def demonstrate_lambda_use_cases():\n    \"\"\"Shows the most effective uses of lambda functions.\"\"\"\n\n    # 1. Sorting with custom keys\n    students = [\n        {'name': 'Alice', 'grade': 88},\n        {'name': 'Bob', 'grade': 92},\n        {'name': 'Charlie', 'grade': 85}\n    ]\n\n    # Sort by grade using lambda\n    sorted_students = sorted(students, key=lambda s: s['grade'], reverse=True)\n\n    # 2. Quick data transformations\n    numbers = [1, 2, 3, 4, 5]\n    doubled = list(map(lambda x: x * 2, numbers))\n\n    # 3. Short callbacks in UI code\n    def create_button(text, callback):\n        \"\"\"Simulates creating a UI button with a callback.\"\"\"\n        print(f\"Button '{text}' created with callback: {callback.__name__}\")\n        callback()\n\n    # Using lambda for a simple callback\n    create_button(\"Save\", lambda: print(\"Saving...\"))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-pitfalls","title":"Best Practices and Common Pitfalls","text":"<p>Understanding when not to use lambda functions is just as important as knowing when to use them: <pre><code>def demonstrate_lambda_practices():\n    \"\"\"Illustrates best practices and common pitfalls with lambda functions.\"\"\"\n\n    # DON'T: Assign lambda to a name when a def would be clearer\n    # Bad practice:\n    complicated_lambda = lambda x, y: x**2 + y**2 + 2*x*y\n\n    # Better practice:\n    def calculate_expression(x, y):\n        \"\"\"Calculates x^2 + y^2 + 2xy.\"\"\"\n        return x**2 + y**2 + 2*x*y\n\n    # DO: Use lambda for simple key functions\n    points = [(1, 2), (3, 1), (2, 4)]\n    sorted_by_y = sorted(points, key=lambda point: point[1])\n\n    # DON'T: Use lambda for complex operations\n    # Bad practice:\n    result = (lambda x: (\n        x.strip()\n        .replace(',', '')\n        .upper()\n    ))(\"hello, world\")\n\n    # Better practice:\n    def clean_text(text):\n        \"\"\"Cleans and formats text by removing commas and converting to uppercase.\"\"\"\n        text = text.strip()\n        text = text.replace(',', '')\n        return text.upper()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#understanding-lambda-function-limitations","title":"Understanding Lambda Function Limitations","text":"<p>Lambda functions have specific limitations that shape how we use them: <pre><code>def explore_lambda_limitations():\n    \"\"\"Demonstrates the limitations of lambda functions.\"\"\"\n\n    try:\n        # Cannot use statements inside lambda\n        invalid_lambda = lambda x: (\n            if x &gt; 0:  # This will cause a syntax error\n                return x\n        )\n    except SyntaxError:\n        print(\"Lambdas cannot contain statements like if/return\")\n\n    # Cannot add documentation to lambda functions\n    add = lambda x, y: x + y  # No way to add docstring\n\n    # Instead, use a regular function when documentation is needed:\n    def add_documented(x, y):\n        \"\"\"Adds two numbers together.\n\n        Args:\n            x: First number\n            y: Second number\n\n        Returns:\n            Sum of x and y\n        \"\"\"\n        return x + y\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#alternative-approaches","title":"Alternative Approaches","text":"<p>Often, there are more readable alternatives to lambda functions: <pre><code>def show_lambda_alternatives():\n    \"\"\"Demonstrates clearer alternatives to lambda functions.\"\"\"\n\n    numbers = [1, -2, 3, -4, 5]\n\n    # Instead of lambda with filter:\n    positive_lambda = list(filter(lambda x: x &gt; 0, numbers))\n\n    # Use a list comprehension:\n    positive_comprehension = [x for x in numbers if x &gt; 0]\n\n    # Instead of lambda with map:\n    squared_lambda = list(map(lambda x: x**2, numbers))\n\n    # Use a list comprehension:\n    squared_comprehension = [x**2 for x in numbers]\n</code></pre> Lambda functions are a powerful feature of Python, but they should be used judiciously. Think of them as a specialized tool in your programming toolbox - perfect for certain situations but not for every job. When used appropriately, they can make your code more concise and elegant. When overused, they can make it harder to understand and maintain.</p> <p>Remember: clarity is more important than brevity. If you find yourself writing a complex lambda function, it's probably better to use a regular function instead. The goal is to write code that others (including your future self) can easily understand and maintain.</p>"},{"location":"1.Fundamentals/d_python/#a-comprehensive-guide-to-python-decorators","title":"A Comprehensive Guide to Python Decorators","text":""},{"location":"1.Fundamentals/d_python/#understanding-the-power-of-decorators","title":"Understanding the Power of Decorators","text":"<p>Decorators are one of Python's most elegant and powerful features, allowing you to enhance or modify the behavior of functions without changing their source code. Think of a decorator as a wrapper that you can place around an existing function - like putting a letter in an envelope that adds special handling instructions.</p> <p>Let's explore how decorators work from the ground up, building our understanding piece by piece.</p>"},{"location":"1.Fundamentals/d_python/#the-foundation-functions-as-first-class-objects","title":"The Foundation: Functions as First-Class Objects","text":"<p>To understand decorators, we first need to grasp that Python treats functions as first-class objects. This means functions can be:</p> <ul> <li>Assigned to variables</li> <li>Passed as arguments</li> <li>Returned from other functions</li> <li>Modified and manipulated like any other object</li> </ul> <p>Here's a simple example to illustrate this concept: <pre><code>def demonstrate_first_class_functions():\n    \"\"\"Shows how Python functions are first-class objects.\"\"\"\n\n    # A function can be assigned to a variable\n    def greet(name):\n        return f\"Hello, {name}!\"\n\n    welcome = greet  # Notice: no parentheses - we're assigning the function itself\n\n    # The function can be called through either name\n    print(greet(\"Alice\"))    # Prints: Hello, Alice!\n    print(welcome(\"Bob\"))    # Prints: Hello, Bob!\n\n    # Functions have attributes like any other object\n    print(f\"Function name: {greet.__name__}\")\n    print(f\"Function type: {type(greet)}\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#creating-your-first-decorator","title":"Creating Your First Decorator","text":"<p>Let's create a simple decorator that measures how long a function takes to execute: <pre><code>import time\nimport functools\n\ndef measure_time(func):\n    \"\"\"A decorator that measures the execution time of a function.\n\n    Args:\n        func: The function to be decorated\n\n    Returns:\n        A wrapper function that adds timing functionality\n    \"\"\"\n    @functools.wraps(func)  # Preserves func's metadata\n    def wrapper(*args, **kwargs):\n        # Record start time\n        start_time = time.perf_counter()\n\n        # Execute the original function\n        result = func(*args, **kwargs)\n\n        # Calculate execution time\n        end_time = time.perf_counter()\n        run_time = end_time - start_time\n\n        print(f\"Finished {func.__name__!r} in {run_time:.4f} secs\")\n\n        return result\n\n    return wrapper\n\n# Example usage\n@measure_time\ndef calculate_fibonacci(n):\n    \"\"\"Calculate the nth Fibonacci number recursively.\"\"\"\n    if n &lt;= 1:\n        return n\n    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#understanding-decorator-mechanics","title":"Understanding Decorator Mechanics","text":"<p>When you use the  <code>@decorator</code>  syntax, Python performs some behind-the-scenes magic. The following two code blocks are equivalent: <pre><code># Using the @ syntax\n@measure_time\ndef my_function():\n    pass\n\n# Is the same as\ndef my_function():\n    pass\nmy_function = measure_time(my_function)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-decorator-patterns","title":"Advanced Decorator Patterns","text":""},{"location":"1.Fundamentals/d_python/#decorators-with-arguments","title":"Decorators with Arguments","text":"<p>Sometimes you want to pass arguments to the decorator itself. This requires an additional layer of wrapping: <pre><code>def repeat(times):\n    \"\"\"Create a decorator that repeats a function a specified number of times.\n\n    Args:\n        times: Number of times to repeat the function\n\n    Returns:\n        A decorator that can be applied to a function\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            for _ in range(times):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(times=3)\ndef greet(name):\n    print(f\"Hello {name}\")\n    return True\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#class-based-decorators","title":"Class-Based Decorators","text":"<p>Sometimes using a class as a decorator provides better organization and state management: <pre><code>class MethodCallCounter:\n    \"\"\"A decorator that counts how many times a method is called.\n\n    This is particularly useful for profiling and debugging.\n    \"\"\"\n\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        # Preserve the original function's metadata\n        functools.update_wrapper(self, func)\n\n    def __call__(self, *args, **kwargs):\n        \"\"\"Called when the decorated function is invoked.\"\"\"\n        self.count += 1\n        print(f\"{self.func.__name__} has been called {self.count} times\")\n        return self.func(*args, **kwargs)\n\n    def reset_count(self):\n        \"\"\"Reset the call counter to zero.\"\"\"\n        self.count = 0\n\n@MethodCallCounter\ndef expensive_operation():\n    \"\"\"A function that we want to monitor.\"\"\"\n    time.sleep(1)  # Simulate expensive work\n    return \"Operation complete\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-gotchas","title":"Best Practices and Gotchas","text":"<ol> <li>Always use  <code>functools.wraps</code>: <pre><code>def my_decorator(func):\n    @functools.wraps(func)  # Preserves the original function's metadata\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n</code></pre></li> <li>Handle function signatures properly: <pre><code>def preserve_signature(func):\n    \"\"\"A decorator that preserves the original function's signature.\"\"\"\n    # This allows tools like type checkers to work correctly\n    from typing import TypeVar, Callable, Any\n\n    F = TypeVar('F', bound=Callable[..., Any])\n\n    @functools.wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre></li> <li>Be mindful of decorator order when using multiple decorators: <pre><code>@decorator1  # Applied last\n@decorator2  # Applied second\n@decorator3  # Applied first\ndef my_function():\n    pass\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#real-world-applications","title":"Real-World Applications","text":"<p>Decorators are commonly used for:</p> <ol> <li>Logging and Instrumentation: <pre><code>def log_calls(logger):\n    \"\"\"Create a decorator that logs function calls.\"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            logger.info(f\"Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n            result = func(*args, **kwargs)\n            logger.info(f\"{func.__name__} returned {result}\")\n            return result\n        return wrapper\n    return decorator\n</code></pre></li> <li>Caching and Memoization: <pre><code>def memoize(func):\n    \"\"\"Cache function results for repeated calls with same arguments.\"\"\"\n    cache = {}\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a hash from the arguments to use as a cache key\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = func(*args, **kwargs)\n        return cache[key]\n\n    return wrapper\n</code></pre> Decorators are a powerful tool in Python that enable clean, reusable code by separating concerns and following the DRY (Don't Repeat Yourself) principle. By understanding how to create and use decorators effectively, you can write more maintainable and elegant Python code.</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-python-iterators","title":"Understanding Python Iterators","text":""},{"location":"1.Fundamentals/d_python/#introduction_6","title":"Introduction","text":"<p>Iterators are fundamental building blocks in Python that provide a unified way to access elements in a collection one at a time. They are the underlying mechanism that powers many of Python's most useful features, including for loops, list comprehensions, and generators. Understanding iterators helps us write more efficient and elegant code.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts_2","title":"Core Concepts","text":""},{"location":"1.Fundamentals/d_python/#what-is-an-iterator","title":"What is an Iterator?","text":"<p>An iterator in Python is an object that represents a stream of data. Think of it as a pointer that keeps track of where we are in a sequence, remembering our position between successive fetches of data. Every time we request the next item, the iterator knows exactly where to look and what to return.</p> <p>Two key methods define an iterator:</p> <ol> <li><code>__iter__()</code>: Returns the iterator object itself</li> <li><code>__next__()</code>: Returns the next value in the sequence</li> </ol>"},{"location":"1.Fundamentals/d_python/#from-iterable-to-iterator","title":"From Iterable to Iterator","text":"<p>Let's understand the relationship between iterables and iterators: <pre><code># Creating an iterator from a list\ndef demonstrate_iterator_creation():\n    \"\"\"\n    Shows how to create and use an iterator from a list.\n    Returns the first three numbers from a sequence.\n    \"\"\"\n    numbers = [1, 2, 3, 4, 5]  # This is an iterable\n\n    # Convert iterable to iterator\n    iterator = iter(numbers)    # Behind the scenes: numbers.__iter__()\n\n    # Get values one by one\n    first = next(iterator)      # Returns 1\n    second = next(iterator)     # Returns 2\n    third = next(iterator)      # Returns 3\n\n    return first, second, third\n\n# The iterator maintains state between calls\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#creating-custom-iterators","title":"Creating Custom Iterators","text":"<p>Let's create a custom iterator that generates powers of two: <pre><code>class PowersOfTwo:\n    \"\"\"\n    An iterator that generates powers of two up to a specified maximum exponent.\n\n    This class demonstrates the core principles of iterator implementation:\n    1. State maintenance between calls\n    2. Implementation of iterator protocol\n    3. Proper handling of iteration termination\n    \"\"\"\n\n    def __init__(self, max_exponent):\n        \"\"\"Initialize with the maximum exponent to generate.\"\"\"\n        self.max_exponent = max_exponent\n        self.current_exponent = 0\n\n    def __iter__(self):\n        \"\"\"Return the iterator object (self).\"\"\"\n        self.current_exponent = 0  # Reset state for new iteration\n        return self\n\n    def __next__(self):\n        \"\"\"Generate and return the next power of two.\"\"\"\n        if self.current_exponent &lt;= self.max_exponent:\n            result = 2 ** self.current_exponent\n            self.current_exponent += 1\n            return result\n        else:\n            raise StopIteration\n\n# Example usage\npowers = PowersOfTwo(3)\nfor power in powers:\n    print(power)  # Outputs: 1, 2, 4, 8\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#understanding-iterator-behavior","title":"Understanding Iterator Behavior","text":""},{"location":"1.Fundamentals/d_python/#iterator-state","title":"Iterator State","text":"<p>Iterators maintain state, which is both their strength and a characteristic that requires careful consideration: <pre><code>def demonstrate_iterator_state():\n    \"\"\"\n    Demonstrates how iterators maintain state and are exhaustible.\n    \"\"\"\n    numbers = [1, 2, 3]\n    iterator = iter(numbers)\n\n    # First iteration - works fine\n    for num in iterator:\n        print(num)\n\n    # Second iteration - no output (iterator is exhausted)\n    for num in iterator:\n        print(num)  # Nothing happens\n\n    # Create a fresh iterator to start over\n    iterator = iter(numbers)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#infinite-iterators","title":"Infinite Iterators","text":"<p>Python allows creation of iterators that generate values indefinitely: <pre><code>class CountUpwards:\n    \"\"\"\n    An infinite iterator that counts upwards from a starting number.\n    Demonstrates the concept of an infinite sequence.\n    \"\"\"\n\n    def __init__(self, start=0):\n        self.current = start\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        result = self.current\n        self.current += 1\n        return result\n\n# Use with caution and always limit the iteration:\ncounter = CountUpwards(1)\nfor num in counter:\n    if num &gt; 5:\n        break\n    print(num)  # Outputs: 1, 2, 3, 4, 5\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-patterns","title":"Best Practices and Patterns","text":""},{"location":"1.Fundamentals/d_python/#memory-efficiency","title":"Memory Efficiency","text":"<p>Iterators are memory-efficient because they generate values on-demand rather than storing them all in memory: <pre><code># Memory-intensive approach (don't do this):\ndef get_squares_list(n):\n    \"\"\"Creates a list of squares in memory.\"\"\"\n    return [x*x for x in range(n)]\n\n# Memory-efficient approach using iterator:\nclass SquaresIterator:\n    \"\"\"Generates squares one at a time.\"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.current = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current &gt;= self.n:\n            raise StopIteration\n        result = self.current * self.current\n        self.current += 1\n        return result\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#exception-handling","title":"Exception Handling","text":"<p>Always handle iterator exhaustion gracefully: <pre><code>def safe_iteration(iterator):\n    \"\"\"Demonstrates safe iteration with exception handling.\"\"\"\n    try:\n        while True:\n            value = next(iterator)\n            print(value)\n    except StopIteration:\n        print(\"Iterator exhausted\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#common-use-cases","title":"Common Use Cases","text":""},{"location":"1.Fundamentals/d_python/#data-processing","title":"Data Processing","text":"<p>Iterators are excellent for processing large datasets: <pre><code>class DataProcessor:\n    \"\"\"\n    Processes data items one at a time using an iterator.\n    Demonstrates real-world iterator usage.\n    \"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index &gt;= len(self.data):\n            raise StopIteration\n\n        # Process the current item\n        item = self.data[self.index]\n        processed_item = self._process_item(item)\n        self.index += 1\n\n        return processed_item\n\n    def _process_item(self, item):\n        \"\"\"Placeholder for data processing logic.\"\"\"\n        return item * 2\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Iterators provide lazy evaluation, generating values only when needed</li> <li>They maintain minimal state, reducing memory overhead</li> <li>They are ideal for processing large or infinite sequences</li> <li>Consider using iterators when working with large datasets or when memory is a concern</li> </ol>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-solutions_1","title":"Common Pitfalls and Solutions","text":"<ol> <li>Iterator Exhaustion<ul> <li>Always create new iterators when needed</li> <li>Use  <code>itertools.tee()</code>  to create multiple iterators from a single source</li> </ul> </li> <li>State Management<ul> <li>Reset state in  <code>__iter__()</code>  for reusable iterators</li> <li>Document state behavior clearly</li> </ul> </li> <li>Memory Leaks<ul> <li>Ensure proper cleanup in complex iterators</li> <li>Use context managers when appropriate</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-python-regular-expressions-a-comprehensive-guide","title":"Understanding Python Regular Expressions: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_7","title":"Introduction","text":"<p>Regular expressions (regex) represent one of the most powerful tools in a programmer's toolkit for working with text. Think of them as a specialized mini-language that lets us describe patterns in text. Just as we might tell someone to look for \"any three-digit number followed by a dash,\" regex gives us a formal way to express such patterns that computers can understand and use.</p>"},{"location":"1.Fundamentals/d_python/#understanding-raw-strings-the-foundation","title":"Understanding Raw Strings: The Foundation","text":"<p>Before diving into regex patterns, we need to understand a crucial Python concept: raw strings. In Python, we have two ways to write strings: <pre><code># Normal strings interpret escape sequences\nnormal_string = \"First\\nSecond\"   # Creates two lines: \"First\" and \"Second\"\n\n# Raw strings treat backslashes literally\nraw_string = r\"First\\nSecond\"     # Creates one line: \"First\\nSecond\"\n</code></pre> Why does this matter? Regular expressions frequently use backslashes to denote special patterns (like  <code>\\d</code>  for digits). Using raw strings (prefixed with  <code>r</code>) prevents Python from interpreting these backslashes as escape sequences, making our patterns clearer and more reliable.</p>"},{"location":"1.Fundamentals/d_python/#the-building-blocks-of-patterns","title":"The Building Blocks of Patterns","text":""},{"location":"1.Fundamentals/d_python/#basic-characters-the-literal-foundation","title":"Basic Characters: The Literal Foundation","text":"<p>The simplest patterns match exact sequences of characters. When we write: <pre><code>import re\npattern = r\"python\"\nresult = re.search(pattern, \"I love python programming\")\n</code></pre> Every character in our pattern (<code>python</code>) matches exactly that character in the text. Think of it as looking for an exact piece in a puzzle.</p>"},{"location":"1.Fundamentals/d_python/#character-classes-flexible-matching","title":"Character Classes: Flexible Matching","text":"<p>Character classes give us flexibility in matching. They're like saying \"match any one of these characters\": <pre><code># Let's understand character classes with practical examples\ndef demonstrate_character_classes(text):\n    \"\"\"\n    Shows how different character classes work with clear examples.\n    \"\"\"\n    # Match any vowel\n    vowels = re.findall(r'[aeiou]', text)\n\n    # Match any digit\n    digits = re.findall(r'[0-9]', text)\n\n    # Match anything except vowels\n    not_vowels = re.findall(r'[^aeiou]', text)\n\n    return {\n        'vowels_found': vowels,\n        'digits_found': digits,\n        'non_vowels_found': not_vowels\n    }\n\n# Example usage\ntext = \"Python 3.9 is amazing!\"\nresults = demonstrate_character_classes(text)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#special-character-classes-shorthand-for-common-patterns","title":"Special Character Classes: Shorthand for Common Patterns","text":"<p>Python provides convenient shorthand patterns for common character classes: <pre><code># Common special character classes and their meaning\npatterns = {\n    r'\\d': 'Match any digit (equivalent to [0-9])',\n    r'\\w': 'Match any word character (letters, digits, underscore)',\n    r'\\s': 'Match any whitespace character (space, tab, newline)',\n    r'\\D': 'Match any non-digit',\n    r'\\W': 'Match any non-word character',\n    r'\\S': 'Match any non-whitespace character'\n}\n\ndef show_special_classes(text):\n    \"\"\"\n    Demonstrates how special character classes work in practice.\n    \"\"\"\n    results = {}\n    for pattern, description in patterns.items():\n        matches = re.findall(pattern, text)\n        results[pattern] = {\n            'description': description,\n            'matches': matches\n        }\n    return results\n\n# Example with multiple types of characters\ntext = \"User123 = 456! #test\"\nresults = show_special_classes(text)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#pattern-quantifiers-controlling-repetition","title":"Pattern Quantifiers: Controlling Repetition","text":"<p>Quantifiers let us specify how many times a pattern should appear. Think of them as answering the question \"how many?\": <pre><code>def explain_quantifiers(text):\n    \"\"\"\n    Demonstrates how quantifiers work with clear examples.\n    Each pattern shows a different way of specifying quantity.\n    \"\"\"\n    patterns = {\n        r'a?': 'Match 0 or 1 \"a\"',\n        r'a*': 'Match 0 or more \"a\"s',\n        r'a+': 'Match 1 or more \"a\"s',\n        r'a{3}': 'Match exactly 3 \"a\"s',\n        r'a{2,4}': 'Match 2 to 4 \"a\"s'\n    }\n\n    results = {}\n    for pattern, description in patterns.items():\n        matches = re.findall(pattern, text)\n        results[pattern] = {\n            'description': description,\n            'matches': matches\n        }\n    return results\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#understanding-search-operations","title":"Understanding Search Operations","text":"<p>Python provides several ways to search text using regex. Each serves a different purpose:</p>"},{"location":"1.Fundamentals/d_python/#match-starting-at-the-beginning","title":"match(): Starting at the Beginning","text":"<p>Think of  <code>match()</code>  as placing a ruler at the start of your text and seeing if your pattern lines up: <pre><code>def explain_match(text, pattern):\n    \"\"\"\n    Demonstrates how match() works by attempting to match a pattern\n    at the start of the text.\n    \"\"\"\n    result = re.match(pattern, text)\n    if result:\n        return {\n            'found': True,\n            'start': result.start(),\n            'end': result.end(),\n            'matched_text': result.group()\n        }\n    return {'found': False}\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#findall-collecting-all-matches","title":"findall(): Collecting All Matches","text":"<p><code>findall()</code>  comprehensively gathers all non-overlapping matches in your text: <pre><code>def demonstrate_findall(text, pattern):\n    \"\"\"\n    Shows how findall() collects all matches of a pattern.\n    Includes context for each match to better understand where they were found.\n    \"\"\"\n    matches = re.findall(pattern, text)\n    positions = [(m.start(), m.end()) for m in re.finditer(pattern, text)]\n\n    return {\n        'matches': matches,\n        'count': len(matches),\n        'positions': positions\n    }\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-regular-expressions","title":"Best Practices for Regular Expressions","text":"<ol> <li>Start Simple, Build Complexity: Begin with the simplest pattern that could work, then add complexity as needed.</li> <li>Use Readable Patterns: <pre><code># Instead of this\npattern = r'\\w+@\\w+\\.\\w+'\n\n# Use this with re.VERBOSE flag\npattern = re.compile(r\"\"\"\n    \\w+     # Username\n    @       # @ symbol\n    \\w+     # Domain name\n    \\.      # Dot\n    \\w+     # Top-level domain\n\"\"\", re.VERBOSE)\n</code></pre></li> <li>Optimize for Performance: <pre><code># Compile patterns you'll use multiple times\nemail_pattern = re.compile(r'\\w+@\\w+\\.\\w+')\n\n# Now use the compiled pattern\nemails = email_pattern.findall(text)\n</code></pre></li> <li>Test Thouroughly: <pre><code>def test_pattern(pattern, test_cases):\n    \"\"\"\n    Tests a regex pattern against multiple test cases.\n    Helps ensure the pattern works as expected.\n    \"\"\"\n    compiled_pattern = re.compile(pattern)\n    results = {}\n\n    for test in test_cases:\n        match = compiled_pattern.search(test)\n        results[test] = {\n            'matches': bool(match),\n            'value': match.group() if match else None\n        }\n\n    return results\n</code></pre> Through understanding these concepts and practicing with clear examples, you'll develop the ability to write effective and maintainable regular expressions. Remember that regex is a powerful tool, but with that power comes the responsibility to write patterns that others (including your future self) can understand and maintain.</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-object-oriented-programming-in-python","title":"Understanding Object-Oriented Programming in Python","text":""},{"location":"1.Fundamentals/d_python/#introduction-to-object-oriented-programming","title":"Introduction to Object-Oriented Programming","text":"<p>Object-oriented programming (OOP) is a powerful way to structure code that mirrors how we think about the real world. Instead of writing code as a sequence of functions that operate on data, OOP allows us to bundle related data and behaviors together into objects. Think of it this way: in the real world, objects have characteristics (like a car's color) and can perform actions (like a car's ability to drive). OOP lets us model our code the same way.</p>"},{"location":"1.Fundamentals/d_python/#building-blocks-classes-and-objects","title":"Building Blocks: Classes and Objects","text":""},{"location":"1.Fundamentals/d_python/#understanding-classes","title":"Understanding Classes","text":"<p>A class is like a blueprint that defines what properties and behaviors a particular type of object should have. Just as an architect's blueprint specifies what a house should look like but isn't itself a house, a class describes what an object should be like but isn't itself an object.</p> <p>Here's a simple example to illustrate this concept: <pre><code>class Car:\n    def __init__(self, color, model, year):\n        # Initialize the car's attributes\n        self.color = color    # The car's color property\n        self.model = model    # The car's model property\n        self.year = year      # The car's manufacturing year\n        self.is_running = False  # Track if the car is running\n\n    def start_engine(self):\n        \"\"\"Turn on the car's engine.\"\"\"\n        if not self.is_running:\n            self.is_running = True\n            return f\"The {self.color} {self.model}'s engine is now running.\"\n        return f\"The {self.color} {self.model}'s engine is already running.\"\n</code></pre> In this example, the  <code>Car</code>  class defines:</p> <ul> <li>Properties (through attributes like  <code>color</code>  and  <code>model</code>)</li> <li>Behaviors (through methods like  <code>start_engine</code>)</li> </ul>"},{"location":"1.Fundamentals/d_python/#from-classes-to-objects","title":"From Classes to Objects","text":"<p>When we create an actual object from a class, we call this instantiation. It's like using a blueprint to build an actual house: <pre><code># Creating specific car objects from our Car class\nmy_car = Car(\"blue\", \"Toyota Camry\", 2020)\nfriends_car = Car(\"red\", \"Honda Civic\", 2019)\n\n# Each car is a unique object with its own properties\nprint(my_car.color)      # Outputs: \"blue\"\nprint(friends_car.color) # Outputs: \"red\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#the-four-pillars-of-oop","title":"The Four Pillars of OOP","text":""},{"location":"1.Fundamentals/d_python/#1-encapsulation-bundling-data-and-methods","title":"1. Encapsulation: Bundling Data and Methods","text":"<p>Encapsulation is about keeping related data and methods together and hiding the internal details. Think of it like a car's engine - you don't need to know how every component works to drive the car: <pre><code>class BankAccount:\n    def __init__(self, account_holder, balance=0):\n        # Private attribute (denoted by double underscore)\n        self.__balance = balance\n        self.account_holder = account_holder\n\n    def deposit(self, amount):\n        \"\"\"Public method to safely modify the private balance.\"\"\"\n        if amount &gt; 0:\n            self.__balance += amount\n            return f\"Deposited ${amount}. New balance: ${self.__balance}\"\n        return \"Amount must be positive\"\n\n    def get_balance(self):\n        \"\"\"Safe way to access the private balance.\"\"\"\n        return self.__balance\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#2-inheritance-building-on-existing-classes","title":"2. Inheritance: Building on Existing Classes","text":"<p>Inheritance allows us to create new classes based on existing ones, just like how a hybrid car is still a car but with additional features: <pre><code>class Vehicle:\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n\n    def start(self):\n        return f\"The {self.brand} {self.model} is starting...\"\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand, model, battery_capacity):\n        # Initialize the parent class first\n        super().__init__(brand, model)\n        # Add electric car specific attributes\n        self.battery_capacity = battery_capacity\n\n    def charge(self):\n        return f\"Charging the {self.brand} {self.model}'s {self.battery_capacity}kWh battery\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#3-polymorphism-many-forms-one-interface","title":"3. Polymorphism: Many Forms, One Interface","text":"<p>Polymorphism allows different classes to implement the same method in different ways, while maintaining a consistent interface: <pre><code>class Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\nclass Duck(Animal):\n    def speak(self):\n        return \"Quack!\"\n\ndef make_animal_speak(animal):\n    \"\"\"\n    This function works with any animal class that implements speak()\n    This is polymorphism in action!\n    \"\"\"\n    return animal.speak()\n\n# Each animal speaks differently, but we can treat them the same way\nanimals = [Dog(), Cat(), Duck()]\nfor animal in animals:\n    print(make_animal_speak(animal))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#4-abstraction-simplifying-complex-reality","title":"4. Abstraction: Simplifying Complex Reality","text":"<p>Abstraction means hiding complex implementation details and showing only the necessary features: <pre><code>from abc import ABC, abstractmethod\n\nclass Database(ABC):\n    @abstractmethod\n    def connect(self):\n        \"\"\"All databases must implement a connect method.\"\"\"\n        pass\n\n    @abstractmethod\n    def query(self, sql):\n        \"\"\"All databases must implement a query method.\"\"\"\n        pass\n\nclass PostgresDatabase(Database):\n    def connect(self):\n        return \"Connected to PostgreSQL\"\n\n    def query(self, sql):\n        return f\"Executing in PostgreSQL: {sql}\"\n\nclass MongoDatabase(Database):\n    def connect(self):\n        return \"Connected to MongoDB\"\n\n    def query(self, sql):\n        return f\"Executing in MongoDB: {sql}\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-in-python-oop","title":"Best Practices in Python OOP","text":"<ol> <li>Use Clear and Descriptive Names <pre><code># Good\nclass CustomerOrder:\n    def calculate_total_price(self):\n        pass\n\n# Less clear\nclass Order:\n    def calc(self):\n        pass\n</code></pre></li> <li>Follow the Single Responsibility Principle Each class should have one primary responsibility: <pre><code># Good - Each class has a single responsibility\nclass OrderCalculator:\n    def calculate_total(self, items):\n        pass\n\nclass OrderValidator:\n    def validate(self, order):\n        pass\n\nclass OrderPersistence:\n    def save(self, order):\n        pass\n</code></pre></li> <li>Use Properties Instead of Direct Attribute Access <pre><code>class Employee:\n    def __init__(self, name, salary):\n        self._salary = salary\n        self.name = name\n\n    @property\n    def salary(self):\n        \"\"\"Protect salary access with a getter.\"\"\"\n        return self._salary\n\n    @salary.setter\n    def salary(self, value):\n        \"\"\"Validate salary before setting.\"\"\"\n        if value &lt; 0:\n            raise ValueError(\"Salary cannot be negative\")\n        self._salary = value\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-solutions_2","title":"Common Pitfalls and Solutions","text":"<ol> <li>Mutable Default Arguments <pre><code># Problematic\nclass TaskList:\n    def __init__(self, tasks=[]):  # Don't do this!\n        self.tasks = tasks\n\n# Better\nclass TaskList:\n    def __init__(self, tasks=None):\n        self.tasks = tasks if tasks is not None else []\n</code></pre></li> <li>Circular Dependencies <pre><code># Instead of tight coupling\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer  # Direct reference\n\n# Consider using identifiers\nclass Order:\n    def __init__(self, customer_id):\n        self.customer_id = customer_id  # Loose coupling\n</code></pre></li> <li>Not Using Super() in Multiple Inheritance <pre><code>class A:\n    def __init__(self):\n        print(\"A init\")\n\nclass B(A):\n    def __init__(self):\n        super().__init__()  # Always use super() for proper initialization\n        print(\"B init\")\n</code></pre> Understanding these principles and patterns will help you write more maintainable, reusable, and robust Python code. Remember that OOP is just one programming paradigm - choose it when it makes sense for your specific use case.</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-python-inheritance-a-complete-guide","title":"Understanding Python Inheritance: A Complete Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction-what-is-inheritance","title":"Introduction: What is Inheritance?","text":"<p>Inheritance is one of the core concepts that makes object-oriented programming so powerful. Think of it like genetic inheritance in families - just as children inherit traits from their parents, in programming, one class can inherit attributes and behaviors from another class.</p> <p>Let's explore this concept step by step, building our understanding from the ground up.</p>"},{"location":"1.Fundamentals/d_python/#starting-with-a-simple-example","title":"Starting with a Simple Example","text":"<p>Imagine we're modeling different types of vehicles. We'll start with a basic vehicle class and then create more specialized types: <pre><code>class Vehicle:\n    def __init__(self, brand, year):\n        # These are common attributes all vehicles share\n        self.brand = brand\n        self.year = year\n        self.is_running = False\n\n    def start_engine(self):\n        \"\"\"Turn on the vehicle.\"\"\"\n        if not self.is_running:\n            self.is_running = True\n            return f\"{self.brand} engine is now running\"\n        return f\"{self.brand} engine is already running\"\n\n    def stop_engine(self):\n        \"\"\"Turn off the vehicle.\"\"\"\n        if self.is_running:\n            self.is_running = False\n            return f\"{self.brand} engine is now stopped\"\n        return f\"{self.brand} engine is already stopped\"\n</code></pre> Now, when we want to create a more specific type of vehicle, like a car, we can inherit from the Vehicle class: <pre><code>class Car(Vehicle):\n    def __init__(self, brand, year, num_doors):\n        # First, initialize everything from the parent class\n        super().__init__(brand, year)\n        # Then add car-specific attributes\n        self.num_doors = num_doors\n        self.is_parked = True\n\n    def drive(self):\n        \"\"\"Make the car move.\"\"\"\n        if self.is_running and self.is_parked:\n            self.is_parked = False\n            return f\"{self.brand} is now driving\"\n        elif not self.is_running:\n            return f\"Please start the engine first\"\n        else:\n            return f\"{self.brand} is already driving\"\n</code></pre> Let's break down what's happening here:</p> <ol> <li>When we write  <code>class Car(Vehicle)</code>, we're saying that Car is a \"child class\" of Vehicle (the \"parent class\")</li> <li>Cars automatically get all the attributes and methods from Vehicle</li> <li>We can add new attributes and methods specific to cars</li> <li>We can also modify how inherited methods work</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-method-resolution","title":"Understanding Method Resolution","text":"<p>When you use inheritance, Python needs to know which version of a method to use. This is called method resolution. Let's see how it works: <pre><code>class ElectricCar(Car):\n    def __init__(self, brand, year, num_doors, battery_size):\n        # Initialize the car parts first\n        super().__init__(brand, year, num_doors)\n        # Add electric-specific features\n        self.battery_size = battery_size\n        self.charge_level = 100\n\n    def start_engine(self):\n        \"\"\"\n        Electric cars don't have traditional engines.\n        Override the start_engine method to reflect this.\n        \"\"\"\n        if not self.is_running:\n            self.is_running = True\n            return f\"{self.brand} motor is now humming quietly\"\n        return f\"{self.brand} motor is already running\"\n\n    def charge(self):\n        \"\"\"Charge the electric car's battery.\"\"\"\n        self.charge_level = 100\n        return f\"{self.brand} is now fully charged\"\n</code></pre> When we create these classes, we can see inheritance in action: <pre><code># Create different types of vehicles\nregular_car = Car(\"Toyota\", 2020, 4)\nelectric_car = ElectricCar(\"Tesla\", 2023, 4, 75)\n\n# Both can use Vehicle methods\nprint(regular_car.start_engine())  # \"Toyota engine is now running\"\nprint(electric_car.start_engine())  # \"Tesla motor is now humming quietly\"\n\n# Only ElectricCar has charging capability\nprint(electric_car.charge())       # \"Tesla is now fully charged\"\n# regular_car.charge()            # This would cause an error\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#multiple-inheritance-when-a-child-has-many-parents","title":"Multiple Inheritance: When a Child Has Many Parents","text":"<p>Python allows a class to inherit from multiple parent classes. Think of it like a child who learns different skills from different parents: <pre><code>class FlyingVehicle:\n    def __init__(self, max_altitude):\n        self.max_altitude = max_altitude\n        self.current_altitude = 0\n\n    def fly_to_altitude(self, altitude):\n        if altitude &lt;= self.max_altitude:\n            self.current_altitude = altitude\n            return f\"Flying to {altitude} feet\"\n        return f\"Cannot exceed maximum altitude of {self.max_altitude} feet\"\n\nclass FlyingCar(Car, FlyingVehicle):\n    def __init__(self, brand, year, num_doors, max_altitude):\n        # Initialize both parent classes\n        Car.__init__(self, brand, year, num_doors)\n        FlyingVehicle.__init__(self, max_altitude)\n\n    def switch_mode(self):\n        \"\"\"Switch between driving and flying mode.\"\"\"\n        if self.current_altitude == 0:\n            return self.fly_to_altitude(1000)\n        else:\n            self.current_altitude = 0\n            return \"Landing and switching to drive mode\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-making-inheritance-work-for-you","title":"Best Practices: Making Inheritance Work for You","text":"<ol> <li>Keep It Simple: Inheritance hierarchies should be like a family tree - clear and easy to follow. Don't make them too deep or complex. <pre><code># Too complex:\nclass A:\n    pass\nclass B(A):\n    pass\nclass C(B):\n    pass\nclass D(C):\n    pass\n\n# Better:\nclass Vehicle:\n    pass\nclass LandVehicle(Vehicle):\n    pass\nclass WaterVehicle(Vehicle):\n    pass\n</code></pre></li> <li>Use Composition When Appropriate: Sometimes it's better to have a class contain other classes rather than inherit from them: <pre><code># Instead of complex inheritance:\nclass SuperCar(Car, RadioSystem, GPSSystem, ClimateControl):\n    pass\n\n# Better to use composition:\nclass Car:\n    def __init__(self):\n        self.radio = RadioSystem()\n        self.gps = GPSSystem()\n        self.climate = ClimateControl()\n</code></pre></li> <li>Always Initialize Parent Classes: When creating a new child class, make sure to properly initialize all parent classes: <pre><code>class SmartCar(Car):\n    def __init__(self, brand, year, num_doors, ai_version):\n        # Always initialize the parent first\n        super().__init__(brand, year, num_doors)\n        # Then add new attributes\n        self.ai_version = ai_version\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#real-world-applications_1","title":"Real-World Applications","text":"<p>Let's look at a practical example of how inheritance might be used in a real application, like a game with different character types: <pre><code>class Character:\n    def __init__(self, name, health=100):\n        self.name = name\n        self.health = health\n\n    def take_damage(self, damage):\n        self.health = max(0, self.health - damage)\n        if self.health == 0:\n            return f\"{self.name} has been defeated\"\n        return f\"{self.name} took {damage} damage. Health: {self.health}\"\n\nclass Warrior(Character):\n    def __init__(self, name, weapon_type):\n        super().__init__(name, health=120)  # Warriors have more health\n        self.weapon_type = weapon_type\n        self.defense = 20\n\n    def take_damage(self, damage):\n        # Warriors reduce damage taken by their defense\n        actual_damage = max(0, damage - self.defense)\n        return super().take_damage(actual_damage)\n\nclass Mage(Character):\n    def __init__(self, name, magic_type):\n        super().__init__(name, health=80)  # Mages have less health\n        self.magic_type = magic_type\n        self.mana = 100\n\n    def cast_spell(self, spell_cost):\n        if self.mana &gt;= spell_cost:\n            self.mana -= spell_cost\n            return f\"{self.name} casts a {self.magic_type} spell\"\n        return f\"{self.name} doesn't have enough mana\"\n</code></pre> This creates a flexible system where different character types share common traits but have their own unique abilities and characteristics.</p>"},{"location":"1.Fundamentals/d_python/#understanding-methods-vs-functions-in-python-a-deep-dive","title":"Understanding Methods vs Functions in Python: A Deep Dive","text":""},{"location":"1.Fundamentals/d_python/#introduction-building-blocks-of-python","title":"Introduction: Building Blocks of Python","text":"<p>To understand the distinction between methods and functions in Python, let's start by thinking about how we organize code. Imagine you're building with LEGO blocks - functions and methods are both tools for bundling code, but they serve different purposes and belong in different contexts.</p>"},{"location":"1.Fundamentals/d_python/#functions-independent-code-blocks","title":"Functions: Independent Code Blocks","text":"<p>Think of a function as an independent worker - it can operate on its own and doesn't need to belong to anything else. Functions are like specialized tools that can work on any appropriate input they're given.</p> <p>Let's see what this looks like in practice: <pre><code>def calculate_area(length, width):\n    \"\"\"\n    A simple function that calculates the area of a rectangle.\n    This function works independently - it doesn't need to 'belong' to anything.\n    \"\"\"\n    return length * width\n\n# We can call this function directly\nroom_area = calculate_area(10, 15)\nprint(f\"The room's area is {room_area} square units\")\n</code></pre> Key characteristics of functions:</p> <ol> <li>They exist independently</li> <li>They take input parameters (though they don't have to)</li> <li>They can return values (though they don't have to)</li> <li>They're called directly by their name</li> </ol>"},{"location":"1.Fundamentals/d_python/#methods-functions-that-belong","title":"Methods: Functions That Belong","text":"<p>Methods, on the other hand, are like specialized workers that only operate within a specific factory (class). They always belong to a class and work with the data of that class. The key distinction is that methods are functions that are bound to specific objects.</p> <p>Here's an example to illustrate: <pre><code>class Rectangle:\n    def __init__(self, length, width):\n        self.length = length\n        self.width = width\n\n    def calculate_area(self):\n        \"\"\"\n        This is a method - it belongs to the Rectangle class and can access\n        the object's attributes directly through 'self'\n        \"\"\"\n        return self.length * self.width\n\n# We must create an object before we can use its methods\nmy_room = Rectangle(10, 15)\nroom_area = my_room.calculate_area()\nprint(f\"The room's area is {room_area} square units\")\n</code></pre> Notice how  <code>calculate_area</code>  as a method:</p> <ol> <li>Belongs to the Rectangle class</li> <li>Takes  <code>self</code>  as its first parameter automatically</li> <li>Can access the object's attributes directly</li> <li>Must be called on an instance of the class</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-the-key-differences","title":"Understanding the Key Differences","text":""},{"location":"1.Fundamentals/d_python/#1-context-and-belonging","title":"1. Context and Belonging","text":"<pre><code># Function - independent\ndef greet(name):\n    return f\"Hello, {name}!\"\n\n# Method - belongs to a class\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\n    def greet(self):\n        return f\"Hello, my name is {self.name}!\"\n\n# Using the function\nmessage = greet(\"Alice\")\n\n# Using the method\nperson = Person(\"Alice\")\nmessage = person.greet()\n</code></pre>"},{"location":"1.Fundamentals/d_python/#2-state-access","title":"2. State Access","text":"<p>Methods have direct access to object state through  <code>self</code>, while functions need to receive everything they need as parameters: <pre><code>class BankAccount:\n    def __init__(self, balance):\n        self.balance = balance\n\n    # Method: Can access balance directly\n    def add_interest(self):\n        self.balance *= 1.05\n        return self.balance\n\n# Function: Must receive balance as parameter\ndef calculate_interest(balance):\n    return balance * 1.05\n\n# Using the method\naccount = BankAccount(1000)\nnew_balance = account.add_interest()\n\n# Using the function\ninitial_balance = 1000\nnew_balance = calculate_interest(initial_balance)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#3-data-encapsulation","title":"3. Data Encapsulation","text":"<p>Methods help enforce encapsulation by keeping related data and behaviors together: <pre><code>class Student:\n    def __init__(self, name, grades):\n        self.name = name\n        self._grades = grades  # Protected attribute\n\n    def calculate_average(self):\n        \"\"\"\n        Method can access protected data directly and enforce business rules\n        \"\"\"\n        return sum(self._grades) / len(self._grades)\n\n# This would require passing all data explicitly as a function\ndef calculate_student_average(grades):\n    return sum(grades) / len(grades)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#choosing-between-methods-and-functions","title":"Choosing Between Methods and Functions","text":"<p>Consider using methods when:</p> <ol> <li>The behavior is intrinsically tied to some object's data</li> <li>You need to maintain and modify object state</li> <li>The functionality is part of a larger, cohesive class</li> </ol> <p>Use functions when:</p> <ol> <li>The behavior is standalone and doesn't rely on object state</li> <li>The operation is truly independent of any particular class</li> <li>You need utility functions that work across different types of objects</li> </ol>"},{"location":"1.Fundamentals/d_python/#real-world-example-data-processing","title":"Real-World Example: Data Processing","text":"<p>Here's a practical example showing when to use each: <pre><code>def validate_date_format(date_string):\n    \"\"\"\n    A function - because date validation is a standalone operation\n    that doesn't need object context\n    \"\"\"\n    import re\n    pattern = r'^\\d{4}-\\d{2}-\\d{2}$'\n    return bool(re.match(pattern, date_string))\n\nclass DataProcessor:\n    def __init__(self, data):\n        self.data = data\n        self.processed = False\n\n    def clean_data(self):\n        \"\"\"\n        A method - because it operates on the object's data\n        and maintains object state\n        \"\"\"\n        self.data = [item.strip().lower() for item in self.data]\n        self.processed = True\n\n    def get_processed_data(self):\n        \"\"\"\n        A method - because it needs to check object state\n        and access object data\n        \"\"\"\n        if not self.processed:\n            raise ValueError(\"Data must be processed first\")\n        return self.data\n\n# Using both together\ndates = [\"2023-01-01\", \"invalid-date\", \"2023-12-31\"]\nprocessor = DataProcessor(dates)\n\n# Use standalone function for validation\nvalid_dates = [date for date in dates if validate_date_format(date)]\n\n# Use methods for data processing\nprocessor.clean_data()\nprocessed_data = processor.get_processed_data()\n</code></pre> Understanding the distinction between methods and functions helps write more organized and maintainable code. Functions provide standalone utility, while methods encapsulate behavior within objects, each serving their own important purpose in Python programming.</p>"},{"location":"1.Fundamentals/d_python/#understanding-python-magic-methods-dunder-methods","title":"Understanding Python Magic Methods (Dunder Methods)","text":""},{"location":"1.Fundamentals/d_python/#introduction-the-magic-behind-python-objects","title":"Introduction: The Magic Behind Python Objects","text":"<p>Magic methods, also known as \"dunder methods\" (double underscore methods), are the special sauce that makes Python's object-oriented programming so powerful and elegant. Think of them as behind-the-scenes workers that spring into action when you perform common operations on objects. Let's explore how they work and why they're so important.</p>"},{"location":"1.Fundamentals/d_python/#what-are-magic-methods","title":"What Are Magic Methods?","text":"<p>Magic methods are special methods that Python calls automatically in response to certain operations. Their names are surrounded by double underscores (e.g.,  <code>__init__</code>), which is why they're often called \"dunder\" methods. Let's start with a simple example: <pre><code>class Book:\n    def __init__(self, title, pages):\n        self.title = title\n        self.pages = pages\n\n    def __str__(self):\n        \"\"\"This magic method determines what happens when we print the object\"\"\"\n        return f\"{self.title} ({self.pages} pages)\"\n\n    def __len__(self):\n        \"\"\"This magic method allows us to use len() on our object\"\"\"\n        return self.pages\n\n# Let's see these magic methods in action\nnovel = Book(\"The Great Gatsby\", 180)\nprint(novel)          # Calls __str__\nprint(len(novel))     # Calls __len__\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#object-lifecycle-magic-methods","title":"Object Lifecycle Magic Methods","text":""},{"location":"1.Fundamentals/d_python/#creation-and-initialization","title":"Creation and Initialization","text":"<p>When you create a new object, Python uses several magic methods to bring it to life: <pre><code>class DatabaseConnection:\n    def __new__(cls, *args, **kwargs):\n        \"\"\"Called before object creation - rarely overridden but powerful\"\"\"\n        print(\"1. Creating a new instance\")\n        return super().__new__(cls)\n\n    def __init__(self, host, port):\n        \"\"\"Called after object creation - commonly used for setup\"\"\"\n        print(\"2. Initializing the instance\")\n        self.host = host\n        self.port = port\n\n    def __del__(self):\n        \"\"\"Called when object is being garbage collected\"\"\"\n        print(\"3. Cleaning up database connection\")\n\n# Watch the lifecycle in action\nconnection = DatabaseConnection(\"localhost\", 5432)\ndel connection\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#operator-magic-methods","title":"Operator Magic Methods","text":"<p>Magic methods allow objects to respond to Python's standard operators. This makes our code more intuitive and readable: <pre><code>class Money:\n    def __init__(self, dollars):\n        self.dollars = dollars\n\n    def __add__(self, other):\n        \"\"\"Enables the + operator between Money objects\"\"\"\n        if isinstance(other, Money):\n            return Money(self.dollars + other.dollars)\n        return NotImplemented\n\n    def __lt__(self, other):\n        \"\"\"Enables the &lt; operator for comparing Money objects\"\"\"\n        if isinstance(other, Money):\n            return self.dollars &lt; other.dollars\n        return NotImplemented\n\n    def __str__(self):\n        return f\"${self.dollars:.2f}\"\n\n# Now we can use natural operations with our Money objects\nwallet = Money(50)\nsavings = Money(1000)\ntotal = wallet + savings\nprint(f\"Total money: {total}\")\nprint(f\"Is wallet less than savings? {wallet &lt; savings}\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#container-and-sequence-magic-methods","title":"Container and Sequence Magic Methods","text":"<p>These methods allow objects to behave like Python's built-in containers (lists, dictionaries, etc.): <pre><code>class Playlist:\n    def __init__(self, songs):\n        self._songs = songs\n\n    def __getitem__(self, index):\n        \"\"\"Enables indexing and iteration\"\"\"\n        return self._songs[index]\n\n    def __len__(self):\n        \"\"\"Enables len() function\"\"\"\n        return len(self._songs)\n\n    def __contains__(self, song):\n        \"\"\"Enables 'in' operator\"\"\"\n        return song in self._songs\n\n# Using our playlist like a container\nmy_playlist = Playlist([\"Song1\", \"Song2\", \"Song3\"])\nprint(f\"First song: {my_playlist[0]}\")\nprint(f\"Number of songs: {len(my_playlist)}\")\nprint(f\"Is 'Song2' in playlist? {'Song2' in my_playlist}\")\n\n# We can even iterate over it!\nfor song in my_playlist:\n    print(f\"Playing: {song}\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#context-manager-magic-methods","title":"Context Manager Magic Methods","text":"<p>These methods enable the  <code>with</code>  statement for safe resource management: <pre><code>class FileLogger:\n    def __init__(self, filename):\n        self.filename = filename\n\n    def __enter__(self):\n        \"\"\"Called when entering 'with' block\"\"\"\n        print(f\"Opening {self.filename}\")\n        self.file = open(self.filename, 'w')\n        return self  # This is what gets assigned to the 'as' variable\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Called when exiting 'with' block, even if an error occurred\"\"\"\n        print(f\"Closing {self.filename}\")\n        self.file.close()\n        # Return True to suppress any exceptions, False to propagate them\n        return False\n\n# Using our context manager\nwith FileLogger(\"app.log\") as logger:\n    logger.file.write(\"Application started\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#attribute-access-magic-methods","title":"Attribute Access Magic Methods","text":"<p>These methods give you control over how attributes are accessed and modified: <pre><code>class ProtectedDict:\n    def __init__(self):\n        self._data = {}\n\n    def __getattr__(self, name):\n        \"\"\"Called when an attribute isn't found normally\"\"\"\n        if name in self._data:\n            return self._data[name]\n        raise AttributeError(f\"No such attribute: {name}\")\n\n    def __setattr__(self, name, value):\n        \"\"\"Called when setting any attribute\"\"\"\n        if name == \"_data\":\n            # Allow setting the internal dictionary\n            super().__setattr__(name, value)\n        else:\n            # Store other attributes in our protected dictionary\n            self._data[name] = value\n\n# Using our protected dictionary\nconfig = ProtectedDict()\nconfig.api_key = \"secret123\"  # Calls __setattr__\nprint(config.api_key)         # Calls __getattr__\n</code></pre> Magic methods, also known as \"dunder methods\" (double underscore methods), are the special sauce that makes Python's object-oriented programming so powerful and elegant. Think of them as behind-the-scenes workers that spring into action when you perform common operations on objects. Let's explore how they work and why they're so important.</p>"},{"location":"1.Fundamentals/d_python/#what-are-magic-methods_1","title":"What Are Magic Methods?","text":"<p>Magic methods are special methods that Python calls automatically in response to certain operations. Their names are surrounded by double underscores (e.g.,  <code>__init__</code>), which is why they're often called \"dunder\" methods. Let's start with a simple example:</p> <p>python</p> <p>Copy</p> <p><code>class  Book:   def  __init__(self, title, pages): self.title = title self.pages = pages  def  __str__(self): \"\"\"This magic method determines what happens when we print the object\"\"\" return  f\"{self.title} ({self.pages} pages)\"  def  __len__(self): \"\"\"This magic method allows us to use len() on our object\"\"\" return self.pages   # Let's see these magic methods in action novel = Book(\"The Great Gatsby\",  180) print(novel)  # Calls __str__ print(len(novel))  # Calls __len__</code></p>"},{"location":"1.Fundamentals/d_python/#object-lifecycle-magic-methods_1","title":"Object Lifecycle Magic Methods","text":""},{"location":"1.Fundamentals/d_python/#creation-and-initialization_1","title":"Creation and Initialization","text":"<p>When you create a new object, Python uses several magic methods to bring it to life:</p> <p>python</p> <p>Copy</p> <p><code>class  DatabaseConnection:   def  __new__(cls,  *args,  **kwargs): \"\"\"Called before object creation - rarely overridden but powerful\"\"\" print(\"1. Creating a new instance\") return  super().__new__(cls)  def  __init__(self, host, port): \"\"\"Called after object creation - commonly used for setup\"\"\" print(\"2. Initializing the instance\") self.host = host self.port = port  def  __del__(self): \"\"\"Called when object is being garbage collected\"\"\" print(\"3. Cleaning up database connection\")   # Watch the lifecycle in action connection = DatabaseConnection(\"localhost\",  5432) del connection</code></p>"},{"location":"1.Fundamentals/d_python/#operator-magic-methods_1","title":"Operator Magic Methods","text":"<p>Magic methods allow objects to respond to Python's standard operators. This makes our code more intuitive and readable:</p> <p>python</p> <p>Copy</p> <p><code>class  Money:   def  __init__(self, dollars): self.dollars = dollars  def  __add__(self, other): \"\"\"Enables the + operator between Money objects\"\"\" if  isinstance(other, Money): return Money(self.dollars + other.dollars) return NotImplemented  def  __lt__(self, other): \"\"\"Enables the &lt; operator for comparing Money objects\"\"\" if  isinstance(other, Money): return self.dollars &lt; other.dollars return NotImplemented  def  __str__(self): return  f\"${self.dollars:.2f}\"   # Now we can use natural operations with our Money objects wallet = Money(50) savings = Money(1000) total = wallet + savings print(f\"Total money: {total}\") print(f\"Is wallet less than savings? {wallet &lt; savings}\")</code></p>"},{"location":"1.Fundamentals/d_python/#container-and-sequence-magic-methods_1","title":"Container and Sequence Magic Methods","text":"<p>These methods allow objects to behave like Python's built-in containers (lists, dictionaries, etc.):</p> <p>python</p> <p>Copy</p> <p><code>class  Playlist:   def  __init__(self, songs): self._songs = songs  def  __getitem__(self, index): \"\"\"Enables indexing and iteration\"\"\" return self._songs[index]  def  __len__(self): \"\"\"Enables len() function\"\"\" return  len(self._songs)  def  __contains__(self, song): \"\"\"Enables 'in' operator\"\"\" return song in self._songs   # Using our playlist like a container my_playlist = Playlist([\"Song1\",  \"Song2\",  \"Song3\"]) print(f\"First song: {my_playlist[0]}\") print(f\"Number of songs: {len(my_playlist)}\") print(f\"Is 'Song2' in playlist? {'Song2'  in my_playlist}\")   # We can even iterate over it! for song in my_playlist:   print(f\"Playing: {song}\")</code></p>"},{"location":"1.Fundamentals/d_python/#context-manager-magic-methods_1","title":"Context Manager Magic Methods","text":"<p>These methods enable the  <code>with</code>  statement for safe resource management:</p> <p>python</p> <p>Copy</p> <p><code>class  FileLogger:   def  __init__(self, filename): self.filename = filename  def  __enter__(self): \"\"\"Called when entering 'with' block\"\"\" print(f\"Opening {self.filename}\") self.file  =  open(self.filename,  'w') return self # This is what gets assigned to the 'as' variable  def  __exit__(self, exc_type, exc_val, exc_tb): \"\"\"Called when exiting 'with' block, even if an error occurred\"\"\" print(f\"Closing {self.filename}\") self.file.close() # Return True to suppress any exceptions, False to propagate them return  False   # Using our context manager with FileLogger(\"app.log\")  as logger:   logger.file.write(\"Application started\")</code></p>"},{"location":"1.Fundamentals/d_python/#attribute-access-magic-methods_1","title":"Attribute Access Magic Methods","text":"<p>These methods give you control over how attributes are accessed and modified:</p> <p>python</p> <p>Copy</p> <p><code>class  ProtectedDict:   def  __init__(self): self._data =  {}  def  __getattr__(self, name): \"\"\"Called when an attribute isn't found normally\"\"\" if name in self._data: return self._data[name] raise AttributeError(f\"No such attribute: {name}\")  def  __setattr__(self, name, value): \"\"\"Called when setting any attribute\"\"\" if name ==  \"_data\": # Allow setting the internal dictionary super().__setattr__(name, value) else: # Store other attributes in our protected dictionary self._data[name]  = value   # Using our protected dictionary config = ProtectedDict() config.api_key =  \"secret123\"  # Calls __setattr__ print(config.api_key)  # Calls __getattr__</code></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-patterns_2","title":"Best Practices and Common Patterns","text":"<ol> <li>Always call superclass magic methods when inheriting: <pre><code>class ChildClass(ParentClass):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Additional initialization here\n</code></pre></li> <li>Return NotImplemented for unsupported operations: <pre><code>def __add__(self, other):\n    if isinstance(other, compatible_type):\n        # Perform addition\n        return result\n    return NotImplemented\n</code></pre></li> <li>Keep magic methods focused and simple: <pre><code>def __str__(self):\n    \"\"\"Keep string representations clear and concise\"\"\"\n    return f\"{self.__class__.__name__}(value={self.value})\"\n</code></pre> Magic methods make Python's syntax elegant and expressive. By understanding and using them appropriately, you can create classes that integrate seamlessly with Python's built-in operations and feel natural to use.</li> </ol>"},{"location":"1.Fundamentals/d_python/#understanding-python-build-systems-and-package-distribution-a-developers-guide","title":"Understanding Python Build Systems and Package Distribution: A Developer's Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction-the-evolution-of-python-packaging","title":"Introduction: The Evolution of Python Packaging","text":"<p>When Python was first created in 1991, sharing code between developers wasn't a primary concern. The internet was in its infancy, and most programs lived in isolation on individual computers. As Python grew in popularity, the need to share code efficiently became increasingly important. Let's explore how Python's packaging ecosystem evolved to meet this need and understand how we can effectively use modern build systems today.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts-what-is-a-python-package","title":"Core Concepts: What Is a Python Package?","text":"<p>Before diving into build systems, let's understand what we're actually building. A Python package is more than just Python files - it's a structured way to distribute code that:</p> <ol> <li>Contains Python modules (<code>.py</code>  files)</li> <li>May include additional resources (configuration files, data, etc.)</li> <li>Specifies its dependencies</li> <li>Provides metadata about itself</li> </ol> <p>Think of a package like a well-organized suitcase - everything is properly arranged, labeled, and ready for travel. The build system is like the person packing that suitcase, making sure everything is included and organized correctly.</p>"},{"location":"1.Fundamentals/d_python/#understanding-build-systems","title":"Understanding Build Systems","text":"<p>A build system in Python serves as the bridge between your development environment and the distributed package. It performs several crucial functions: <pre><code># Example of what a build system does behind the scenes:\n\nclass BuildSystem:\n    def collect_source_files(self):\n        \"\"\"Gather all relevant Python files and resources\"\"\"\n        # Find all .py files\n        # Include specified resource files\n        # Handle package data\n        pass\n\n    def validate_metadata(self):\n        \"\"\"Ensure all required package information is present\"\"\"\n        # Check package name\n        # Verify version number\n        # Validate dependencies\n        pass\n\n    def create_distribution(self):\n        \"\"\"Create distributable package formats\"\"\"\n        # Build source distribution (.tar.gz)\n        # Create wheel distribution (.whl)\n        pass\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#the-three-major-build-systems","title":"The Three Major Build Systems","text":"<p>Let's look at the three most popular build systems and understand their unique approaches:</p>"},{"location":"1.Fundamentals/d_python/#1-setuptools-the-traditional-approach","title":"1. Setuptools: The Traditional Approach","text":"<p>Setuptools has been the standard build system for Python packages for many years. It's like a Swiss Army knife - very capable but sometimes complex: <pre><code># pyproject.toml using setuptools\n[build-system]\nrequires = [\"setuptools&gt;=61.0.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"your-package\"\nversion = \"1.0.0\"\ndependencies = [\n    \"requests&gt;=2.25.0\",\n    \"pandas&gt;=1.2.0\"\n]\n</code></pre> Key characteristics:</p> <ul> <li>Extensive configuration options</li> <li>Strong backward compatibility</li> <li>Handles complex build scenarios</li> <li>Well-documented but can be overwhelming</li> </ul> <p>Reference: https://pypi.org/project/setuptools/</p>"},{"location":"1.Fundamentals/d_python/#2-flit-the-minimalist-choice","title":"2. Flit: The Minimalist Choice","text":"<p>Flit takes a \"convention over configuration\" approach, making simple cases very simple: <pre><code># pyproject.toml using Flit\n[build-system]\nrequires = [\"flit_core&gt;=3.4.0\"]\nbuild-backend = \"flit_core.buildapi\"\n\n[project]\nname = \"your-package\"\nversion = \"1.0.0\"\ndescription = \"A simple package\"\n</code></pre> Think of Flit like a minimalist's backpack - it carries what you need without extra pockets and zippers:</p> <ul> <li>Focuses on Python-only packages</li> <li>Minimal configuration required</li> <li>Automatic metadata discovery</li> <li>Built-in publishing tools Reference: https://flit.pypa.io/en/stable/</li> </ul>"},{"location":"1.Fundamentals/d_python/#3-poetry-the-modern-alternative","title":"3. Poetry: The Modern Alternative","text":"<p>Poetry combines dependency management with build tools, providing a more comprehensive development experience: <pre><code># pyproject.toml using Poetry\n[tool.poetry]\nname = \"your-package\"\nversion = \"1.0.0\"\ndescription = \"A modern Python package\"\n\n[tool.poetry.dependencies]\npython = \"^3.8\"\nrequests = \"^2.25.0\"\n\n[build-system]\nrequires = [\"poetry-core&gt;=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"\n</code></pre> Poetry is like an integrated development environment for package management:</p> <ul> <li>Built-in dependency resolution</li> <li>Virtual environment management</li> <li>Lock file for reproducible builds</li> <li>Modern CLI interface</li> </ul>"},{"location":"1.Fundamentals/d_python/#making-the-right-choice","title":"Making the Right Choice","text":"<p>To choose the right build system, consider these factors:</p>"},{"location":"1.Fundamentals/d_python/#1-project-complexity","title":"1. Project Complexity","text":"<pre><code>def assess_project_complexity():\n    \"\"\"Guide for choosing a build system based on project complexity\"\"\"\n    if is_simple_python_package():\n        return \"Consider Flit - it's simple and straightforward\"\n    elif needs_complex_build_steps():\n        return \"Use Setuptools - it handles complex cases well\"\n    elif want_modern_workflow():\n        return \"Try Poetry - it provides an integrated experience\"\n</code></pre>"},{"location":"1.Fundamentals/d_python/#2-development-workflow","title":"2. Development Workflow","text":"<p>Consider how your team works:</p> <ul> <li>Setuptools is familiar to most Python developers</li> <li>Poetry provides excellent dependency management</li> <li>Flit is perfect for simple, straightforward packages</li> </ul>"},{"location":"1.Fundamentals/d_python/#3-package-distribution-requirements","title":"3. Package Distribution Requirements","text":"<p>Different build systems handle distribution differently: <pre><code>class DistributionNeeds:\n    def source_distribution(self):\n        \"\"\"All build systems handle this well\"\"\"\n        return True\n\n    def wheel_distribution(self):\n        \"\"\"All modern build systems create wheels\"\"\"\n        return True\n\n    def binary_extensions(self):\n        \"\"\"Complex C extensions? Consider Setuptools\"\"\"\n        return \"Setuptools recommended\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-any-build-system","title":"Best Practices for Any Build System","text":"<p>Regardless of which build system you choose, follow these principles:</p> <ol> <li>Use pyproject.toml <pre><code># Modern Python packaging standard\n[build-system]\n# Specify your build system here\n\n[project]\n# Project metadata goes here\n</code></pre></li> <li>Version Your Dependencies Wisely <pre><code># Good - Specify minimum versions\ndependencies = [\n    \"requests&gt;=2.25.0\",\n    \"pandas&gt;=1.2.0\"\n]\n\n# Better - Specify compatible versions\ndependencies = [\n    \"requests&gt;=2.25.0,&lt;3.0.0\",\n    \"pandas&gt;=1.2.0,&lt;2.0.0\"\n]\n</code></pre></li> <li>Include Comprehensive Metadata <pre><code>[project]\nname = \"your-package\"\nversion = \"1.0.0\"\ndescription = \"Clear, concise description\"\nreadme = \"README.md\"\nauthors = [{name = \"Your Name\", email = \"you@example.com\"}]\nlicense = {text = \"MIT\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\"\n]\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-solutions_3","title":"Common Pitfalls and Solutions","text":"<ol> <li>Dependency Conflicts <pre><code># Problem: Incompatible version requirements\n# Solution: Use dependency groups\n\n[tool.poetry.dependencies]\nrequests = \"^2.25.0\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^7.0.0\"\n</code></pre></li> <li>Resource Files <pre><code># Problem: Missing package data\n# Solution: Include manifest\n\n[tool.setuptools.package-data]\nmy_package = [\"*.json\", \"data/*.csv\"]\n</code></pre></li> <li>Version Management <pre><code># Use a single source of truth for versions\n# In your package's __init__.py:\n__version__ = \"1.0.0\"\n\n# Reference it in pyproject.toml:\n[tool.poetry]\nversion = { attr = \"my_package.__version__\" }\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#testing-your-build","title":"Testing Your Build","text":"<p>Always test your build before publishing: <pre><code># Build your package\npython -m build\n\n# Check the contents of your wheel\nunzip -l dist/*.whl\n\n# Try installing locally\npip install dist/*.whl\n\n# Verify import works\npython -c \"import your_package; print(your_package.__version__)\"\n</code></pre> Understanding build systems is crucial for modern Python development. While they may seem complex at first, they solve real problems in code distribution and make sharing your work with others much easier.</p> <p>Reference: https://python-poetry.org</p>"},{"location":"1.Fundamentals/d_python/#understanding-pythons-pip-package-manager-a-complete-guide","title":"Understanding Python's pip Package Manager: A Complete Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction-why-package-management-matters","title":"Introduction: Why Package Management Matters","text":"<p>Imagine you're building a house. While you could theoretically create every component from scratch - from nails to windows to electrical systems - it would be impractical. Instead, you rely on pre-made components and materials. Python packages work the same way: they're pre-built components that you can use in your projects. The pip package manager is your tool for finding, installing, and managing these components.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts_3","title":"Core Concepts","text":""},{"location":"1.Fundamentals/d_python/#what-is-pip","title":"What is pip?","text":"<p>pip is Python's standard package manager - it's the tool that connects your project to the vast ecosystem of Python packages. The name \"pip\" stands for \"pip installs packages\" (a recursive acronym). Think of pip as your personal assistant that:</p> <ol> <li>Finds the packages you need from package repositories</li> <li>Downloads and installs them correctly</li> <li>Manages version compatibility</li> <li>Keeps track of what's installed</li> <li>Removes packages when they're no longer needed</li> </ol>"},{"location":"1.Fundamentals/d_python/#package-repositories-and-pypi","title":"Package Repositories and PyPI","text":"<p>Most pip operations involve PyPI (the Python Package Index), which is like a massive library of Python packages. When you ask pip to install something, here's what happens behind the scenes: <pre><code># What happens when you run: pip install requests\n\ndef conceptual_pip_install(package_name):\n    \"\"\"This illustrates pip's internal workflow\"\"\"\n    # 1. Check PyPI for the package\n    package = search_pypi(package_name)\n\n    # 2. Analyze dependencies\n    dependencies = resolve_dependencies(package)\n\n    # 3. Download all needed files\n    files = download_files(package, dependencies)\n\n    # 4. Install everything in the right order\n    install_order = determine_installation_order(dependencies)\n    for component in install_order:\n        install_component(component)\n\n    # 5. Update package database\n    update_installed_packages_list()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#essential-pip-commands","title":"Essential pip Commands","text":""},{"location":"1.Fundamentals/d_python/#installation-and-setup","title":"Installation and Setup","text":"<p>First, let's ensure pip is working correctly in your environment: <pre><code># Check pip installation\npython -m pip --version\n\n# Update pip itself\npython -m pip install --upgrade pip\n</code></pre> Always use  <code>python -m pip</code>  instead of just  <code>pip</code>  - this ensures you're using the pip associated with your current Python installation.</p>"},{"location":"1.Fundamentals/d_python/#installing-packages","title":"Installing Packages","text":"<p>There are several ways to install packages, each serving different needs: <pre><code># Basic installation\npython -m pip install requests\n\n# Install specific version\npython -m pip install requests==2.25.0\n\n# Install minimum version\npython -m pip install \"requests&gt;=2.25.0\"\n\n# Install from requirements file\npython -m pip install -r requirements.txt\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#understanding-version-specifiers","title":"Understanding Version Specifiers","text":"<p>Version specifiers tell pip exactly which versions of a package are acceptable: <pre><code># Version specifier meanings\npackage==2.25.0    # Exactly version 2.25.0\npackage&gt;=2.25.0    # Version 2.25.0 or higher\npackage&lt;=2.25.0    # Version 2.25.0 or lower\npackage~=2.25.0    # Version 2.25.* but not 2.26\npackage!=2.25.0    # Any version except 2.25.0\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#working-with-virtual-environments","title":"Working with Virtual Environments","text":"<p>Virtual environments are isolated Python installations - think of them as separate workspaces for different projects. Here's how to use them with pip: <pre><code># Create new virtual environment\npython -m venv myproject_env\n\n# Activate it (on Windows)\nmyproject_env\\Scripts\\activate\n\n# Activate it (on Unix/MacOS)\nsource myproject_env/bin/activate\n\n# Install packages in virtual environment\npython -m pip install requests\n\n# Create requirements file\npython -m pip freeze &gt; requirements.txt\n</code></pre> The requirements file captures your project's dependencies: <pre><code># requirements.txt\nrequests==2.28.1\nurllib3==1.26.12\ncertifi==2022.9.24\ncharset-normalizer==2.1.1\nidna==3.4\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#managing-dependencies","title":"Managing Dependencies","text":""},{"location":"1.Fundamentals/d_python/#understanding-dependency-resolution","title":"Understanding Dependency Resolution","text":"<p>When you install a package, pip needs to figure out all the other packages it needs: <pre><code># Conceptual model of dependency resolution\ndef resolve_dependencies(package):\n    \"\"\"Shows how pip thinks about dependencies\"\"\"\n    direct_deps = package.get_dependencies()\n    all_deps = set()\n\n    for dep in direct_deps:\n        # Check if this version works with existing deps\n        if is_compatible(dep, all_deps):\n            all_deps.add(dep)\n            # Recursively resolve this dep's dependencies\n            all_deps.update(resolve_dependencies(dep))\n        else:\n            # Handle version conflicts\n            resolve_conflict(dep, all_deps)\n\n    return all_deps\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-for-dependency-management","title":"Best Practices for Dependency Management","text":"<ol> <li>Use Virtual Environments  Always work in virtual environments to keep projects isolated.</li> <li>Specify Version Ranges Carefully <pre><code># Good - Allows compatible updates\nrequests&gt;=2.25.0,&lt;3.0.0\n\n# Risky - Any version might break things\nrequests\n\n# Too strict - Misses bug fixes\nrequests==2.25.0\n</code></pre></li> <li>Separate Development and Production Dependencies <pre><code># requirements.txt - Production dependencies\nrequests==2.28.1\nurllib3==1.26.12\n\n# requirements-dev.txt - Additional development tools\npytest&gt;=7.0.0\nblack&gt;=22.0.0\n-r requirements.txt  # Include production deps\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"1.Fundamentals/d_python/#version-conflicts","title":"Version Conflicts","text":"<p>When pip reports a version conflict, understand what it's telling you: <pre><code>ERROR: Cannot install package_a and package_b because these package versions have conflicting dependencies.\n</code></pre> This means:</p> <ol> <li>package_a needs a specific version of a dependency</li> <li>package_b needs a different version of the same dependency</li> <li>These versions are incompatible</li> </ol> <p>Resolution steps:</p> <ol> <li>Check which versions of each package work together</li> <li>Consider upgrading/downgrading one package</li> <li>Look for alternative packages that don't conflict</li> </ol>"},{"location":"1.Fundamentals/d_python/#installation-failures","title":"Installation Failures","text":"<p>When installation fails, follow this debugging process:</p> <ol> <li>Check Python Version Compatibility <pre><code>python --version\npython -m pip show package_name\n</code></pre></li> <li>Verify Network Connection <pre><code># Test PyPI connectivity\npython -m pip install --index-url https://pypi.org/simple/ pip\n</code></pre></li> <li>Check for System Dependencies Some packages require system-level libraries. Read the package's documentation for requirements.</li> </ol>"},{"location":"1.Fundamentals/d_python/#advanced-pip-features","title":"Advanced pip Features","text":""},{"location":"1.Fundamentals/d_python/#using-alternative-package-indexes","title":"Using Alternative Package Indexes","text":"<pre><code># Use a different package index\npython -m pip install --index-url https://test.pypi.org/simple/ some-package\n\n# Add an extra index\npython -m pip install --extra-index-url https://my-index.org/simple/ some-package\n</code></pre>"},{"location":"1.Fundamentals/d_python/#installing-from-source-control","title":"Installing From Source Control","text":"<pre><code># Install from Git repository\npython -m pip install git+https://github.com/user/project.git\n\n# Install specific branch/tag\npython -m pip install git+https://github.com/user/project.git@branch_name\n</code></pre>"},{"location":"1.Fundamentals/d_python/#development-mode-installation","title":"Development Mode Installation","text":"<p>When developing packages, use editable mode: <pre><code># Install in editable mode\npython -m pip install -e .\n\n# This creates a link instead of copying files,\n# so your changes are immediately reflected\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#security-considerations","title":"Security Considerations","text":"<ol> <li>Verify Package Sources<ul> <li>Only install from trusted sources</li> <li>Use  <code>--require-hashes</code>  for additional security</li> <li>Check package signatures when available</li> </ul> </li> <li>Keep Packages Updated <pre><code># Check for outdated packages\npython -m pip list --outdated\n\n# Update packages\npython -m pip install --upgrade package_name\n</code></pre></li> <li>Audit Dependencies <pre><code># Use safety to check for known vulnerabilities\npython -m pip install safety\nsafety check\n</code></pre> Understanding pip deeply helps you manage Python projects more effectively and avoid common pitfalls. Remember that pip is just a tool - the key is understanding what you're trying to achieve and using pip appropriately to reach those goals. Reference: https://pypi.org/project/pip/</li> </ol>"},{"location":"1.Fundamentals/d_python/#common-packages-and-modules","title":"Common Packages and Modules","text":"<p>Python has a rich ecosystem of packages and modules that can be used to get the most out of the language. A package is essentially a directory that contains multiple modules and subpackages. A module is a single file that contains a collection of related functions, classes, and variables. Modules are the basic building blocks of Python code organization. A module can be thought of as a container that holds a set of related code.</p> <p>Visit the following resources to learn more: -   Official requests: Used for making HTTP requests - it lets your Python code talk to web services and APIs in a simple way. Instead of dealing with complex networking code, you can fetch web pages or send data with just a few lines of code. Think of it as Python's way of browsing the web. -   Official pathlib: Modernizes how Python handles file paths. Rather than working with raw strings for file paths, it provides Path objects that understand the rules of different operating systems. It's like having a smart assistant that knows how to properly write and manipulate file paths whether you're on Windows, Mac, or Linux. -   Official asyncio: Is Python's built-in tool for writing concurrent code. It lets your program do multiple things at once without getting stuck waiting for slow operations like network requests or file operations. Imagine a chef who can start cooking multiple dishes at once instead of completing one dish at a time. -   Official dataclasses: Simplifies creating classes that mainly hold data. Instead of writing lots of boilerplate code to initialize attributes and represent your objects, dataclasses automatically generates this code for you. It's like having a secretary who handles all the repetitive paperwork so you can focus on the important stuff. -   Official python-dotenv: helps manage configuration variables in your applications by loading them from a .env file. This keeps sensitive information like API keys separate from your code. Think of it as a secure notepad that stores your application's secrets. -   Official numpy: This is the foundation for scientific computing in Python. It provides powerful tools for working with large arrays and matrices of numerical data, along with mathematical functions to analyze this data. It's like a high-powered calculator that can work with huge amounts of numbers at once. -   Official pandas: Builds on numpy to provide tools specifically designed for data analysis. It introduces DataFrames, which are like Excel spreadsheets in Python, making it easy to work with structured data. Think of it as a data analyst's Swiss Army knife - it can load, clean, analyze, and transform data in many different ways.</p>"},{"location":"1.Fundamentals/d_python/#pyprojecttoml","title":"pyproject.toml","text":"<p>This file is used to define the project configuration and dependencies. It is a configuration file that contains metadata about the project, such as its name, version, dependencies, and build settings. The  <code>pyproject.toml</code>  file is used by tools like  <code>poetry</code>  and  <code>flit</code>  to manage Python projects and their dependencies.</p> <p>Learn more from the following resources: Official pyproject.toml</p>"},{"location":"1.Fundamentals/d_python/#understanding-python-list-comprehensions-a-developers-guide","title":"Understanding Python List Comprehensions: A Developer's Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction-what-are-list-comprehensions","title":"Introduction: What Are List Comprehensions?","text":"<p>List comprehensions are a powerful feature in Python that allows you to create lists in a clear, concise way. Think of them as a recipe for building a list - you specify what each element should be and what conditions it needs to meet. Let's explore how they work and why they're so useful.</p>"},{"location":"1.Fundamentals/d_python/#the-basic-pattern","title":"The Basic Pattern","text":"<p>At its simplest, a list comprehension follows this pattern: <pre><code>[expression for item in iterable]\n</code></pre> Let's break this down:</p> <ul> <li>The  <code>expression</code>  determines what goes into our new list</li> <li>The  <code>for item in iterable</code>  part determines where we get our values from</li> <li>Everything is wrapped in square brackets  <code>[]</code>  to create a list</li> </ul> <p>Here's a concrete example: <pre><code># Instead of writing this:\nsquares = []\nfor number in range(5):\n    squares.append(number * number)\n\n# We can write this:\nsquares = [number * number for number in range(5)]\nprint(squares)  # Output: [0, 1, 4, 9, 16]\n</code></pre> Think of this like giving Python a recipe: \"For each number in range(5), multiply it by itself and put that in the list.\"</p>"},{"location":"1.Fundamentals/d_python/#building-understanding-with-simple-examples","title":"Building Understanding with Simple Examples","text":"<p>Let's start with some straightforward examples to build our intuition: <pre><code># Creating a list of strings\nnames = [\"alice\", \"bob\", \"charlie\"]\nupper_names = [name.upper() for name in names]\n# Result: [\"ALICE\", \"BOB\", \"CHARLIE\"]\n\n# Converting temperatures from Celsius to Fahrenheit\ncelsius = [0, 10, 20, 30]\nfahrenheit = [(9/5 * temp + 32) for temp in celsius]\n# Result: [32.0, 50.0, 68.0, 86.0]\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#adding-conditions-with-if-statements","title":"Adding Conditions with if Statements","text":"<p>Sometimes we only want certain items in our new list. We can add conditions using  <code>if</code>: <pre><code>numbers = [1, 2, 3, 4, 5, 6]\n# Get only even numbers\neven_numbers = [num for num in numbers if num % 2 == 0]\nprint(even_numbers)  # Output: [2, 4, 6]\n\n# A more practical example: getting active users\nusers = [\n    {\"name\": \"Alice\", \"active\": True},\n    {\"name\": \"Bob\", \"active\": False},\n    {\"name\": \"Charlie\", \"active\": True}\n]\nactive_users = [user[\"name\"] for user in users if user[\"active\"]]\nprint(active_users)  # Output: [\"Alice\", \"Charlie\"]\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#using-if-else-for-transformations","title":"Using if-else for Transformations","text":"<p>We can also use conditional expressions (if-else) to transform values: <pre><code>numbers = [1, 2, 3, 4, 5]\n# Replace odd numbers with 'odd' and even numbers with 'even'\nnumber_types = ['even' if num % 2 == 0 else 'odd' for num in numbers]\nprint(number_types)  # Output: ['odd', 'even', 'odd', 'even', 'odd']\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#nested-list-comprehensions","title":"Nested List Comprehensions","text":"<p>Like nesting dolls, we can nest list comprehensions inside each other: <pre><code># Creating a 3x3 matrix of zeros\nmatrix = [[0 for col in range(3)] for row in range(3)]\nprint(matrix)  # Output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n\n# Flattening a matrix (converting 2D to 1D)\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflattened = [num for row in matrix for num in row]\nprint(flattened)  # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-pitfalls_1","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/d_python/#when-to-use-list-comprehensions","title":"When to Use List Comprehensions","text":"<p>List comprehensions are great when:</p> <ol> <li>You're creating a new list based on some existing iterable</li> <li>The transformation logic is simple and clear</li> <li>You want to filter elements based on a simple condition <pre><code># Good use of list comprehension - clear and simple\nwords = [\"hello\", \"world\", \"python\"]\nlengths = [len(word) for word in words]\n\n# Better as a regular loop - complex logic\ndef complex_transform(x):\n    # Imagine this is a complex calculation\n    return x * x if x &gt; 0 else -x\n\n# Too complex for a list comprehension\nresults = []\nfor x in numbers:\n    try:\n        result = complex_transform(x)\n        if result &gt; 0:\n            results.append(result)\n    except ValueError:\n        continue\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ol> <li>Making comprehensions too complex <pre><code># Bad - too complex and hard to read\nmatrix = [[sum(x * y for x in range(3)) for y in range(3)] for z in range(2)]\n\n# Better - break it down into smaller steps\ndef calculate_row(y):\n    return [sum(x * y for x in range(3))]\nmatrix = [calculate_row(y) for y in range(3)]\n</code></pre></li> <li>Using comprehensions for side effects <pre><code># Bad - using comprehension just for side effects\n[print(x) for x in range(5)]\n\n# Better - use a regular for loop\nfor x in range(5):\n    print(x)\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#performance-considerations_1","title":"Performance Considerations","text":"<p>List comprehensions are often more efficient than equivalent for loops because:</p> <ol> <li>They're optimized by Python's interpreter</li> <li>They avoid appending to a list repeatedly</li> <li>They create the list in one go</li> </ol> <p>However, be mindful of memory usage with large lists: <pre><code># This could use a lot of memory with large numbers\nbig_list = [x * x for x in range(1000000)]\n\n# Better to use a generator expression for large sequences\n# This creates values one at a time instead of all at once\nbig_gen = (x * x for x in range(1000000))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#real-world-examples","title":"Real-World Examples","text":"<p>Let's look at some practical applications: <pre><code># Data cleaning: Converting strings to numbers and filtering out invalid values\nraw_data = [\"1\", \"2\", \"N/A\", \"4\", \"invalid\", \"6\"]\nclean_numbers = [int(x) for x in raw_data if x.isdigit()]\n\n# File processing: Getting all Python files in a directory\nimport os\npython_files = [f for f in os.listdir('.') if f.endswith('.py')]\n\n# URL processing: Extracting domains from URLs\nurls = [\"https://python.org\", \"http://google.com\", \"github.com\"]\ndomains = [url.split('/')[-1] for url in urls]\n</code></pre> List comprehensions are a powerful tool that can make your code more readable and efficient when used appropriately. The key is to find the right balance between conciseness and clarity.</p>"},{"location":"1.Fundamentals/d_python/#understanding-python-generator-expressions-a-deep-dive","title":"Understanding Python Generator Expressions: A Deep Dive","text":""},{"location":"1.Fundamentals/d_python/#introduction-what-are-generator-expressions","title":"Introduction: What Are Generator Expressions?","text":"<p>Generator expressions are Python's elegant solution to working with large sequences of data efficiently. Think of them as a recipe that creates values one at a time, rather than all at once. This \"lazy evaluation\" approach makes them memory-efficient and perfect for handling large datasets.</p>"},{"location":"1.Fundamentals/d_python/#the-basics-from-lists-to-generators","title":"The Basics: From Lists to Generators","text":"<p>Let's start by understanding how generator expressions evolved from list comprehensions. Consider how we might create a sequence of square numbers: <pre><code># Using a list comprehension - creates all values immediately\nsquares_list = [x * x for x in range(1000)]\n\n# Using a generator expression - creates values on demand\nsquares_gen = (x * x for x in range(1000))\n</code></pre> Notice the subtle but important difference - we use parentheses  <code>()</code>  instead of square brackets  <code>[]</code>. This small change makes a big difference in how Python handles the computation.</p>"},{"location":"1.Fundamentals/d_python/#understanding-lazy-evaluation","title":"Understanding Lazy Evaluation","text":"<p>When we create a generator expression, Python doesn't compute any values right away. Instead, it creates a \"recipe\" for generating values when they're needed. Let's see this in action: <pre><code># Create a generator expression\nnumbers = (x for x in range(5))\n\nprint(numbers)  # Output: &lt;generator object &lt;genexpr&gt; at 0x...&gt;\n\n# Values are generated one at a time as we iterate\nfor n in numbers:\n    print(f\"Generated value: {n}\")\n</code></pre> Each value is computed only when we ask for it. This is particularly useful when working with large datasets or infinite sequences.</p>"},{"location":"1.Fundamentals/d_python/#comparing-memory-usage","title":"Comparing Memory Usage","text":"<p>To understand why generator expressions can be so valuable, let's look at a practical example: <pre><code>import sys\n\n# Create a list of one million numbers\nbig_list = [x for x in range(1_000_000)]\n\n# Create a generator expression for the same sequence\nbig_gen = (x for x in range(1_000_000))\n\n# Compare memory usage\nlist_size = sys.getsizeof(big_list)\ngen_size = sys.getsizeof(big_gen)\n\nprint(f\"List size: {list_size:,} bytes\")\nprint(f\"Generator size: {gen_size:,} bytes\")\n</code></pre> You'll notice that the generator expression uses significantly less memory because it doesn't store all values at once.</p>"},{"location":"1.Fundamentals/d_python/#building-complex-generator-expressions","title":"Building Complex Generator Expressions","text":"<p>Generator expressions can include conditions and transformations, just like list comprehensions: <pre><code># Generate only even numbers, doubled\neven_doubles = (x * 2 for x in range(10) if x % 2 == 0)\n\n# Generate pairs of coordinates\ncoordinates = ((x, y) for x in range(3) for y in range(3))\n\n# Process strings on the fly\nnames = ['Alice', 'Bob', 'Charlie']\ngreetings = (f\"Hello, {name.upper()}!\" for name in names)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#important-characteristics-to-remember","title":"Important Characteristics to Remember","text":"<ol> <li>One-Time Use: Unlike lists, generators are exhaustible. Once you've iterated through all values, you can't do it again: <pre><code>numbers = (x for x in range(3))\nprint(list(numbers))  # [0, 1, 2]\nprint(list(numbers))  # [] - generator is exhausted\n</code></pre></li> <li>Memory Efficiency: They're perfect for large sequences: <pre><code># Process a large file efficiently\ndef read_large_file(file_path):\n    with open(file_path) as f:\n        return (line.strip() for line in f)\n\n# Each line is processed one at a time, not all at once\nfor line in read_large_file(\"big_file.txt\"):\n    process_line(line)\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#real-world-applications_2","title":"Real-World Applications","text":"<p>Let's look at some practical uses of generator expressions: <pre><code># Data Processing Pipeline\ndef process_data():\n    # Read raw data\n    raw_data = [1, 2, \"3\", \"4\", \"invalid\", \"6\", 7]\n\n    # Create a processing pipeline using generator expressions\n    numbers = (x for x in raw_data if str(x).isdigit())\n    integers = (int(x) for x in numbers)\n    doubled = (x * 2 for x in integers)\n\n    return doubled\n\n# Memory-efficient processing of results\nfor result in process_data():\n    print(result)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-patterns_1","title":"Best Practices and Patterns","text":"<ol> <li>Use Generator Expressions When:<ul> <li>Working with large sequences</li> <li>Processing data in a pipeline</li> <li>Computing values that might not all be needed</li> <li>Memory efficiency is important</li> </ul> </li> <li>Use List Comprehensions When:<ul> <li>You need to use the results multiple times</li> <li>You need random access to elements</li> <li>You need to know the length of the sequence</li> <li>Memory isn't a concern and you need all values immediately</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#performance-optimization-examples","title":"Performance Optimization Examples","text":"<p>Let's look at how generator expressions can improve performance in real scenarios: <pre><code>import time\n\ndef measure_time(func):\n    start = time.time()\n    func()\n    end = time.time()\n    return end - start\n\n# Processing large datasets\ndef process_with_list():\n    numbers = [x * x for x in range(10_000_000)]\n    return sum(numbers)\n\ndef process_with_generator():\n    numbers = (x * x for x in range(10_000_000))\n    return sum(numbers)\n\nlist_time = measure_time(process_with_list)\ngen_time = measure_time(process_with_generator)\n\nprint(f\"List processing time: {list_time:.2f} seconds\")\nprint(f\"Generator processing time: {gen_time:.2f} seconds\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li>Reusing Exhausted Generators: <pre><code>numbers = (x for x in range(3))\nlist_1 = list(numbers)  # Works fine\nlist_2 = list(numbers)  # Empty! Generator is exhausted\n\n# Solution: Create a new generator if you need to iterate again\nnumbers = (x for x in range(3))  # Create fresh generator\n</code></pre></li> <li>Memory Leaks in Long-Running Generators: <pre><code># Potential memory leak\ndef bad_practice():\n    data = []  # This list keeps growing\n    return (x for x in data.append(x) or data)\n\n# Better approach\ndef good_practice():\n    return (x for x in range(1_000_000))\n</code></pre> Generator expressions are a powerful tool that can make your code both more memory-efficient and easier to read. By understanding when and how to use them effectively, you can write better Python code that scales well with large datasets.</li> </ol>"},{"location":"1.Fundamentals/d_python/#context-manager","title":"Context Manager","text":"<p>Context Managers are a construct in Python that allows you to set up context for a block of code, and then automatically clean up or release resources when the block is exited. It is most commonly used with the  <code>with</code>statement.</p> <p>Visit the following resources to learn more: Reference: -   OfficialContext Libraries</p>"},{"location":"1.Fundamentals/d_python/#understanding-python-concurrency-from-basics-to-advanced","title":"Understanding Python Concurrency: From Basics to Advanced","text":""},{"location":"1.Fundamentals/d_python/#the-essence-of-concurrency","title":"The Essence of Concurrency","text":"<p>Imagine you're cooking a complex meal in your kitchen. When you cook sequentially, you complete one task entirely before starting another - chopping all vegetables, then cooking the meat, then preparing the sauce. But an experienced chef works differently, starting the rice while chopping vegetables, stirring the sauce while the meat cooks. This is concurrency in action - managing multiple tasks to complete work more efficiently.</p> <p>In Python, concurrency follows this same principle. Instead of executing tasks one after another, a concurrent program can juggle multiple operations, making better use of available resources. Let's understand how this works and when to use each approach.</p>"},{"location":"1.Fundamentals/d_python/#three-approaches-to-concurrency","title":"Three Approaches to Concurrency","text":"<p>Python offers three main ways to implement concurrency, each with its own strengths:</p>"},{"location":"1.Fundamentals/d_python/#1-threading-sharing-resources-efficiently","title":"1. Threading: Sharing Resources Efficiently","text":"<p>Think of threads like multiple cooks sharing the same kitchen. They share the same space (memory) and resources (kitchen tools), but each can work independently: <pre><code>import threading\nimport requests\n\ndef download_site(url):\n    \"\"\"Download content from a URL using a shared session.\"\"\"\n    with session.get(url) as response:\n        print(f\"Downloaded {len(response.content)} bytes from {url}\")\n\n# Create thread-local storage for session objects\nthread_local = threading.local()\n\ndef get_session():\n    \"\"\"Ensure each thread has its own session.\"\"\"\n    if not hasattr(thread_local, \"session\"):\n        thread_local.session = requests.Session()\n    return thread_local.session\n\n# Multiple threads can download sites concurrently\nthreads = [\n    threading.Thread(target=download_site, args=(url,))\n    for url in urls\n]\n</code></pre> Threading works best when your program spends a lot of time waiting - like waiting for websites to respond or files to load. Each thread can start a task and then step aside while waiting, letting another thread work.</p>"},{"location":"1.Fundamentals/d_python/#2-asyncio-the-cooperative-approach","title":"2. Asyncio: The Cooperative Approach","text":"<p>Asyncio is like a master chef who keeps a mental checklist of tasks and switches between them at logical breaking points. It's more structured than threading: <pre><code>import asyncio\nimport aiohttp\n\nasync def download_site(url, session):\n    \"\"\"Download a site's content asynchronously.\"\"\"\n    async with session.get(url) as response:\n        print(f\"Read {len(await response.read())} bytes from {url}\")\n\nasync def download_all_sites(sites):\n    \"\"\"Coordinate downloading multiple sites concurrently.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        tasks = [download_site(url, session) for url in sites]\n        await asyncio.gather(*tasks)\n</code></pre> The key difference here is that the code explicitly marks where it can pause and switch tasks using  <code>async</code>  and  <code>await</code>. This makes it easier to understand and debug, but requires special async-compatible libraries.</p>"},{"location":"1.Fundamentals/d_python/#3-multiprocessing-true-parallel-execution","title":"3. Multiprocessing: True Parallel Execution","text":"<p>Multiprocessing is like having multiple kitchens, each with its own chef. Each process has its own Python interpreter and memory space: <pre><code>from multiprocessing import Process, Pool\n\ndef cpu_bound_task(n):\n    \"\"\"A computationally intensive task that benefits from true parallelism.\"\"\"\n    return sum(i * i for i in range(n))\n\ndef parallel_processing():\n    \"\"\"Process multiple tasks using separate CPU cores.\"\"\"\n    # Create a pool of worker processes\n    with Pool() as pool:\n        # Distribute work across processes\n        results = pool.map(cpu_bound_task, [10000000] * 4)\n    return results\n</code></pre> Multiprocessing really shines when you have CPU-intensive tasks that can run independently. Since each process runs on a separate CPU core, you can achieve true parallel execution.</p> <p></p>"},{"location":"1.Fundamentals/d_python/#choosing-the-right-approach","title":"Choosing the Right Approach","text":"<p>The key to effective concurrency is choosing the right tool for your specific problem:</p>"},{"location":"1.Fundamentals/d_python/#for-io-bound-tasks","title":"For I/O-Bound Tasks:","text":"<ul> <li>If you're waiting for external resources (network, files), use  asyncio  when possible</li> <li>Fall back to  threading  if you need to use libraries that don't support asyncio</li> <li>Both approaches work well because the program spends most of its time waiting</li> </ul>"},{"location":"1.Fundamentals/d_python/#for-cpu-bound-tasks","title":"For CPU-Bound Tasks:","text":"<ul> <li>Use  multiprocessing  to leverage multiple CPU cores</li> <li>Threading and asyncio won't help because of Python's Global Interpreter Lock (GIL)</li> <li>The overhead of creating processes is worth it for heavy computational work</li> </ul> <p>Here's a decision flow to help you choose: <pre><code>def choose_concurrency_model(task_type, library_constraints):\n    \"\"\"Guide for choosing the right concurrency approach.\"\"\"\n    if task_type == \"IO_BOUND\":\n        if library_supports_async():\n            return \"Use asyncio for best performance\"\n        else:\n            return \"Use threading for compatibility\"\n    elif task_type == \"CPU_BOUND\":\n        return \"Use multiprocessing for true parallelism\"\n    else:\n        return \"Start with synchronous code and optimize if needed\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-best-practices","title":"Common Pitfalls and Best Practices","text":""},{"location":"1.Fundamentals/d_python/#1-resource-sharing","title":"1. Resource Sharing","text":"<p>When using threads, be careful with shared resources: <pre><code>from threading import Lock\n\nclass ThreadSafeCounter:\n    \"\"\"Example of safe resource sharing between threads.\"\"\"\n    def __init__(self):\n        self._counter = 0\n        self._lock = Lock()\n\n    def increment(self):\n        with self._lock:\n            self._counter += 1\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#2-process-communication","title":"2. Process Communication","text":"<p>When using multiprocessing, keep communication minimal: <pre><code>from multiprocessing import Queue\n\ndef worker(input_queue, output_queue):\n    \"\"\"Process data independently and return results.\"\"\"\n    while True:\n        item = input_queue.get()\n        # Process the item independently\n        result = process_item(item)\n        output_queue.put(result)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#3-async-context-management","title":"3. Async Context Management","text":"<p>With asyncio, ensure proper resource cleanup: <pre><code>class AsyncResource:\n    \"\"\"Example of proper async resource management.\"\"\"\n    async def __aenter__(self):\n        await self.open()\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb):\n        await self.cleanup()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#performance-monitoring","title":"Performance Monitoring","text":"<p>Always measure the impact of concurrency: <pre><code>import time\nfrom functools import wraps\n\ndef measure_time(func):\n    \"\"\"Decorator to measure execution time.\"\"\"\n    @wraps(func)\n    async def async_wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = await func(*args, **kwargs)\n        duration = time.perf_counter() - start\n        print(f\"{func.__name__} took {duration:.2f} seconds\")\n        return result\n\n    @wraps(func)\n    def sync_wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        duration = time.perf_counter() - start\n        print(f\"{func.__name__} took {duration:.2f} seconds\")\n        return result\n\n    return async_wrapper if asyncio.iscoroutinefunction(func) else sync_wrapper\n</code></pre> Remember that concurrency adds complexity to your code. Start with simple, synchronous code and add concurrency only when you have a clear performance need and understanding of the bottlenecks in your application.</p>"},{"location":"1.Fundamentals/d_python/#python-asyncio-technical-guide","title":"Python Asyncio Technical Guide","text":""},{"location":"1.Fundamentals/d_python/#overview","title":"Overview","text":"<p>This technical guide covers Python's asynchronous I/O framework, asyncio, and the implementation of concurrent programming patterns using async/await syntax. The guide is intended for developers who want to understand and implement asynchronous programming in Python 3.7+.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts_4","title":"Core Concepts","text":""},{"location":"1.Fundamentals/d_python/#asynchronous-programming-model","title":"Asynchronous Programming Model","text":"<p>Asynchronous I/O is a concurrent programming paradigm that enables single-threaded, non-blocking execution through coroutines. Key characteristics include:</p> <ul> <li>Single-threaded execution with cooperative multitasking</li> <li>Event loop-based scheduling of tasks</li> <li>Non-blocking I/O operations</li> <li>Coroutine-based task management</li> </ul> <p>Unlike threading or multiprocessing, async IO doesn't create multiple execution contexts. Instead, it allows a single thread to efficiently handle multiple tasks by switching between them at well-defined suspension points.</p> <p></p>"},{"location":"1.Fundamentals/d_python/#coroutines","title":"Coroutines","text":"<p>Coroutines are the fundamental building blocks of async IO in Python. A coroutine is a specialized function that can pause its execution and yield control back to the event loop. Coroutines are defined using the following syntax: <pre><code>async def my_coroutine():\n    # Coroutine implementation\n    await some_async_operation()\n</code></pre> Key properties of coroutines:</p> <ol> <li>Must be declared with  <code>async def</code></li> <li>Can use  <code>await</code>,  <code>return</code>, and  <code>yield</code>  expressions</li> <li>Must be awaited when called from another coroutine</li> <li>Cannot use  <code>yield from</code>  expressions</li> </ol>"},{"location":"1.Fundamentals/d_python/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"1.Fundamentals/d_python/#basic-structure_2","title":"Basic Structure","text":"<p>A typical async IO application follows this structure: <pre><code>import asyncio\n\nasync def main():\n    # Main application logic\n    await some_coroutine()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#event-loop-management","title":"Event Loop Management","text":"<p>The event loop is the core scheduler for async operations. Best practices for event loop management:</p> <ol> <li>Use  <code>asyncio.run()</code>  for high-level applications (Python 3.7+)</li> <li>Only create one event loop per process</li> <li>Avoid explicitly creating event loops unless necessary</li> <li>Handle cleanup properly using async context managers</li> </ol> <p>Example of proper event loop usage: <pre><code>async def main():\n    async with aiohttp.ClientSession() as session:\n        async with session.get('http://example.com') as response:\n            return await response.text()\n\n# Preferred method (Python 3.7+)\nresult = asyncio.run(main())\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#task-management","title":"Task Management","text":"<p>Tasks are wrappers around coroutines that track their execution state. Key task management functions: <pre><code># Create and schedule a task\ntask = asyncio.create_task(my_coroutine())\n\n# Wait for multiple tasks\nresults = await asyncio.gather(task1, task2, task3)\n\n# Process tasks as they complete\nfor task in asyncio.as_completed([task1, task2, task3]):\n    result = await task\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#error-handling_1","title":"Error Handling","text":"<p>Proper error handling in async code requires special attention: <pre><code>async def safe_operation():\n    try:\n        await potentially_failing_operation()\n    except aiohttp.ClientError as e:\n        logger.error(f\"Network operation failed: {e}\")\n    except asyncio.TimeoutError:\n        logger.error(\"Operation timed out\")\n    finally:\n        await cleanup_resources()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices_2","title":"Best Practices","text":"<ol> <li>Resource Management<ul> <li>Use async context managers (<code>async with</code>) for managing resources</li> <li>Implement proper cleanup in  <code>finally</code>  blocks</li> <li>Use connection pooling for database and HTTP connections</li> </ul> </li> <li>Performance Optimization<ul> <li>Avoid CPU-bound operations in coroutines</li> <li>Use  <code>asyncio.gather()</code>  for concurrent execution</li> <li>Implement timeouts for network operations</li> <li>Consider using  <code>uvloop</code>  for improved performance</li> </ul> </li> <li>Code Organization<ul> <li>Keep coroutines focused and single-purpose</li> <li>Use dependency injection for external resources</li> <li>Implement proper logging for async operations</li> <li>Structure code to avoid callback hell</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#common-patterns","title":"Common Patterns","text":""},{"location":"1.Fundamentals/d_python/#producer-consumer-pattern","title":"Producer-Consumer Pattern","text":"<pre><code>async def producer(queue):\n    for item in items:\n        await queue.put(item)\n        await asyncio.sleep(1)  # Simulate work\n\nasync def consumer(queue):\n    while True:\n        item = await queue.get()\n        await process_item(item)\n        queue.task_done()\n\nasync def main():\n    queue = asyncio.Queue()\n    producers = [asyncio.create_task(producer(queue)) for _ in range(3)]\n    consumers = [asyncio.create_task(consumer(queue)) for _ in range(2)]\n    await asyncio.gather(*producers)\n    await queue.join()\n</code></pre>"},{"location":"1.Fundamentals/d_python/#http-client-pattern","title":"HTTP Client Pattern","text":"<pre><code>async def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\nasync def fetch_all_urls(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        return await asyncio.gather(*tasks)\n</code></pre>"},{"location":"1.Fundamentals/d_python/#common-pitfalls-and-solutions_4","title":"Common Pitfalls and Solutions","text":"<ol> <li>Blocking Operations<ul> <li>Problem: Running blocking code in coroutines</li> <li>Solution: Use  <code>loop.run_in_executor()</code>  for CPU-bound operations</li> </ul> </li> <li>Task Cancellation<ul> <li>Problem: Unhandled cancellation</li> <li>Solution: Implement proper cleanup in  <code>try/finally</code>  blocks</li> </ul> </li> <li>Resource Leaks<ul> <li>Problem: Unclosed connections and resources</li> <li>Solution: Use async context managers and proper cleanup patterns</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#testing-async-code","title":"Testing Async Code","text":"<pre><code>import pytest\n\n@pytest.mark.asyncio\nasync def test_async_operation():\n    result = await my_async_operation()\n    assert result == expected_value\n</code></pre>"},{"location":"1.Fundamentals/d_python/#debugging-tools","title":"Debugging Tools","text":"<ol> <li>Enable debug mode: <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre></li> <li>Use <code>asyncio.get_event_loop().set_debug(True)</code> for detailed logging</li> </ol>"},{"location":"1.Fundamentals/d_python/#version-compatibility","title":"Version Compatibility","text":"<p>Feature support across Python versions:</p> <ul> <li>Python 3.7+:  <code>asyncio.run()</code>, stable API</li> <li>Python 3.6: Asynchronous generators</li> <li>Python 3.5: Native coroutines with async/await</li> <li>Python 3.4: Initial asyncio introduction</li> </ul>"},{"location":"1.Fundamentals/d_python/#additional-resources","title":"Additional Resources","text":"<ul> <li>Python Documentation:  Asyncio Documentation</li> <li>PEP 492: Coroutines with async and await syntax</li> <li>PEP 525: Asynchronous Generators</li> <li>PEP 530: Asynchronous Comprehensions</li> </ul>"},{"location":"1.Fundamentals/d_python/#python-global-interpreter-lock-gil-technical-guide","title":"Python Global Interpreter Lock (GIL) Technical Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_8","title":"Introduction","text":"<p>The Global Interpreter Lock (GIL) is one of Python's most important yet frequently misunderstood implementation details. This technical guide explains what the GIL is, why it exists, and how it impacts Python application development.</p>"},{"location":"1.Fundamentals/d_python/#understanding-the-gil","title":"Understanding the GIL","text":"<p>The Global Interpreter Lock is a mutex (mutual exclusion lock) that protects access to Python objects, preventing multiple native threads from executing Python bytecode simultaneously. In simpler terms, the GIL ensures that only one thread can execute Python code at a time, even on multi-core systems.</p>"},{"location":"1.Fundamentals/d_python/#memory-management-and-reference-counting","title":"Memory Management and Reference Counting","text":"<p>To understand why the GIL exists, we need to first understand Python's memory management system. Python uses reference counting for memory management, which works as follows: <pre><code>import sys\n\n# Example of reference counting\nlist_obj = []           # ref count = 1\nanother_ref = list_obj  # ref count = 2\n\n# Get the current reference count\nref_count = sys.getrefcount(list_obj)  # Returns 3 (includes temporary reference created by getrefcount)\n</code></pre> Every Python object maintains a count of how many references point to it. When this count reaches zero, the object's memory is automatically deallocated. This system is efficient and straightforward but creates a critical requirement: the reference count must be thread-safe to prevent race conditions.</p>"},{"location":"1.Fundamentals/d_python/#the-race-condition-problem","title":"The Race Condition Problem","text":"<p>Without the GIL, the following scenario could occur:</p> <ol> <li>Object A has a reference count of 2</li> <li>Thread 1 decrements the reference count</li> <li>Thread 2 decrements the reference count</li> <li>Both threads read the initial value (2) before either writes the decremented value</li> <li>Both threads write back 1 instead of 0</li> <li>Memory leak occurs as the object is never deallocated</li> </ol>"},{"location":"1.Fundamentals/d_python/#impact-on-python-programs","title":"Impact on Python Programs","text":""},{"location":"1.Fundamentals/d_python/#cpu-bound-vs-io-bound-operations","title":"CPU-Bound vs IO-Bound Operations","text":"<p>The GIL's impact varies significantly depending on the type of operations your program performs:</p>"},{"location":"1.Fundamentals/d_python/#cpu-bound-example-heavily-impacted-by-gil","title":"CPU-Bound Example (Heavily Impacted by GIL)","text":"<p><pre><code>import time\nfrom threading import Thread\n\ndef cpu_intensive_task(n):\n    \"\"\"A CPU-bound task that performs a large number of calculations.\"\"\"\n    while n &gt; 0:\n        n -= 1\n\ndef single_threaded_example():\n    start = time.time()\n    cpu_intensive_task(50000000)\n    end = time.time()\n    return end - start\n\ndef multi_threaded_example():\n    start = time.time()\n    t1 = Thread(target=cpu_intensive_task, args=(25000000,))\n    t2 = Thread(target=cpu_intensive_task, args=(25000000,))\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    end = time.time()\n    return end - start\n</code></pre> In this CPU-bound example, the multi-threaded version may actually run slower than the single-threaded version due to the overhead of GIL acquisition and release.</p>"},{"location":"1.Fundamentals/d_python/#io-bound-example-minimal-gil-impact","title":"IO-Bound Example (Minimal GIL Impact)","text":"<p><pre><code>import asyncio\nimport aiohttp\n\nasync def io_intensive_task():\n    \"\"\"An IO-bound task that performs network operations.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get('http://example.com') as response:\n            return await response.text()\n\n# Multiple IO-bound tasks can run efficiently\nasync def main():\n    tasks = [io_intensive_task() for _ in range(10)]\n    return await asyncio.gather(*tasks)\n</code></pre> IO-bound operations work well with threading because the GIL is released during IO operations.</p>"},{"location":"1.Fundamentals/d_python/#working-around-the-gil","title":"Working Around the GIL","text":""},{"location":"1.Fundamentals/d_python/#multiprocessing-approach","title":"Multiprocessing Approach","text":"<p>When CPU-bound parallelism is needed, use multiprocessing instead of threading: <pre><code>from multiprocessing import Pool\nimport time\n\ndef cpu_intensive_task(n):\n    while n &gt; 0:\n        n -= 1\n\ndef parallel_processing_example():\n    \"\"\"Using multiprocessing to bypass the GIL.\"\"\"\n    start = time.time()\n\n    with Pool(processes=2) as pool:\n        # Split the work across processes\n        pool.map(cpu_intensive_task, [25000000, 25000000])\n\n    end = time.time()\n    return end - start\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#alternative-python-implementations","title":"Alternative Python Implementations","text":"<p>Several Python implementations exist that handle the GIL differently:</p> <ol> <li>PyPy: A JIT-compiled implementation that can provide better performance</li> <li>Jython: Java-based implementation without a GIL</li> <li>IronPython: .NET-based implementation without a GIL</li> </ol>"},{"location":"1.Fundamentals/d_python/#best-practices-and-recommendations","title":"Best Practices and Recommendations","text":"<ol> <li>Profile First: Always profile your application to confirm that the GIL is actually your bottleneck before attempting to work around it.</li> <li>Choose the Right Tool:<ul> <li>Use multiprocessing for CPU-bound parallelism</li> <li>Use threading for IO-bound operations</li> <li>Consider async/await for IO-bound operations with many concurrent tasks</li> </ul> </li> <li>Design Considerations: <pre><code># Good: IO-bound operations with threading\ndef io_bound_operation():\n    with open('large_file.txt', 'r') as f:\n        return f.read()\n\n# Better: CPU-bound operations with multiprocessing\nfrom multiprocessing import Process\n\ndef cpu_bound_operation():\n    Process(target=cpu_intensive_task).start()\n</code></pre></li> <li>Performance Monitoring:<ul> <li>Monitor thread contention using Python's system monitoring tools</li> <li>Use logging to track GIL acquisition times in critical sections</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#debugging-gil-related-issues","title":"Debugging GIL-Related Issues","text":""},{"location":"1.Fundamentals/d_python/#common-symptoms","title":"Common Symptoms","text":"<ol> <li>Poor scaling with additional CPU cores</li> <li>Unexpected performance degradation with threading</li> <li>High CPU usage with minimal throughput improvement</li> </ol>"},{"location":"1.Fundamentals/d_python/#diagnostic-tools","title":"Diagnostic Tools","text":"<pre><code>import sys\nimport threading\n\ndef diagnose_gil():\n    \"\"\"Basic GIL diagnostic information.\"\"\"\n    print(f\"Check interval: {sys.getcheckinterval()}\")\n    print(f\"Active threads: {threading.active_count()}\")\n    print(f\"GIL implementation: {sys.implementation.name}\")\n</code></pre>"},{"location":"1.Fundamentals/d_python/#future-of-the-gil","title":"Future of the GIL","text":"<p>The Python community continues to work on GIL improvements and potential alternatives:</p> <ol> <li>Subinterpreters: PEP 554 proposes per-interpreter GILs</li> <li>No-GIL Python: Experimental efforts to remove the GIL entirely</li> <li>GIL Optimizations: Ongoing improvements to GIL behavior</li> </ol>"},{"location":"1.Fundamentals/d_python/#conclusion","title":"Conclusion","text":"<p>While the GIL can impact performance in CPU-bound multi-threaded programs, understanding its behavior allows developers to make informed decisions about concurrent programming in Python. By choosing the appropriate concurrency model and implementation strategy, you can effectively work around GIL limitations while maintaining Python's simplicity and ease of use.</p>"},{"location":"1.Fundamentals/d_python/#python-threading-a-comprehensive-technical-guide","title":"Python Threading: A Comprehensive Technical Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_9","title":"Introduction","text":"<p>Threading in Python enables concurrent execution within a program, allowing different parts of code to run seemingly simultaneously. This guide provides a thorough examination of Python's threading capabilities, implementation patterns, and best practices.</p>"},{"location":"1.Fundamentals/d_python/#core-threading-concepts","title":"Core Threading Concepts","text":""},{"location":"1.Fundamentals/d_python/#understanding-threads","title":"Understanding Threads","text":"<p>A thread represents an independent flow of execution within a program. In Python's standard implementation (CPython), threads operate under some important constraints:</p> <ol> <li>Global Interpreter Lock (GIL): While threads appear to run simultaneously, the GIL ensures only one thread executes Python bytecode at a time</li> <li>Use Cases: Most effective for I/O-bound operations where threads spend time waiting for external events</li> <li>Limitations: May not improve performance for CPU-bound tasks due to GIL constraints</li> </ol>"},{"location":"1.Fundamentals/d_python/#thread-lifecycle","title":"Thread Lifecycle","text":"<pre><code>import threading\nimport time\n\ndef worker_function(name):\n    \"\"\"Example worker function to demonstrate thread lifecycle\"\"\"\n    print(f\"Thread {name}: Starting\")\n    time.sleep(2)  # Simulate work\n    print(f\"Thread {name}: Finishing\")\n\n# Create and start a thread\nthread = threading.Thread(target=worker_function, args=('Worker',))\nthread.start()  # Thread begins execution\nthread.join()   # Wait for thread completion\n</code></pre>"},{"location":"1.Fundamentals/d_python/#thread-management","title":"Thread Management","text":""},{"location":"1.Fundamentals/d_python/#creating-threads","title":"Creating Threads","text":"<p>There are two primary ways to create threads:</p> <ol> <li>Function-based Approach: <pre><code>def task():\n    \"\"\"Thread task implementation\"\"\"\n    pass\n\n# Create thread with a function\nthread = threading.Thread(target=task)\n</code></pre></li> <li>Class based Approach <pre><code>class WorkerThread(threading.Thread):\n    def run(self):\n        \"\"\"Thread task implementation\"\"\"\n        pass\n\n# Create thread from class\nthread = WorkerThread()\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#thread-control","title":"Thread Control","text":""},{"location":"1.Fundamentals/d_python/#daemon-threads","title":"Daemon Threads","text":"<p>Daemon threads automatically terminate when the main program exits: <pre><code>def background_task():\n    \"\"\"Task that runs in background\"\"\"\n    pass\n\ndaemon_thread = threading.Thread(target=background_task, daemon=True)\ndaemon_thread.start()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#thread-synchronization","title":"Thread Synchronization","text":"<ol> <li>Lock: Provides mutual exclusion: <pre><code>lock = threading.Lock()\n\ndef protected_operation():\n    with lock:  # Acquire and release lock automatically\n        # Critical section\n        pass\n</code></pre></li> <li>RLock: Reentrant lock allowing multiple acquisitions by same thread: <pre><code>rlock = threading.RLock()\n\ndef reentrant_operation():\n    with rlock:\n        with rlock:  # Same thread can acquire multiple times\n            pass\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#advanced-threading-patterns","title":"Advanced Threading Patterns","text":""},{"location":"1.Fundamentals/d_python/#producer-consumer-pattern_1","title":"Producer-Consumer Pattern","text":"<p>A common threading pattern for handling asynchronous workloads: <pre><code>import queue\n\nclass ProducerConsumer:\n    def __init__(self, queue_size=10):\n        self.queue = queue.Queue(maxsize=queue_size)\n        self.event = threading.Event()\n\n    def producer(self):\n        \"\"\"Generates work items\"\"\"\n        while not self.event.is_set():\n            item = self.generate_item()\n            self.queue.put(item)\n\n    def consumer(self):\n        \"\"\"Processes work items\"\"\"\n        while not self.event.is_set() or not self.queue.empty():\n            item = self.queue.get()\n            self.process_item(item)\n            self.queue.task_done()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#thread-pooling","title":"Thread Pooling","text":"<p>Using ThreadPoolExecutor for managed thread pools: <pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef process_item(item):\n    \"\"\"Process a single item\"\"\"\n    return item * 2\n\n# Process items using thread pool\nwith ThreadPoolExecutor(max_workers=3) as executor:\n    results = list(executor.map(process_item, range(10)))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#synchronization-primitives","title":"Synchronization Primitives","text":""},{"location":"1.Fundamentals/d_python/#event","title":"Event","text":"<p>Used for thread signaling: <pre><code>event = threading.Event()\n\ndef wait_for_signal():\n    \"\"\"Wait for event to be set\"\"\"\n    event.wait()  # Block until event is set\n    print(\"Signal received\")\n\n# In another thread\nevent.set()  # Signal waiting threads\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#semaphore","title":"Semaphore","text":"<p>Controls access to a limited resource: <pre><code># Limit concurrent access to 3 threads\nsemaphore = threading.Semaphore(3)\n\ndef limited_access():\n    \"\"\"Access limited resource\"\"\"\n    with semaphore:\n        # Access protected resource\n        pass\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#barrier","title":"Barrier","text":"<p>Synchronizes multiple threads at a specific point: <pre><code>barrier = threading.Barrier(3)  # Wait for 3 threads\n\ndef synchronized_task():\n    \"\"\"Task that requires synchronization\"\"\"\n    print(\"Preparing...\")\n    barrier.wait()  # Wait for all threads\n    print(\"All threads ready!\")\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-common-pitfalls_2","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/d_python/#race-conditions","title":"Race Conditions","text":"<p>Prevent race conditions by properly protecting shared resources: <pre><code>class ThreadSafeCounter:\n    def __init__(self):\n        self._value = 0\n        self._lock = threading.Lock()\n\n    def increment(self):\n        with self._lock:\n            self._value += 1\n            return self._value\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#deadlock-prevention","title":"Deadlock Prevention","text":"<p>Avoid deadlocks by:</p> <ol> <li>Using context managers (<code>with</code>  statements) for lock management</li> <li>Maintaining consistent lock acquisition order</li> <li>Using timeouts with lock acquisition</li> <li>Preferring  <code>Queue</code>  for thread communication</li> </ol>"},{"location":"1.Fundamentals/d_python/#resource-management","title":"Resource Management","text":"<pre><code>def managed_threads():\n    \"\"\"Properly manage thread resources\"\"\"\n    threads = []\n    try:\n        # Create and start threads\n        for _ in range(3):\n            thread = threading.Thread(target=worker)\n            threads.append(thread)\n            thread.start()\n    finally:\n        # Ensure all threads are properly joined\n        for thread in threads:\n            thread.join()\n</code></pre>"},{"location":"1.Fundamentals/d_python/#performance-considerations_2","title":"Performance Considerations","text":"<ol> <li>I/O-Bound vs CPU-Bound:<ul> <li>Use threading for I/O-bound tasks</li> <li>Consider multiprocessing for CPU-bound tasks</li> <li>Profile code to identify bottlenecks</li> </ul> </li> <li>Thread Overhead:<ul> <li>Creating threads has overhead</li> <li>Use thread pools for frequent task execution</li> <li>Balance thread count with system resources</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/d_python/#debug-and-testing-strategies","title":"Debug and Testing Strategies","text":"<ol> <li>Logging: <pre><code>import logging\n\nlogging.basicConfig(\n    format='%(asctime)s: %(message)s',\n    level=logging.DEBUG,\n    datefmt='%H:%M:%S'\n)\n</code></pre></li> <li>Thread Naming: <pre><code>def worker():\n    name = threading.current_thread().name\n    logging.debug(f'Thread {name} starting')\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#conclusion_1","title":"Conclusion","text":"<p>Python's threading module provides powerful tools for concurrent programming, particularly suited for I/O-bound tasks. While the GIL impacts CPU-bound performance, proper thread usage can significantly improve application responsiveness and resource utilization. Understanding synchronization primitives and common patterns is crucial for building robust threaded applications.</p>"},{"location":"1.Fundamentals/d_python/#python-virtual-environments-a-comprehensive-technical-guide","title":"Python Virtual Environments: A Comprehensive Technical Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_10","title":"Introduction","text":"<p>Python virtual environments are isolated runtime environments that contain a specific Python interpreter and library dependencies. They solve the critical problem of managing project-specific dependencies while avoiding conflicts between different projects. This guide provides a thorough understanding of virtual environments and their implementation in Python projects.</p>"},{"location":"1.Fundamentals/d_python/#understanding-virtual-environments","title":"Understanding Virtual Environments","text":""},{"location":"1.Fundamentals/d_python/#the-dependency-problem","title":"The Dependency Problem","text":"<p>Consider a scenario where you're working on two different Python projects:</p> <ul> <li>Project A requires Django 2.2 for legacy support</li> <li>Project B needs Django 4.0 for newer features</li> </ul> <p>Without virtual environments, you would face a dilemma: installing either version globally would break one of your projects. Virtual environments solve this by creating isolated spaces where each project can have its own dependencies without interfering with others. </p>"},{"location":"1.Fundamentals/d_python/#creating-and-managing-virtual-environments","title":"Creating and Managing Virtual Environments","text":""},{"location":"1.Fundamentals/d_python/#using-venv-python-33","title":"Using venv (Python 3.3+)","text":"<p>The  <code>venv</code>  module is Python's built-in solution for creating virtual environments: <pre><code># Create a new virtual environment\npython -m venv myproject_env\n\n# Structure created:\nmyproject_env/\n\u251c\u2500\u2500 bin/                # Scripts directory on Unix\n\u2502   \u251c\u2500\u2500 activate       # Shell activation script\n\u2502   \u251c\u2500\u2500 pip           # Environment-specific pip\n\u2502   \u2514\u2500\u2500 python        # Python interpreter symlink\n\u251c\u2500\u2500 include/           # C headers for compilation\n\u251c\u2500\u2500 lib/               # Python packages directory\n\u2514\u2500\u2500 pyvenv.cfg         # Environment configuration\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#activating-virtual-environments","title":"Activating Virtual Environments","text":"<p>Different shells require different activation commands: <pre><code># Unix/macOS (bash/zsh)\nsource myproject_env/bin/activate\n\n# Windows Command Prompt\nmyproject_env\\Scripts\\activate.bat\n\n# Windows PowerShell\nmyproject_env\\Scripts\\Activate.ps1\n</code></pre> When activated, your prompt changes to indicate the active environment: <pre><code>(myproject_env) user@machine:~$\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#managing-dependencies_1","title":"Managing Dependencies","text":"<p>Once activated, you can manage packages without affecting other projects: <pre><code># Install packages in the virtual environment\n(myproject_env) $ pip install django==4.0\n\n# List installed packages\n(myproject_env) $ pip list\n\n# Create requirements file\n(myproject_env) $ pip freeze &gt; requirements.txt\n\n# Install from requirements\n(myproject_env) $ pip install -r requirements.txt\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices-and-advanced-usage","title":"Best Practices and Advanced Usage","text":""},{"location":"1.Fundamentals/d_python/#project-structure","title":"Project Structure","text":"<p>A recommended project structure using virtual environments: <pre><code>myproject/\n\u251c\u2500\u2500 .gitignore          # Include venv/ directory\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt    # Dependency specifications\n\u251c\u2500\u2500 src/               # Source code directory\n\u251c\u2500\u2500 tests/             # Test files\n\u2514\u2500\u2500 venv/              # Virtual environment (not in version control)\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#version-control-integration","title":"Version Control Integration","text":"<p>Add to  <code>.gitignore</code>: <pre><code># Ignore virtual environment directories\nvenv/\nenv/\n.env/\n.venv/\n\n# Ignore compiled Python files\n__pycache__/\n*.pyc\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#dependency-management-best-practices","title":"Dependency Management Best Practices","text":"<pre><code># Development dependencies\npip install -r requirements-dev.txt\n\n# Production dependencies\npip install -r requirements.txt\n\n# Example requirements.txt structure\nDjango==4.0.0\npsycopg2-binary==2.9.3\ngunicorn==20.1.0\n\n# Example requirements-dev.txt\n-r requirements.txt    # Include production dependencies\npytest==7.1.1\nblack==22.3.0\nflake8==4.0.1\n</code></pre>"},{"location":"1.Fundamentals/d_python/#advanced-virtual-environment-tools","title":"Advanced Virtual Environment Tools","text":""},{"location":"1.Fundamentals/d_python/#poetry-modern-dependency-management","title":"Poetry: Modern Dependency Management","text":"<p>Poetry provides enhanced dependency management and packaging: <pre><code># Initialize a new project\npoetry new myproject\n\n# Add dependencies\npoetry add django\n\n# Install dependencies\npoetry install\n\n# Run commands in the virtual environment\npoetry run python manage.py runserver\n</code></pre> Example <code>pyproject.toml</code>: <pre><code>[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name &lt;your.email@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\ndjango = \"^4.0.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^7.1.1\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#pipenv-security-focused-environment-management","title":"Pipenv: Security-Focused Environment Management","text":"<p>Pipeline Environment (pipenv) is a tool that aims to bring the best of all packaging worlds (bundled, requirements.txt, setup.py, setup.cfg, etc.) to the Python world. It automatically creates and manages a virtualenv for your projects, as well as adds/removes packages from your Pipfile as you install/uninstall packages. It also generates the ever-important Pipfile.lock, which is used to produce deterministic builds.</p> <p>Read more here: Pipenv Documentation <pre><code># Create new environment and install packages\npipenv install django\n\n# Activate the environment\npipenv shell\n\n# Install development dependencies\npipenv install --dev pytest\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#environment-variables-and-configuration","title":"Environment Variables and Configuration","text":""},{"location":"1.Fundamentals/d_python/#managing-environment-variables","title":"Managing Environment Variables","text":"<p>Create a  <code>.env</code>  file for environment-specific variables: <pre><code># .env\nDATABASE_URL=postgresql://localhost/mydb\nDEBUG=True\nSECRET_KEY=your-secret-key\n</code></pre> Load environment variables in Python: <pre><code>import os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env\nload_dotenv()\n\n# Access variables\ndatabase_url = os.getenv('DATABASE_URL')\ndebug = os.getenv('DEBUG', 'False').lower() == 'true'\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"1.Fundamentals/d_python/#path-issues","title":"Path Issues","text":"<p>If you encounter path-related problems:</p> <ol> <li>Verify environment activation: <pre><code># Check Python interpreter location\nwhich python  # Unix/macOS\nwhere python  # Windows\n</code></pre></li> <li>Check environment variables: <pre><code>echo $PATH  # Verify virtual environment path is first\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#dependency-conflicts","title":"Dependency Conflicts","text":"<p>Resolve dependency conflicts by:</p> <ol> <li>Using  <code>pip-tools</code>  for dependency pinning: <pre><code># Generate pinned requirements\npip-compile requirements.in\n\n# Sync environment with requirements\npip-sync\n</code></pre></li> <li>Analyzing dependency trees: <pre><code>pip install pipdeptree\npipdeptree -p django  # Show django dependency tree\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#performance-optimization","title":"Performance Optimization","text":""},{"location":"1.Fundamentals/d_python/#caching-pip-downloads","title":"Caching Pip Downloads","text":"<p>Configure pip to cache downloads: <pre><code># Set pip cache directory\npip config set global.cache-dir ~/.pip/cache\n\n# Set cache expiry\npip config set global.cache-ttl 172800  # 48 hours\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#reducing-environment-size","title":"Reducing Environment Size","text":"<p>Minimize environment size by:</p> <ol> <li>Only installing needed packages</li> <li>Using wheels instead of source distributions</li> <li>Regularly cleaning cached files: <pre><code>pip cache purge  # Clear pip cache\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#security-considerations_1","title":"Security Considerations","text":""},{"location":"1.Fundamentals/d_python/#dependency-auditing","title":"Dependency Auditing","text":"<p>Regularly audit dependencies for security vulnerabilities: <pre><code># Install safety checker\npip install safety\n\n# Check installed packages\nsafety check\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#environment-isolation","title":"Environment Isolation","text":"<p>Ensure proper isolation by:</p> <ol> <li>Never committing sensitive data in version control</li> <li>Using separate environments for development and production</li> <li>Regularly updating dependencies for security patches</li> </ol>"},{"location":"1.Fundamentals/d_python/#conclusion_2","title":"Conclusion","text":"<p>Virtual environments are essential for Python development, providing isolation, dependency management, and reproducible environments. By following these best practices and understanding the available tools, you can create maintainable and secure Python projects.</p> <p>Remember to:</p> <ul> <li>Create a new virtual environment for each project</li> <li>Keep dependencies updated and documented</li> <li>Use appropriate tools for your project's needs</li> <li>Maintain security through regular audits and updates</li> <li>Follow consistent project structure patterns</li> </ul> <p>This foundation will help you manage Python projects effectively while avoiding common pitfalls and security issues.</p>"},{"location":"1.Fundamentals/d_python/#python-type-hints-a-comprehensive-guide","title":"Python Type Hints: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_11","title":"Introduction","text":"<p>Type hints in Python provide a way to explicitly specify the types of variables, function parameters, and return values in your code. While Python remains a dynamically typed language, type hints enable static type checking, better documentation, and improved IDE support without affecting runtime behavior.</p>"},{"location":"1.Fundamentals/d_python/#core-concepts_5","title":"Core Concepts","text":""},{"location":"1.Fundamentals/d_python/#understanding-type-hints","title":"Understanding Type Hints","text":"<p>Type hints were introduced in Python 3.5 through PEP 484 and have evolved significantly since then. At their core, type hints are annotations that help developers and tools understand the expected types in your code. Consider this basic example: <pre><code>def calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"Calculate the area of a rectangle.\"\"\"\n    return length * width\n</code></pre> In this function:</p> <ul> <li><code>length: float</code>  indicates that  <code>length</code>  should be a floating-point number</li> <li><code>width: float</code>  specifies that  <code>width</code>  should also be a float</li> <li><code>-&gt; float</code>  declares that the function returns a float</li> </ul>"},{"location":"1.Fundamentals/d_python/#type-aliases","title":"Type Aliases","text":"<p>Type aliases allow you to create meaningful names for complex types. They help improve code readability and reduce duplication. Starting from Python 3.12, you can use the dedicated  <code>type</code>  statement: <pre><code># Creating a type alias for a complex type\ntype Vector = list[float]\ntype Point = tuple[float, float]\n\ndef scale_vector(scalar: float, vector: Vector) -&gt; Vector:\n    return [scalar * x for x in vector]\n\ndef plot_point(point: Point) -&gt; None:\n    x, y = point\n    # Plot implementation\n</code></pre> For backwards compatibility on older Python versions: <pre><code>from typing import TypeAlias\n\nVector: TypeAlias = list[float]\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#generics-and-type-variables","title":"Generics and Type Variables","text":"<p>Generics allow you to write code that works with multiple types while maintaining type safety. Type variables are the building blocks of generic types: <pre><code>from typing import TypeVar, Sequence\n\nT = TypeVar('T')\n\ndef first_element[T](sequence: Sequence[T]) -&gt; T:\n    \"\"\"Return the first element of any sequence.\"\"\"\n    if not sequence:\n        raise ValueError(\"Sequence is empty\")\n    return sequence[0]\n\n# Usage\nnumbers = [1, 2, 3]\nfirst_num = first_element(numbers)  # Type: int\n\nwords = [\"hello\", \"world\"]\nfirst_word = first_element(words)  # Type: str\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#advanced-features","title":"Advanced Features","text":""},{"location":"1.Fundamentals/d_python/#union-types-and-optional-values","title":"Union Types and Optional Values","text":"<p>Union types specify that a value can be one of several types: <pre><code>from typing import Union\n\ndef process_data(data: Union[str, bytes]) -&gt; str:\n    if isinstance(data, bytes):\n        return data.decode('utf-8')\n    return data\n\n# Modern syntax (Python 3.10+)\ndef process_data(data: str | bytes) -&gt; str:\n    # Same implementation\n</code></pre> Optional values are commonly represented using the <code>Optional</code> type or the <code>None</code> union: <pre><code>def find_user(id: int) -&gt; str | None:\n    \"\"\"Return username if found, None otherwise.\"\"\"\n    # Implementation\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#protocol-classes","title":"Protocol Classes","text":"<p>Protocols enable structural subtyping (duck typing) with static type checking: <pre><code>from typing import Protocol\n\nclass Drawable(Protocol):\n    def draw(self) -&gt; None: ...\n\nclass Circle:\n    def draw(self) -&gt; None:\n        print(\"Drawing a circle\")\n\nclass Square:\n    def draw(self) -&gt; None:\n        print(\"Drawing a square\")\n\ndef render(shape: Drawable) -&gt; None:\n    shape.draw()\n\n# Both work because they implement the Drawable protocol\nrender(Circle())\nrender(Square())\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#type-guards-and-narrowing","title":"Type Guards and Narrowing","text":"<p>Type guards help narrow down types in conditional blocks: <pre><code>from typing import TypeGuard\n\ndef is_string_list(val: list[object]) -&gt; TypeGuard[list[str]]:\n    \"\"\"Check if all elements in the list are strings.\"\"\"\n    return all(isinstance(x, str) for x in val)\n\ndef process_strings(items: list[object]) -&gt; None:\n    if is_string_list(items):\n        # Type checker knows items is list[str] here\n        print(\" \".join(items))\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices_3","title":"Best Practices","text":""},{"location":"1.Fundamentals/d_python/#type-checking","title":"Type Checking","text":"<p>While Python's runtime doesn't enforce type hints, you can use static type checkers like mypy: <pre><code># Install mypy\npip install mypy\n\n# Run type checking\nmypy your_script.py\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#documentation-integration","title":"Documentation Integration","text":"<p>Type hints complement docstrings and provide machine-readable type information: <pre><code>def parse_date(date_string: str) -&gt; tuple[int, int, int]:\n    \"\"\"Parse a date string in YYYY-MM-DD format.\n\n    Args:\n        date_string: Date in YYYY-MM-DD format\n\n    Returns:\n        Tuple of (year, month, day)\n\n    Raises:\n        ValueError: If the date string is invalid\n    \"\"\"\n    # Implementation\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#performance-considerations_3","title":"Performance Considerations","text":"<p>Type hints have no runtime performance impact since they're ignored by the Python interpreter. However, for optimal performance:</p> <ol> <li>Use  <code>from __future__ import annotations</code>  to defer annotation evaluation</li> <li>Avoid complex type expressions in hot code paths</li> <li>Consider using  <code>typing.Final</code>  for constants that shouldn't change <pre><code>from __future__ import annotations\nfrom typing import Final\n\nMAX_RETRIES: Final = 3  # Type checker ensures this isn't modified\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#common-patterns_1","title":"Common Patterns","text":""},{"location":"1.Fundamentals/d_python/#container-types","title":"Container Types","text":"<p>Python provides several ways to type common container structures: <pre><code>from collections.abc import Sequence, Mapping\nfrom typing import TypedDict\n\n# For sequences\ndef process_items(items: Sequence[int]) -&gt; None: ...\n\n# For dictionaries\ndef process_config(config: Mapping[str, str]) -&gt; None: ...\n\n# For structured dictionaries\nclass UserData(TypedDict):\n    name: str\n    age: int\n    email: str | None\n\ndef save_user(user: UserData) -&gt; None: ...\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#callable-types","title":"Callable Types","text":"<p>For functions and callable objects: <pre><code>from collections.abc import Callable\n\n# Function taking two ints and returning a float\ndef apply_operation(func: Callable[[int, int], float], x: int, y: int) -&gt; float:\n    return func(x, y)\n\n# Any callable returning str\ndef process_with_callback(callback: Callable[..., str]) -&gt; str:\n    return callback()\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#conclusion_3","title":"Conclusion","text":"<p>Type hints provide a powerful way to make Python code more maintainable and less error-prone. While they require some initial investment in learning and setup, the benefits of catching type-related errors early, improving code documentation, and enabling better tooling support make them invaluable for many Python projects.</p> <p>Remember that type hints are optional and can be adopted gradually. Start with the most critical parts of your codebase and expand coverage as needed. Use type checkers regularly to catch potential issues early in development.</p>"},{"location":"1.Fundamentals/d_python/#code-formatting","title":"Code Formatting","text":"<p>Python code formatting is crucial for maintaining readability, consistency, and reducing errors. Black is a code formatter for Python. It is a tool that automatically formats Python code to adhere to the PEP 8 style guide. It is a great tool to use in your Python projects to ensure that your code is formatted consistently and correctly.</p> <p>References for Further Reading: -   Pylint for Python -   OfficialBlack Documentation</p>"},{"location":"1.Fundamentals/d_python/#code-documentation","title":"Code Documentation","text":""},{"location":"1.Fundamentals/d_python/#sphinx","title":"sphinx","text":"<p>Sphinx is a tool that makes it easy to create intelligent and beautiful documentation, written by Georg Brandl and licensed under the BSD license. -   Official Shpinx Website</p>"},{"location":"1.Fundamentals/d_python/#python-testing-a-comprehensive-guide","title":"Python Testing: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/d_python/#introduction_12","title":"Introduction","text":"<p>Software testing is an essential practice that helps ensure your code works as intended and continues to work as your application evolves. This guide will walk you through testing in Python, starting with basic concepts and building up to advanced testing strategies.</p>"},{"location":"1.Fundamentals/d_python/#understanding-testing-fundamentals","title":"Understanding Testing Fundamentals","text":""},{"location":"1.Fundamentals/d_python/#why-we-test","title":"Why We Test","text":"<p>Testing serves multiple critical purposes in software development:</p> <ol> <li>Validating functionality - Ensures your code does what it's supposed to do</li> <li>Catching regressions - Helps prevent new changes from breaking existing features</li> <li>Documenting behavior - Tests serve as executable documentation of how code should work</li> <li>Improving design - Writing testable code naturally leads to better software architecture</li> </ol>"},{"location":"1.Fundamentals/d_python/#types-of-testing","title":"Types of Testing","text":"<p>Let's explore the main categories of testing, moving from smallest to largest scope:</p>"},{"location":"1.Fundamentals/d_python/#unit-testing","title":"Unit Testing","text":"<p>Unit tests focus on testing individual components in isolation. Consider this simple function: <pre><code>def calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"Calculate the area of a rectangle.\"\"\"\n    return length * width\n\n# A unit test for this function\ndef test_calculate_area():\n    assert calculate_area(2, 3) == 6\n    assert calculate_area(0, 5) == 0\n    assert calculate_area(2.5, 3.0) == 7.5\n</code></pre> Unit tests should be:</p> <ul> <li>Fast - They test small units of code</li> <li>Isolated - No dependencies on external systems</li> <li>Repeatable - Same results every time</li> <li>Clear - Easy to understand what's being tested</li> </ul>"},{"location":"1.Fundamentals/d_python/#integration-testing","title":"Integration Testing","text":"<p>Integration tests verify that multiple components work together correctly. For example: <pre><code>def test_save_user_to_database():\n    # Create a test database connection\n    db = create_test_database()\n\n    # Test that user creation and retrieval work together\n    user_service = UserService(db)\n    user = user_service.create_user(\"test@example.com\", \"password123\")\n    retrieved_user = user_service.get_user(user.id)\n\n    assert retrieved_user.email == \"test@example.com\"\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#testing-tools-and-frameworks","title":"Testing Tools and Frameworks","text":""},{"location":"1.Fundamentals/d_python/#unittest-pythons-built-in-testing-framework","title":"unittest - Python's Built-in Testing Framework","text":"<p>Python's standard library includes unittest, which provides a rich set of tools for constructing and running tests: <pre><code>import unittest\n\nclass TestCalculator(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        self.calc = Calculator()\n\n    def test_addition(self):\n        \"\"\"Test that addition works with positive numbers.\"\"\"\n        result = self.calc.add(3, 5)\n        self.assertEqual(result, 8)\n\n    def test_division_by_zero(self):\n        \"\"\"Test that division by zero raises an error.\"\"\"\n        with self.assertRaises(ValueError):\n            self.calc.divide(5, 0)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> Key unittest features:</p> <ul> <li>Test fixtures (setUp/tearDown)</li> <li>Rich set of assertions</li> <li>Test discovery</li> <li>Test organization with test cases</li> </ul>"},{"location":"1.Fundamentals/d_python/#pytest-a-more-powerful-alternative","title":"pytest - A More Powerful Alternative","text":"<p>pytest has become the de facto standard for Python testing, offering more features and a simpler syntax: <pre><code>import pytest\n\ndef test_addition():\n    result = add(3, 5)\n    assert result == 8\n\n# Parameterized testing made easy\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (3, 5, 8),\n    (-1, 1, 0),\n    (0, 0, 0),\n])\ndef test_addition_parameterized(a, b, expected):\n    assert add(a, b) == expected\n</code></pre> pytest advantages:</p> <ul> <li>Simpler assert statements</li> <li>Powerful fixture system</li> <li>Extensive plugin ecosystem</li> <li>Better error reporting</li> </ul>"},{"location":"1.Fundamentals/d_python/#advanced-testing-concepts","title":"Advanced Testing Concepts","text":""},{"location":"1.Fundamentals/d_python/#test-fixtures","title":"Test Fixtures","text":"<p>Fixtures provide a way to set up consistent test environments: <pre><code>import pytest\nimport tempfile\nimport os\n\n@pytest.fixture\ndef temp_file():\n    \"\"\"Create a temporary file for testing.\"\"\"\n    fd, path = tempfile.mkstemp()\n    yield path  # This is provided to the test\n    os.close(fd)  # Cleanup after the test\n    os.unlink(path)\n\ndef test_file_operations(temp_file):\n    # Write to the temporary file\n    with open(temp_file, 'w') as f:\n        f.write('test data')\n\n    # Read and verify the contents\n    with open(temp_file) as f:\n        assert f.read() == 'test data'\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#mocking","title":"Mocking","text":"<p>Mocking allows you to replace parts of your system with mock objects for testing: <pre><code>from unittest.mock import Mock, patch\n\ndef get_user_data(user_id):\n    # Imagine this makes an API call\n    response = requests.get(f'https://api.example.com/users/{user_id}')\n    return response.json()\n\ndef test_get_user_data():\n    # Mock the requests.get call\n    mock_response = Mock()\n    mock_response.json.return_value = {'id': 1, 'name': 'Test User'}\n\n    with patch('requests.get', return_value=mock_response):\n        data = get_user_data(1)\n        assert data['name'] == 'Test User'\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#best-practices_4","title":"Best Practices","text":""},{"location":"1.Fundamentals/d_python/#test-organization","title":"Test Organization","text":"<p>Structure your tests to be maintainable and clear: <pre><code>my_project/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 calculator/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 operations.py\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 unit/\n    \u2502   \u2514\u2500\u2500 test_operations.py\n    \u2514\u2500\u2500 integration/\n        \u2514\u2500\u2500 test_calculator.py\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#writing-good-tests","title":"Writing Good Tests","text":"<ol> <li>Follow the Arrange-Act-Assert pattern: <pre><code>def test_user_registration():\n    # Arrange\n    email = \"test@example.com\"\n    password = \"secure_password\"\n\n    # Act\n    user = register_user(email, password)\n\n    # Assert\n    assert user.email == email\n    assert user.is_active == True\n</code></pre></li> <li>Test edge cases and error conditions: <pre><code>def test_division_edge_cases():\n    # Test zero division\n    with pytest.raises(ValueError):\n        divide(1, 0)\n\n    # Test negative numbers\n    assert divide(-6, 2) == -3\n\n    # Test floating point\n    assert abs(divide(1, 3) - 0.3333) &lt; 0.0001\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/d_python/#testing-asynchronous-code","title":"Testing Asynchronous Code","text":"<p>Modern Python applications often include asynchronous code. Here's how to test it: <pre><code>import asyncio\nimport pytest\n\nasync def fetch_data():\n    # Simulate async operation\n    await asyncio.sleep(0.1)\n    return {'status': 'success'}\n\n@pytest.mark.asyncio\nasync def test_fetch_data():\n    result = await fetch_data()\n    assert result['status'] == 'success'\n</code></pre></p>"},{"location":"1.Fundamentals/d_python/#test-automation-and-continuous-integration","title":"Test Automation and Continuous Integration","text":""},{"location":"1.Fundamentals/d_python/#using-tox-for-testing-multiple-python-versions","title":"Using tox for Testing Multiple Python Versions","text":"<pre><code>[tox]\nenvlist = py36,py37,py38,py39\nisolated_build = True\n\n[testenv]\ndeps = pytest\ncommands = pytest tests/\n</code></pre>"},{"location":"1.Fundamentals/d_python/#setting-up-github-actions","title":"Setting Up Github Actions","text":"<pre><code>name: Python Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [3.7, 3.8, 3.9]\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: ${{ matrix.python-version }}\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n    - name: Run tests\n      run: |\n        pytest tests/\n</code></pre>"},{"location":"1.Fundamentals/d_python/#conclusion_4","title":"Conclusion","text":"<p>Testing is a crucial skill for Python developers. Start with simple unit tests and gradually incorporate more advanced testing patterns as your applications grow. Remember that good tests are:</p> <ul> <li>Readable and maintainable</li> <li>Fast and reliable</li> <li>Focused on testing behavior, not implementation</li> <li>Automated and integrated into your development workflow</li> </ul> <p>By following these principles and practices, you can build more reliable Python applications and catch issues before they reach production.</p>"},{"location":"1.Fundamentals/e_java/","title":"Java Programming Language","text":""},{"location":"1.Fundamentals/e_java/#introduction","title":"Introduction","text":"<p>Java stands as one of the most influential programming languages in the history of computing, powering everything from web applications and mobile devices to enterprise software and embedded systems. First released in 1995 by Sun Microsystems, Java has evolved to become a cornerstone of modern software development, known for its platform independence, robustness, and versatility.</p>"},{"location":"1.Fundamentals/e_java/#historical-background","title":"Historical Background","text":"<p>The story of Java begins in 1991 when James Gosling and his team at Sun Microsystems began working on a project called \"Green.\" Their initial goal wasn't to create a new programming language, but rather to develop software for consumer electronic devices. The team quickly realized that existing programming languages like C++ weren't suitable for their needs, primarily due to hardware variations in consumer devices.</p> <p>Gosling and his colleagues aimed to create a language that would be:</p> <ul> <li>Simple and object-oriented</li> <li>Robust and secure</li> <li>Architecture-neutral and portable</li> <li>High-performance</li> <li>Interpreted, threaded, and dynamic</li> </ul> <p>The language was originally named \"Oak\" after a tree outside Gosling's office. However, due to trademark issues, it was renamed to \"Java,\" inspired by Java coffee, a favorite among the language's developers.</p>"},{"location":"1.Fundamentals/e_java/#the-write-once-run-anywhere-philosophy","title":"The \"Write Once, Run Anywhere\" Philosophy","text":"<p>Java's revolutionary \"Write Once, Run Anywhere\" (WORA) principle transformed software development. This was achieved through the Java Virtual Machine (JVM), an innovation that allowed Java programs to run on any device with a JVM installed, regardless of the underlying hardware architecture or operating system.</p> <p>When programmers compile Java code, it isn't converted directly to machine code like in languages such as C++. Instead, it's compiled into an intermediate form called bytecode. This bytecode can then be interpreted by the JVM on any platform, making Java truly platform-independent.</p>"},{"location":"1.Fundamentals/e_java/#key-milestones-in-javas-evolution","title":"Key Milestones in Java's Evolution","text":"<p>1995: First public release of Java (Version 1.0) 1998: Java 2 Platform introduced (J2SE, J2EE, J2ME) 2004: Java 5 brought major language features including generics and annotations 2014: Java 8 introduced lambda expressions and the Stream API 2018: New six-month release cycle began 2021: Java 17 released as a Long Term Support (LTS) version</p>"},{"location":"1.Fundamentals/e_java/#javas-impact-on-modern-computing","title":"Java's Impact on Modern Computing","text":"<p>Java's influence extends far beyond its technical innovations. The language has:</p> <ul> <li>Pioneered the modern app store concept through Java applets</li> <li>Established a vast ecosystem of libraries and frameworks</li> <li>Created one of the largest developer communities worldwide</li> <li>Powered Android development, making it crucial for mobile computing</li> <li>Dominated enterprise software development</li> </ul>"},{"location":"1.Fundamentals/e_java/#the-java-platform","title":"The Java Platform","text":"<p>The Java platform consists of several key components:</p> <ol> <li>Java Programming Language: The high-level language itself</li> <li>Java Virtual Machine (JVM): The runtime environment</li> <li>Java API (Application Programming Interface): A comprehensive collection of software components</li> <li>Development Tools: Compilers, debuggers, and documentation tools</li> </ol> <p>This robust platform has made Java particularly well-suited for:</p> <ul> <li>Enterprise software development</li> <li>Mobile applications (Android)</li> <li>Web services and applications</li> <li>Embedded systems</li> <li>Big data processing</li> <li>Cloud computing</li> </ul> <p>As we delve deeper into Java fundamentals, we'll explore how these historical foundations and architectural decisions influence modern Java programming practices and why understanding them is crucial for becoming a proficient Java developer.</p>"},{"location":"1.Fundamentals/e_java/#understanding-variables-in-java","title":"Understanding Variables in Java","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-variables","title":"Introduction to Variables","text":"<p>In Java, variables serve as containers for storing data values that can be used and manipulated throughout your program. They are fundamental building blocks of any Java application, providing a way to maintain state and work with data. Understanding variables, their types, and proper naming conventions is crucial for writing clean, maintainable Java code.</p>"},{"location":"1.Fundamentals/e_java/#categories-of-variables-in-java","title":"Categories of Variables in Java","text":"<p>Java defines several distinct categories of variables, each serving a specific purpose in your programs:</p>"},{"location":"1.Fundamentals/e_java/#instance-variables-non-static-fields","title":"Instance Variables (Non-Static Fields)","text":"<p>Instance variables, also known as non-static fields, are variables declared within a class but outside any method. Each object of the class maintains its own copy of instance variables. These variables represent the object's state and persist throughout the object's lifetime.</p> <p>For example, in a  <code>Bicycle</code>  class: <pre><code>public class Bicycle {\n    // Instance variables\n    private int currentSpeed;    // Speed of this specific bicycle\n    private int gear;           // Current gear of this specific bicycle\n    private String ownerName;   // Owner of this specific bicycle\n}\n</code></pre> In this example, each  <code>Bicycle</code>  object will have its own values for  <code>currentSpeed</code>,  <code>gear</code>, and  <code>ownerName</code>, independent of other  <code>Bicycle</code>  objects.</p>"},{"location":"1.Fundamentals/e_java/#class-variables-static-fields","title":"Class Variables (Static Fields)","text":"<p>Class variables, declared with the  <code>static</code>  modifier, belong to the class itself rather than to any specific instance. All instances of the class share the same copy of these variables. They are particularly useful for representing constants or values that should be common across all instances. <pre><code>public class Bicycle {\n    // Class variable (static field)\n    private static final int MAX_GEARS = 21;    // Maximum gears for all bicycles\n    private static int totalBicycles = 0;       // Counter for all bicycles created\n}\n</code></pre> The  <code>static final</code>  combination creates a constant that cannot be modified after initialization. The  <code>totalBicycles</code>counter would be shared across all bicycle instances.</p>"},{"location":"1.Fundamentals/e_java/#local-variables","title":"Local Variables","text":"<p>Local variables are declared within methods and exist only within the scope of those methods. They must be initialized before use, as they don't receive default values. <pre><code>public void calculateSpeed(int pedalRotations) {\n    // Local variables\n    int rotationFactor = 2;\n    double speedCalculation = pedalRotations * rotationFactor * gear;\n    // Variables rotationFactor and speedCalculation only exist within this method\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#parameters","title":"Parameters","text":"<p>Parameters are variables that receive values passed to methods. They serve as a bridge for passing data into methods and are considered local to the method. <pre><code>public void changeGear(int newGear, boolean checkSafety) {\n    // newGear and checkSafety are parameters\n    if (checkSafety &amp;&amp; isGearChangeAllowed(newGear)) {\n        this.gear = newGear;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#variable-naming-conventions","title":"Variable Naming Conventions","text":"<p>Java enforces specific rules and conventions for variable names to ensure code readability and maintainability:</p>"},{"location":"1.Fundamentals/e_java/#essential-rules","title":"Essential Rules","text":"<ol> <li>Names must begin with:<ul> <li>A letter (recommended)</li> <li>Dollar sign $ (discouraged)</li> <li>Underscore _ (discouraged)</li> </ul> </li> <li>Subsequent characters can include:<ul> <li>Letters</li> <li>Numbers</li> <li>Dollar signs</li> <li>Underscores</li> </ul> </li> <li>Names cannot:<ul> <li>Begin with numbers</li> <li>Include spaces</li> <li>Use Java keywords</li> <li>Include special characters (except $ and _)</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/e_java/#best-practices","title":"Best Practices","text":"<ol> <li>Camel Case Convention<ul> <li>Single words: all lowercase</li> <li>Multiple words: first word lowercase, capitalize first letter of subsequent words <pre><code>int speed;\nint currentSpeed;\nString userFirstName;\n</code></pre></li> </ul> </li> <li> <p>Constants Naming</p> <ul> <li>All uppercase letters</li> <li>Words separated by underscores <pre><code>static final int MAX_SPEED = 100;\nstatic final double PI_VALUE = 3.14159;\n</code></pre></li> <li> <p>Descriptive Names</p> </li> <li> <p>Use complete words instead of abbreviations</p> </li> <li>Make names self-documenting <pre><code>// Good naming\nint numberOfStudents;\nString customerAddress;\n\n// Poor naming (avoid)\nint n;\nString addr;\n</code></pre></li> <li> <p>Scope-Appropriate Length</p> </li> <li> <p>Broader scope = more descriptive name</p> </li> <li>Local variables can be shorter if their purpose is clear <pre><code>// Class level (more descriptive)\nprivate List&lt;Customer&gt; activeSubscriptionCustomers;\n\n// Local variable (can be shorter if context is clear)\nfor (Customer customer : activeSubscriptionCustomers) {\n    // ...\n}\n</code></pre></li> </ul> </li> </ol> <p>Understanding initialization and default values is crucial for proper variable usage:</p>"},{"location":"1.Fundamentals/e_java/#variable-initialization-and-default-values","title":"Variable Initialization and Default Values","text":""},{"location":"1.Fundamentals/e_java/#default-values","title":"Default Values","text":"<ul> <li>Instance and class variables receive default values if not explicitly initialized:<ul> <li>Numeric types (int, long, etc.): 0</li> <li>Floating-point types (float, double): 0.0</li> <li>Boolean: false</li> <li>Object references: null <pre><code>public class DefaultValues {\n    private int number;         // Defaults to 0\n    private boolean flag;       // Defaults to false\n    private String text;        // Defaults to null\n}\n</code></pre></li> </ul> </li> </ul>"},{"location":"1.Fundamentals/e_java/#local-variable-initialization","title":"Local Variable Initialization","text":"<p>Local variables must be initialized before use: <pre><code>public void processData() {\n    int result;            // Declared but not initialized\n    // System.out.println(result);    // Would cause compilation error\n\n    result = 42;          // Must initialize before use\n    System.out.println(result);    // Now it's valid\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-variable-usage","title":"Best Practices for Variable Usage","text":"<ol> <li>Minimize Scope<ul> <li>Declare variables in the smallest scope possible</li> <li>Initialize variables as close to their usage as possible</li> </ul> </li> <li>Final Variables<ul> <li>Use  <code>final</code>  for variables that shouldn't change after initialization</li> <li>Helps prevent bugs and makes code intent clearer</li> </ul> </li> <li>Clear Purpose<ul> <li>Each variable should have a single, well-defined purpose</li> <li>Avoid reusing variables for different purposes</li> </ul> </li> <li>Documentation<ul> <li>Add comments for complex variables or when the purpose isn't immediately clear</li> <li>Consider using JavaDoc for important instance or class variables</li> </ul> </li> </ol> <p>This comprehensive understanding of Java variables and their proper usage forms the foundation for writing clean, maintainable, and efficient Java code.</p>"},{"location":"1.Fundamentals/e_java/#java-primitive-data-types-a-comprehensive-guide","title":"Java Primitive Data Types: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_1","title":"Introduction","text":"<p>In Java's type system, primitive types are the foundation of all data operations. Unlike objects, primitive types are built directly into the language and represent single, pure values. Understanding primitives is crucial because they're not just simple data containers\u2014they're the building blocks that enable efficient computation and memory usage in Java applications.</p>"},{"location":"1.Fundamentals/e_java/#the-eight-primitive-data-types","title":"The Eight Primitive Data Types","text":"<p>Let's explore each primitive type in detail, understanding not just what they are, but why and when to use them.</p>"},{"location":"1.Fundamentals/e_java/#whole-number-types","title":"Whole Number Types","text":"<p>Java provides four distinct types for representing whole numbers, each offering a different balance between memory usage and range capacity:</p>"},{"location":"1.Fundamentals/e_java/#1-byte","title":"1. byte","text":"<p><pre><code>byte smallNumber = 127;\nbyte negativeNumber = -128;\n</code></pre> Characteristics:</p> <ul> <li>Size: 8 bits</li> <li>Range: -128 to 127</li> <li>Use cases: When working with raw binary data or when memory conservation is crucial</li> <li>Real-world example: Processing binary files or handling network protocols</li> </ul> <p>When you might choose  <code>byte</code>: <pre><code>// Storing pixel color components (0-255 range fits in a byte)\nbyte redComponent = 120;\nbyte greenComponent = 85;\nbyte blueComponent = 95;\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-short","title":"2. short","text":"<p><pre><code>short mediumNumber = 32767;\nshort negativeShort = -32768;\n</code></pre> Characteristics:</p> <ul> <li>Size: 16 bits</li> <li>Range: -32,768 to 32,767</li> <li>Use cases: Representing medium-sized numbers when int would be wasteful</li> <li>Real-world example: Storing audio samples or year values <pre><code>// Using short for year storage\nshort manufacturingYear = 2024;\nshort expiryYear = 2030;\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#3-int-most-commonly-used","title":"3. int (Most Commonly Used)","text":"<p><pre><code>int population = 1000000;\nint negativeTemp = -15;\n</code></pre> Characteristics:</p> <ul> <li>Size: 32 bits</li> <li>Range: -2^31 to 2^31-1 (approximately -2 billion to 2 billion)</li> <li>Use cases: Default choice for whole numbers</li> <li>Real-world example: Counting anything within human scale <pre><code>// Practical int usage\nint totalStudents = 1250;\nint dailyVisitors = 3500;\nint productInventory = 157000;\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#4-long","title":"4. long","text":"<p><pre><code>long worldPopulation = 7_900_000_000L;  // Note the L suffix\nlong distanceToStar = 9_460_730_472_580_800L;  // Light years in meters\n</code></pre> Characteristics:</p> <ul> <li>Size: 64 bits</li> <li>Range: -2^63 to 2^63-1</li> <li>Use cases: Very large numbers or precise time measurements</li> <li>Real-world example: Storing milliseconds since epoch or astronomical distances <pre><code>// Working with time in milliseconds\nlong currentTimeMillis = System.currentTimeMillis();\nlong timeoutDuration = 3600_000L; // One hour in milliseconds\n</code></pre> </li> </ul>"},{"location":"1.Fundamentals/e_java/#floating-point-types","title":"Floating-Point Types","text":"<p>Java provides two types for handling decimal numbers:</p>"},{"location":"1.Fundamentals/e_java/#5-float","title":"5. float","text":"<p><pre><code>float temperature = 98.6f;  // Note the f suffix\nfloat pi = 3.14159f;\n</code></pre> Characteristics:</p> <ul> <li>Size: 32 bits</li> <li>Precision: About 7 decimal digits</li> <li>Use cases: When memory is critical and absolute precision isn't required</li> <li>Warning: Never use for financial calculations <pre><code>// Appropriate float usage\nfloat sensorReading = 23.45f;\nfloat windSpeed = 15.7f;\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#6-double-preferred-for-decimals","title":"6. double (Preferred for Decimals)","text":"<p><pre><code>double preciseCalculation = 3.141592653589793;\ndouble scientificNotation = 2.998e8; // Speed of light\n</code></pre> Characteristics:</p> <ul> <li>Size: 64 bits</li> <li>Precision: About 15 decimal digits</li> <li>Use cases: Default choice for decimal numbers</li> <li>Real-world example: Scientific calculations, geometric computations <pre><code>// Practical double usage\ndouble circleArea = Math.PI * radius * radius;\ndouble gravitationalForce = (G * mass1 * mass2) / (distance * distance);\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#character-and-boolean-types","title":"Character and Boolean Types","text":""},{"location":"1.Fundamentals/e_java/#7-char","title":"7. char","text":"<p><pre><code>char letter = 'A';\nchar unicode = '\\u0041'; // Same as 'A'\n</code></pre> Characteristics:</p> <ul> <li>Size: 16 bits</li> <li>Range: 0 to 65,535 (Unicode characters)</li> <li>Use cases: Single characters and Unicode symbols</li> <li>Real-world example: Text processing <pre><code>// Working with characters\nchar grade = 'B';\nchar currency = '$';\nchar copyright = '\u00a9';\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#8-boolean","title":"8. boolean","text":"<p>Characteristics:</p> <ul> <li>Size: Not strictly defined (typically 1 bit)</li> <li>Values: true or false only</li> <li>Use cases: Logical conditions and flags</li> <li>Real-world example: Status indicators <pre><code>// Boolean in practical use\nboolean isLoggedIn = true;\nboolean isEmailVerified = false;\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#default-values-and-initialization","title":"Default Values and Initialization","text":"<p>Understanding default values is crucial for working with primitive types: <pre><code>public class DefaultValues {\n    // These fields will get default values\n    byte defaultByte;          // Default: 0\n    short defaultShort;        // Default: 0\n    int defaultInt;            // Default: 0\n    long defaultLong;          // Default: 0L\n    float defaultFloat;        // Default: 0.0f\n    double defaultDouble;      // Default: 0.0d\n    char defaultChar;          // Default: '\\u0000'\n    boolean defaultBoolean;    // Default: false\n\n    public void localVariables() {\n        // Local variables must be initialized before use\n        int localVar;\n        // System.out.println(localVar); // This would cause a compilation error\n\n        localVar = 42; // Proper initialization\n        System.out.println(localVar); // Now it works\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/e_java/#1-numeric-type-selection","title":"1. Numeric Type Selection","text":"<p>Always choose the appropriate type for your needs: <pre><code>// Good practice: Using int for human-scale numbers\nint populationCity = 500000;\n\n// Good practice: Using long for very large numbers\nlong galaxyStars = 100000000000L;\n\n// Bad practice: Using long when int would suffice\nlong smallNumber = 100; // Wasteful\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-floating-point-precision","title":"2. Floating-Point Precision","text":"<p>Be aware of floating-point precision limitations: <pre><code>// Potential precision problem\ndouble result = 0.1 + 0.2;\nSystem.out.println(result); // Prints 0.30000000000000004\n\n// Better approach for money calculations\nimport java.math.BigDecimal;\nBigDecimal price = new BigDecimal(\"0.1\")\n    .add(new BigDecimal(\"0.2\"));\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-character-and-string-distinction","title":"3. Character and String Distinction","text":"<p>Understand when to use char vs String: <pre><code>// Single character - use char\nchar grade = 'A';\n\n// Text - use String\nString name = \"John\";\n\n// Bad practice: Using String for single characters\nString letterGrade = \"A\"; // Wasteful\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#4-boolean-expressions","title":"4. Boolean Expressions","text":"<p>Write clear boolean expressions: <pre><code>// Good practice: Clear boolean expressions\nboolean isEligible = age &gt;= 18 &amp;&amp; hasValidID;\n\n// Bad practice: Redundant boolean expressions\nboolean isValid = isEligible == true; // Should be just: isValid = isEligible\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#memory-efficiency-and-performance-considerations","title":"Memory Efficiency and Performance Considerations","text":"<p>Understanding memory usage helps write more efficient code: <pre><code>public class MemoryExample {\n    // Memory-efficient array for small numbers (-128 to 127)\n    byte[] smallNumbers = new byte[1000];     // Uses 1KB\n\n    // Less efficient for same number range\n    Integer[] boxedNumbers = new Integer[1000]; // Uses much more memory\n\n    // Efficient primitive array\n    int[] mediumNumbers = new int[1000];      // Uses 4KB\n\n    public void demonstrateEfficiency() {\n        // Efficient primitive operations\n        for (int i = 0; i &lt; smallNumbers.length; i++) {\n            smallNumbers[i]++; // Direct operation, very fast\n        }\n\n        // Less efficient boxed operations\n        for (int i = 0; i &lt; boxedNumbers.length; i++) {\n            boxedNumbers[i] = boxedNumbers[i] + 1; // Involves unboxing/boxing\n        }\n    }\n}\n</code></pre> This guide provides a solid foundation for understanding Java's primitive types. Remember that choosing the right primitive type is crucial for both program correctness and performance. While objects provide more functionality, primitives are the bedrock of efficient Java programs.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-arrays-a-comprehensive-guide","title":"Understanding Java Arrays: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-arrays","title":"Introduction to Arrays","text":"<p>An array in Java is a fundamental data structure that allows you to store multiple values of the same type in a single, ordered container. Think of an array as a row of boxes, where each box can hold one item, and each box has a number (index) that helps you find it quickly. This organization makes arrays essential for managing collections of related data efficiently.</p>"},{"location":"1.Fundamentals/e_java/#core-concepts","title":"Core Concepts","text":""},{"location":"1.Fundamentals/e_java/#array-structure-and-indexing","title":"Array Structure and Indexing","text":"<p>When you create an array, Java allocates a continuous block of memory to store your values. Each position in this block is numbered, starting from 0. This numbering system, called zero-based indexing, means that in an array of 8 elements, the valid indices are 0 through 7. <pre><code>// Creating and initializing an array of temperatures\ndouble[] temperatures = new double[7];  // Creates space for 7 daily temperatures\n\n// Storing values using indices\ntemperatures[0] = 72.5;  // First element (Sunday)\ntemperatures[1] = 73.2;  // Second element (Monday)\ntemperatures[2] = 74.0;  // Third element (Tuesday)\n// ... and so on\n</code></pre> Understanding zero-based indexing is crucial because it's different from how we typically count in everyday life. When we talk about the \"first\" element, we're actually referring to index 0.</p>"},{"location":"1.Fundamentals/e_java/#array-declaration-and-creation","title":"Array Declaration and Creation","text":"<p>Java provides several ways to declare and create arrays, each suited to different situations: <pre><code>// Method 1: Declaration and creation in separate steps\nint[] scores;           // Declaration\nscores = new int[5];    // Creation\n\n// Method 2: Declaration and creation in one step\nint[] grades = new int[10];\n\n// Method 3: Declaration with initialization\nint[] primeNumbers = {2, 3, 5, 7, 11, 13};\n\n// Method 4: Array of objects\nString[] daysOfWeek = new String[7];\n</code></pre> When you create an array using  <code>new</code>, Java automatically initializes each element with a default value:</p> <ul> <li>Numeric types (int, long, etc.): 0</li> <li>Floating-point types (float, double): 0.0</li> <li>Boolean: false</li> <li>Object references: null</li> </ul>"},{"location":"1.Fundamentals/e_java/#working-with-array-elements","title":"Working with Array Elements","text":"<p>Accessing and modifying array elements is straightforward, but requires careful attention to array bounds: <pre><code>public class ArrayOperationsExample {\n    public static void main(String[] args) {\n        // Creating an array of student scores\n        int[] scores = new int[5];\n\n        // Setting values\n        scores[0] = 95;  // First student's score\n        scores[1] = 87;  // Second student's score\n        scores[2] = 92;  // Third student's score\n        scores[3] = 88;  // Fourth student's score\n        scores[4] = 91;  // Fifth student's score\n\n        // Reading values\n        System.out.println(\"First student's score: \" + scores[0]);\n\n        // Calculating average score\n        double sum = 0;\n        for (int score : scores) {\n            sum += score;\n        }\n        double average = sum / scores.length;\n        System.out.println(\"Class average: \" + average);\n    }\n}\n</code></pre> </p>"},{"location":"1.Fundamentals/e_java/#multi-dimensional-arrays","title":"Multi-dimensional Arrays","text":"<p>Java supports multi-dimensional arrays, which are essentially arrays of arrays. These are particularly useful for representing grids, matrices, or tables: <pre><code>public class ChessboardExample {\n    public static void main(String[] args) {\n        // Creating a 2D array to represent a chessboard\n        String[][] chessboard = new String[8][8];\n\n        // Initialize the board with some pieces\n        chessboard[0][0] = \"Rook\";\n        chessboard[0][1] = \"Knight\";\n        chessboard[0][2] = \"Bishop\";\n        // ... rest of the initialization\n\n        // Accessing elements\n        System.out.println(\"Piece at A1: \" + chessboard[0][0]);\n\n        // You can have arrays with different lengths in each row\n        int[][] triangularArray = {\n            {1},\n            {1, 2},\n            {1, 2, 3},\n            {1, 2, 3, 4}\n        };\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#common-array-operations","title":"Common Array Operations","text":""},{"location":"1.Fundamentals/e_java/#copying-arrays","title":"Copying Arrays","text":"<p>Java provides several ways to copy arrays, each with its own use case: <pre><code>public class ArrayCopyExample {\n    public static void main(String[] args) {\n        int[] source = {1, 2, 3, 4, 5};\n\n        // Method 1: Using System.arraycopy()\n        int[] destination1 = new int[5];\n        System.arraycopy(source, 0, destination1, 0, source.length);\n\n        // Method 2: Using Arrays.copyOf()\n        int[] destination2 = Arrays.copyOf(source, source.length);\n\n        // Method 3: Using clone()\n        int[] destination3 = source.clone();\n\n        // Method 4: Manual copy (less efficient)\n        int[] destination4 = new int[source.length];\n        for (int i = 0; i &lt; source.length; i++) {\n            destination4[i] = source[i];\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#array-utility-methods","title":"Array Utility Methods","text":"<p>The  <code>java.util.Arrays</code>  class provides powerful methods for working with arrays: <pre><code>public class ArrayUtilitiesExample {\n    public static void main(String[] args) {\n        int[] numbers = {5, 2, 8, 1, 9, 3};\n\n        // Sorting an array\n        Arrays.sort(numbers);\n        System.out.println(\"Sorted array: \" + Arrays.toString(numbers));\n\n        // Binary search (array must be sorted first)\n        int index = Arrays.binarySearch(numbers, 8);\n        System.out.println(\"Found 8 at index: \" + index);\n\n        // Checking equality\n        int[] numbers2 = {1, 2, 3, 5, 8, 9};\n        boolean areEqual = Arrays.equals(numbers, numbers2);\n        System.out.println(\"Arrays are equal: \" + areEqual);\n\n        // Filling an array\n        int[] newArray = new int[5];\n        Arrays.fill(newArray, 42);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_1","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/e_java/#array-bounds-and-exception-handling","title":"Array Bounds and Exception Handling","text":"<p>Always validate array indices to prevent ArrayIndexOutOfBoundsException: <pre><code>public class SafeArrayAccess {\n    public static void accessArray(int[] array, int index) {\n        // Always check bounds before accessing\n        if (index &gt;= 0 &amp;&amp; index &lt; array.length) {\n            System.out.println(\"Value at index \" + index + \": \" + array[index]);\n        } else {\n            System.out.println(\"Index \" + index + \" is out of bounds\");\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#memory-management","title":"Memory Management","text":"<p>Understanding array sizing and memory implications: <pre><code>public class ArrayMemoryExample {\n    public static void main(String[] args) {\n        // Be cautious with very large arrays\n        int[] largeArray = new int[1000000];  // Approximately 4MB of memory\n\n        // Consider using ArrayList for dynamic sizing\n        ArrayList&lt;Integer&gt; dynamicArray = new ArrayList&lt;&gt;();\n        // ArrayList grows as needed\n\n        // Clear references when done\n        largeArray = null;  // Allows garbage collection\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#performance-considerations","title":"Performance Considerations","text":"<p>Arrays provide constant-time access to elements but have fixed size: <pre><code>public class ArrayPerformanceExample {\n    public static void main(String[] args) {\n        int[] numbers = new int[1000000];\n\n        // Fast: Direct access by index\n        long startTime = System.nanoTime();\n        int value = numbers[500000];  // O(1) operation\n        long endTime = System.nanoTime();\n\n        // Slower: Finding a value without knowing its index\n        for (int i = 0; i &lt; numbers.length; i++) {\n            if (numbers[i] == value) {\n                // Found it\n                break;\n            }\n        }  // O(n) operation\n    }\n}\n</code></pre> Understanding these concepts and practices will help you use arrays effectively in your Java programs while avoiding common pitfalls and performance issues.</p>"},{"location":"1.Fundamentals/e_java/#understanding-javas-var-type-identifier-local-variable-type-inference","title":"Understanding Java's var Type Identifier: Local Variable Type Inference","text":""},{"location":"1.Fundamentals/e_java/#introduction_2","title":"Introduction","text":"<p>Java introduced the  <code>var</code>  type identifier in Java SE 10 as part of a feature called \"Local Variable Type Inference.\" This feature represents an important evolution in Java's type system, allowing developers to write clearer, more concise code while maintaining Java's strong type safety. Let's explore how  <code>var</code>  works, when to use it, and most importantly, when not to use it.</p>"},{"location":"1.Fundamentals/e_java/#understanding-type-inference","title":"Understanding Type Inference","text":"<p>When we use  <code>var</code>, we're not making Java dynamically typed - we're simply asking the compiler to determine the type for us. Think of  <code>var</code>  as telling the compiler: \"You can see what's on the right side of the assignment, so you figure out the type.\" The compiler then sets that type permanently for the variable.</p> <p>Let's see how this works with a simple example: <pre><code>// Traditional explicit typing\nString message = \"Hello, World!\";\n\n// Using var - compiler infers String type\nvar inferredMessage = \"Hello, World!\";\n</code></pre> In both cases,  <code>message</code>  and  <code>inferredMessage</code>  are strongly typed as  <code>String</code>. The only difference is who specified the type - we did in the first case, the compiler did in the second.</p>"},{"location":"1.Fundamentals/e_java/#practical-applications","title":"Practical Applications","text":""},{"location":"1.Fundamentals/e_java/#basic-variable-declaration","title":"Basic Variable Declaration","text":"<p>Let's explore how  <code>var</code>  can make code more readable, especially with complex types: <pre><code>// Before var - type repeated on both sides\nArrayList&lt;String&gt; studentNames = new ArrayList&lt;String&gt;();\n\n// With var - cleaner but still strongly typed\nvar studentNames = new ArrayList&lt;String&gt;();\n\n// Works with complex types too\nvar responseHandler = new HashMap&lt;Integer, List&lt;String&gt;&gt;();\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#working-with-stream-operations","title":"Working with Stream Operations","text":"<p><code>var</code>  shines when working with intermediate variables in stream operations: <pre><code>// Reading and processing file content\npublic void processLogFile(String filename) {\n    try {\n        var path = Path.of(filename);\n        var lines = Files.readAllLines(path);\n\n        // Using var in stream operations\n        var errorLines = lines.stream()\n            .filter(line -&gt; line.startsWith(\"ERROR\"))\n            .collect(Collectors.toList());\n\n        processErrors(errorLines);\n    } catch (IOException e) {\n        System.err.println(\"Error processing file: \" + e.getMessage());\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#enhanced-for-loops","title":"Enhanced For Loops","text":"<p><code>var</code>  can make loop constructs more readable: <pre><code>public void processOrders(List&lt;Order&gt; orders) {\n    // Using var in enhanced for loop\n    for (var order : orders) {\n        // The compiler knows 'order' is of type Order\n        processOrderDetails(order.getDetails());\n        updateInventory(order.getItems());\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#important-limitations-and-best-practices","title":"Important Limitations and Best Practices","text":""},{"location":"1.Fundamentals/e_java/#where-var-cannot-be-used","title":"Where var Cannot Be Used","text":"<p>Understanding where  <code>var</code>  cannot be used is crucial for effective Java development: <pre><code>public class VarLimitationsExample {\n    // Cannot use var for fields\n    private var field = \"Not allowed\";  // Won't compile\n\n    // Cannot use var for method parameters\n    public void process(var data) {     // Won't compile\n        // method body\n    }\n\n    // Cannot use var without initialization\n    public void wrongUsage() {\n        var uninitializedVar;           // Won't compile\n\n        // Cannot infer type from null\n        var nullValue = null;           // Won't compile\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-using-var","title":"Best Practices for Using var","text":"<p>Let's explore when you should and shouldn't use  <code>var</code>: <pre><code>public class VarBestPractices {\n    public void demonstrateGoodUsage() {\n        // Good: Type is clear from initialization\n        var userName = \"JohnDoe\";\n        var userAge = 25;\n\n        // Good: Long generic type declarations\n        var userMap = new HashMap&lt;String, List&lt;UserPreference&gt;&gt;();\n\n        // Good: In try-with-resources\n        try (var fileReader = new BufferedReader(new FileReader(\"data.txt\"))) {\n            // Process file\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void demonstrateQuestionableUsage() {\n        // Questionable: Type not immediately clear\n        var result = someMethod();  // What type is this?\n\n        // Better: Be explicit when type clarity matters\n        ActionResult result = someMethod();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-type-inference-rules","title":"Understanding Type Inference Rules","text":"<p>The compiler follows specific rules when inferring types: <pre><code>public class TypeInferenceExamples {\n    public void demonstrateInference() {\n        // Infers exact type\n        var list = List.of(\"a\", \"b\", \"c\");  // List&lt;String&gt;\n\n        // Infers common supertype\n        var numbers = List.of(1, 2.0, 3L);  // List&lt;Number&gt;\n\n        // Infers intersection type if necessary\n        var runnable = (Runnable &amp; AutoCloseable)() -&gt; {\n            // Implementation\n        };\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#improving-code-readability","title":"Improving Code Readability","text":"<p>Using  <code>var</code>  effectively can make your code more readable by reducing redundancy while maintaining type safety: <pre><code>public class ReadabilityExample {\n    public void processData() {\n        // Without var - type repeated\n        BufferedReader bufferedReader = new BufferedReader(new FileReader(\"data.txt\"));\n\n        // With var - cleaner but still type-safe\n        var reader = new BufferedReader(new FileReader(\"data.txt\"));\n\n        // Complex generic types become more manageable\n        var processors = new ArrayList&lt;Function&lt;String, Optional&lt;ProcessedData&gt;&gt;&gt;();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-and-how-to-avoid-them","title":"Common Pitfalls and How to Avoid Them","text":"<p>Understanding potential issues helps prevent common mistakes: <pre><code>public class VarPitfalls {\n    public void demonstratePitfalls() {\n        // Pitfall 1: Loss of type information\n        var number = 42;  // Is this meant to be int, long, Integer?\n\n        // Better: Be explicit when type matters\n        int specificNumber = 42;\n\n        // Pitfall 2: Unexpected types\n        var size = 100;  // int\n        var longSize = 100L;  // long\n\n        // Pitfall 3: Diamond operator confusion\n        var list = new ArrayList&lt;&gt;();  // Raw type!\n        // Better:\n        var typedList = new ArrayList&lt;String&gt;();\n    }\n}\n</code></pre> By understanding these concepts, limitations, and best practices, you can effectively use <code>var</code> to write cleaner, more maintainable Java code while maintaining the language's strong type safety guarantees.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-operators-from-basics-to-advanced-usage","title":"Understanding Java Operators: From Basics to Advanced Usage","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-operators","title":"Introduction to Operators","text":"<p>Operators are the foundation of any programming language's ability to manipulate data. In Java, operators are special symbols that perform specific operations on one, two, or three operands and return a result. Think of operators as the verbs of programming\u2014they're what make things happen in your code.</p>"},{"location":"1.Fundamentals/e_java/#operator-precedence-the-order-of-operations","title":"Operator Precedence: The Order of Operations","text":"<p>Just as in mathematics, Java follows specific rules about which operations happen first. Let's understand this through a practical example: <pre><code>public class OperatorPrecedenceExample {\n    public static void main(String[] args) {\n        int result = 5 + 3 * 2;  // What will this be?\n\n        // Let's break it down:\n        // 1. Multiplication happens first: 3 * 2 = 6\n        // 2. Then addition: 5 + 6 = 11\n        System.out.println(\"5 + 3 * 2 = \" + result);  // Prints 11\n\n        // Using parentheses changes the order\n        result = (5 + 3) * 2;\n        // 1. Parentheses first: 5 + 3 = 8\n        // 2. Then multiplication: 8 * 2 = 16\n        System.out.println(\"(5 + 3) * 2 = \" + result);  // Prints 16\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#arithmetic-operators-the-building-blocks","title":"Arithmetic Operators: The Building Blocks","text":"<p>Let's explore how Java handles basic mathematical operations: <pre><code>public class ArithmeticOperatorsDemo {\n    public static void main(String[] args) {\n        // Basic arithmetic operations\n        int a = 10;\n        int b = 3;\n\n        System.out.println(\"Addition: \" + (a + b));        // 13\n        System.out.println(\"Subtraction: \" + (a - b));     // 7\n        System.out.println(\"Multiplication: \" + (a * b));  // 30\n        System.out.println(\"Division: \" + (a / b));        // 3 (integer division!)\n        System.out.println(\"Modulus: \" + (a % b));         // 1 (remainder)\n\n        // Understanding floating-point division\n        double c = 10.0;\n        System.out.println(\"Float division: \" + (c / b));  // 3.3333...\n\n        // The power of compound assignments\n        int sum = 0;\n        sum += 5;  // Same as: sum = sum + 5\n        System.out.println(\"After += 5: \" + sum);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-increment-and-decrement","title":"Understanding Increment and Decrement","text":"<p>The increment (++) and decrement (--) operators might seem simple, but they have subtle complexities: <pre><code>public class IncrementDecrementDemo {\n    public static void main(String[] args) {\n        int x = 5;\n\n        // Postfix increment: use value, then increment\n        System.out.println(x++);  // Prints 5\n        System.out.println(x);    // Prints 6\n\n        // Prefix increment: increment first, then use value\n        x = 5;  // Reset x\n        System.out.println(++x);  // Prints 6\n        System.out.println(x);    // Prints 6\n\n        // Real-world example: loop counting\n        for (int i = 0; i &lt; 3; i++) {\n            System.out.println(\"Loop iteration: \" + i);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#comparison-and-logical-operators-making-decisions","title":"Comparison and Logical Operators: Making Decisions","text":"<p>These operators form the backbone of program logic and decision-making: <pre><code>public class LogicalOperatorsDemo {\n    public static void main(String[] args) {\n        int age = 25;\n        boolean hasLicense = true;\n\n        // Comparison operators\n        System.out.println(\"Is adult? \" + (age &gt;= 18));\n\n        // Logical AND: both conditions must be true\n        boolean canDrive = age &gt;= 16 &amp;&amp; hasLicense;\n        System.out.println(\"Can drive? \" + canDrive);\n\n        // Short-circuit evaluation\n        boolean result = false &amp;&amp; expensiveOperation();  // expensiveOperation never runs!\n\n        // Common pitfall: equality vs assignment\n        int value = 5;\n        if (value == 5) {  // Comparison: correct\n            System.out.println(\"Value is 5\");\n        }\n\n        // if (value = 5) { // Bug: assignment, not comparison!\n        //     System.out.println(\"This would always be true!\");\n        // }\n    }\n\n    private static boolean expensiveOperation() {\n        System.out.println(\"This won't print due to short-circuiting\");\n        return true;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#the-ternary-operator-elegant-conditionals","title":"The Ternary Operator: Elegant Conditionals","text":"<p>The ternary operator provides a concise way to write simple if-else statements: <pre><code>public class TernaryOperatorDemo {\n    public static void main(String[] args) {\n        int score = 85;\n\n        // Traditional if-else\n        String result;\n        if (score &gt;= 60) {\n            result = \"Pass\";\n        } else {\n            result = \"Fail\";\n        }\n\n        // Same logic with ternary operator\n        String result2 = score &gt;= 60 ? \"Pass\" : \"Fail\";\n\n        // When to use ternary\n        // Good: Simple, clear condition and results\n        String status = age &gt;= 18 ? \"Adult\" : \"Minor\";\n\n        // Bad: Complex conditions or multiple operations\n        // Avoid: status = age &gt;= 18 ? hasLicense ? \"Driver\" : \"Adult\" : \"Minor\";\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#bitwise-operators-low-level-operations","title":"Bitwise Operators: Low-Level Operations","text":"<p>While less commonly used in everyday programming, bitwise operators are crucial for certain operations: <pre><code>public class BitwiseOperatorsDemo {\n    public static void main(String[] args) {\n        // Binary representation\n        int a = 5;  // 101 in binary\n        int b = 3;  // 011 in binary\n\n        // Bitwise AND\n        System.out.println(\"5 &amp; 3 = \" + (a &amp; b));  // 1 (001 in binary)\n\n        // Common use case: flags and permissions\n        final int READ = 4;    // 100 in binary\n        final int WRITE = 2;   // 010 in binary\n        final int EXECUTE = 1; // 001 in binary\n\n        int permissions = READ | WRITE;  // Combine permissions\n        boolean canRead = (permissions &amp; READ) != 0;  // Check permission\n\n        System.out.println(\"Can read? \" + canRead);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-operator-concepts","title":"Advanced Operator Concepts","text":""},{"location":"1.Fundamentals/e_java/#understanding-type-promotion","title":"Understanding Type Promotion","text":"<p>Java automatically promotes smaller types to larger ones during operations: <pre><code>public class TypePromotionDemo {\n    public static void main(String[] args) {\n        byte b = 42;\n        char c = 'a';\n        short s = 1024;\n        int i = 50000;\n        float f = 5.67f;\n        double d = .1234;\n\n        // Expression type promotion\n        double result = (f * b) + (i / c) - (d * s);\n\n        // The expression is evaluated with all values promoted to double\n        System.out.println(\"Complex expression result: \" + result);\n\n        // Integer division pitfall\n        System.out.println(\"10 / 3 = \" + (10 / 3));      // Prints 3\n        System.out.println(\"10.0 / 3 = \" + (10.0 / 3));  // Prints 3.3333...\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#string-concatenation","title":"String Concatenation","text":"<p>The + operator has special behavior with strings: <pre><code>public class StringConcatenationDemo {\n    public static void main(String[] args) {\n        String str = \"Hello\";\n        int num = 42;\n\n        // String concatenation with different types\n        System.out.println(str + \" World! Number = \" + num);\n\n        // Watch out for operator precedence\n        System.out.println(1 + 2 + \" = Three\");   // Prints \"3 = Three\"\n        System.out.println(\"Three = \" + 1 + 2);   // Prints \"Three = 12\"\n        System.out.println(\"Three = \" + (1 + 2)); // Prints \"Three = 3\"\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_2","title":"Best Practices and Common Pitfalls","text":"<ol> <li>Always consider operator precedence - use parentheses when in doubt</li> <li>Be careful with integer division - explicitly convert to double if you need decimal precision</li> <li>Avoid complex nested ternary operators</li> <li>Be mindful of short-circuit evaluation in logical operations</li> <li>Use explicit parentheses in complex arithmetic expressions</li> <li>Remember that == compares references for objects, not content</li> </ol> <p>By understanding these operators and their nuances, you'll be better equipped to write clear, correct, and efficient Java code. Remember that while operators are powerful tools, clarity should always be your primary goal when writing code.</p>"},{"location":"1.Fundamentals/e_java/#java-operators-a-complete-reference-and-learning-guide","title":"Java Operators: A Complete Reference and Learning Guide","text":""},{"location":"1.Fundamentals/e_java/#understanding-the-foundation-of-java-operations","title":"Understanding the Foundation of Java Operations","text":"<p>Think of operators as the basic tools in your Java programming toolkit. Just as a carpenter needs to understand how each tool works and when to use it, a Java developer must master operators to write effective code. Let's explore each type of operator, understanding not just how they work, but why they're designed this way and when to use them.</p>"},{"location":"1.Fundamentals/e_java/#simple-assignment-operator","title":"Simple Assignment Operator (=)","text":"<p>The assignment operator might seem straightforward, but it's worth understanding its nuances: <pre><code>public class AssignmentExampleGuide {\n    public static void main(String[] args) {\n        // Simple assignment creates a copy of the value\n        int firstNumber = 42;\n        int secondNumber = firstNumber;  // secondNumber gets a copy of 42\n\n        // Understanding reference assignment\n        StringBuilder text1 = new StringBuilder(\"Hello\");\n        StringBuilder text2 = text1;  // Both variables now point to the same object\n\n        // Demonstrating the difference\n        secondNumber = 100;  // Doesn't affect firstNumber\n        text2.append(\" World\");  // Affects what text1 sees too\n\n        System.out.println(\"firstNumber: \" + firstNumber);  // Still 42\n        System.out.println(\"text1: \" + text1);  // Shows \"Hello World\"\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#arithmetic-operators-beyond-basic-math","title":"Arithmetic Operators: Beyond Basic Math","text":"<p>Arithmetic operators do more than just calculate numbers. Let's explore their full capabilities: <pre><code>public class ArithmeticGuide {\n    public static void main(String[] args) {\n        // The division operator has different behavior for integers and decimals\n        System.out.println(\"Integer division: 5 / 2 = \" + (5 / 2));        // 2\n        System.out.println(\"Decimal division: 5.0 / 2 = \" + (5.0 / 2));    // 2.5\n\n        // The modulus operator: not just for remainders\n        // Common uses include:\n\n        // 1. Checking even/odd\n        int number = 7;\n        boolean isEven = (number % 2 == 0);\n\n        // 2. Wrapping around a range (like clock hours)\n        int hour = 25;\n        int clockHour = hour % 12;\n        if (clockHour == 0) clockHour = 12;\n        System.out.println(\"25th hour is \" + clockHour + \" o'clock\");\n\n        // 3. String concatenation with +\n        String firstName = \"John\";\n        String lastName = \"Doe\";\n        int age = 30;\n        // + operator automatically converts numbers to strings\n        String description = firstName + \" \" + lastName + \" is \" + age;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#unary-operators-single-operand-powers","title":"Unary Operators: Single Operand Powers","text":"<p>Unary operators work with one value, but their effects can be profound: <pre><code>public class UnaryOperatorGuide {\n    public static void main(String[] args) {\n        // Increment/Decrement operators: subtle but important differences\n        int count = 5;\n\n        // Postfix vs Prefix: timing matters\n        System.out.println(count++);  // Shows 5, then increments to 6\n        System.out.println(++count);  // Increments to 7, then shows 7\n\n        // The logical complement operator (!) in practice\n        boolean isValid = true;\n\n        // Understanding double negation\n        boolean isNotNotValid = !!isValid;  // Still true\n\n        // Real-world example: Toggling states\n        boolean lightIsOn = false;\n\n        void toggleLight() {\n            lightIsOn = !lightIsOn;  // Elegant way to toggle\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#equality-and-relational-operators-making-comparisons","title":"Equality and Relational Operators: Making Comparisons","text":"<p>These operators form the basis of decision-making in your programs: <pre><code>public class ComparisonGuide {\n    public static void main(String[] args) {\n        // Comparing numbers is straightforward\n        int x = 5, y = 10;\n        boolean isLess = x &lt; y;  // true\n\n        // But comparing objects requires careful thought\n        String str1 = new String(\"Hello\");\n        String str2 = new String(\"Hello\");\n\n        // Understanding == vs .equals()\n        System.out.println(str1 == str2);         // false: different objects\n        System.out.println(str1.equals(str2));    // true: same content\n\n        // A practical example with numeric ranges\n        int score = 85;\n        boolean isPassingGrade = score &gt;= 60 &amp;&amp; score &lt;= 100;\n\n        // Chaining comparisons (unlike mathematics, Java needs explicit operators)\n        // This won't work: 0 &lt;= age &lt;= 100\n        int age = 25;\n        boolean isValidAge = age &gt;= 0 &amp;&amp; age &lt;= 100;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conditional-operators-making-smart-choices","title":"Conditional Operators: Making Smart Choices","text":"<p>Conditional operators help write more concise and efficient code: <pre><code>public class ConditionalGuide {\n    public static void main(String[] args) {\n        // Understanding short-circuit evaluation\n        int divisor = 0;\n\n        // This is safe because the second part isn't evaluated if divisor is 0\n        if (divisor != 0 &amp;&amp; (100 / divisor) &gt; 5) {\n            System.out.println(\"Large quotient\");\n        }\n\n        // The ternary operator: powerful but use wisely\n        int age = 20;\n\n        // Good use of ternary: simple, clear condition and results\n        String status = age &gt;= 18 ? \"adult\" : \"minor\";\n\n        // Bad use of ternary: too complex, hard to read\n        // String message = age &gt;= 18 ? \n        //     balance &gt; 100 ? \"adult with money\" : \"adult without money\" :\n        //     \"minor\";\n\n        // Better as traditional if-else:\n        String message;\n        if (age &gt;= 18) {\n            message = balance &gt; 100 ? \"adult with money\" : \"adult without money\";\n        } else {\n            message = \"minor\";\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#type-comparison-and-bitwise-operators-specialized-tools","title":"Type Comparison and Bitwise Operators: Specialized Tools","text":"<p>These operators are like specialized tools - not used every day, but invaluable when needed: <pre><code>public class SpecializedOperatorsGuide {\n    public static void main(String[] args) {\n        // instanceof: Safe type checking\n        Object obj = \"Hello\";\n\n        // Traditional approach\n        if (obj instanceof String) {\n            String str = (String) obj;\n            System.out.println(str.toUpperCase());\n        }\n\n        // Bitwise operators: Working with flags\n        final int READ_PERMISSION = 4;    // 100 in binary\n        final int WRITE_PERMISSION = 2;   // 010 in binary\n        final int EXECUTE_PERMISSION = 1;  // 001 in binary\n\n        // Combining permissions using bitwise OR\n        int userPermissions = READ_PERMISSION | WRITE_PERMISSION;\n\n        // Checking permissions using bitwise AND\n        boolean canRead = (userPermissions &amp; READ_PERMISSION) != 0;\n        boolean canWrite = (userPermissions &amp; WRITE_PERMISSION) != 0;\n\n        // Bit shifting: Understanding the power\n        int value = 8;  // 1000 in binary\n        System.out.println(value &gt;&gt; 1);   // 4 (100 in binary)\n        System.out.println(value &lt;&lt; 1);   // 16 (10000 in binary)\n    }\n}\n</code></pre> Understanding these operators deeply will help you write more efficient and maintainable code. Remember that while all operators are tools at your disposal, the key is knowing when to use each one to write clear, correct, and efficient code.</p> <p>The best developers not only know how to use these operators but also understand when a simpler approach might make their code more readable and maintainable. As you continue your Java journey, you'll develop an intuition for which operator best suits each situation.</p>"},{"location":"1.Fundamentals/e_java/#understanding-javas-building-blocks-expressions-statements-and-blocks","title":"Understanding Java's Building Blocks: Expressions, Statements, and Blocks","text":""},{"location":"1.Fundamentals/e_java/#introduction_3","title":"Introduction","text":"<p>Think of Java code as being similar to written language: if expressions are like words and phrases, statements are like complete sentences, and blocks are like paragraphs. Understanding how these elements work together is crucial for writing clear, effective Java programs.</p>"},{"location":"1.Fundamentals/e_java/#expressions-the-basic-units-of-computation","title":"Expressions: The Basic Units of Computation","text":"<p>An expression is any code that evaluates to a single value. Just as we combine words to create meaning in language, we combine variables, operators, and method calls to create expressions in Java.</p>"},{"location":"1.Fundamentals/e_java/#simple-expressions","title":"Simple Expressions","text":"<p>Let's start with basic expressions and build up to more complex ones: <pre><code>public class ExpressionBasics {\n    public static void main(String[] args) {\n        // Literal expressions - evaluate to themselves\n        int simpleNumber = 42;        // 42 is an expression\n        String message = \"Hello\";      // \"Hello\" is an expression\n\n        // Variable expressions\n        int x = 5;\n        int y = x;                    // x is an expression\n\n        // Arithmetic expressions\n        int sum = x + 10;             // x + 10 is an expression\n        int product = sum * 3;        // sum * 3 is an expression\n\n        // Method call expressions\n        String name = \"World\";\n        String greeting = name.toUpperCase();  // name.toUpperCase() is an expression\n\n        // Even a line that looks like pure calculation is an expression\n        System.out.println(sum);      // sum is an expression here too\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#compound-expressions","title":"Compound Expressions","text":"<p>Compound expressions combine multiple simpler expressions. Understanding how they're evaluated is crucial: <pre><code>public class CompoundExpressions {\n    public static void main(String[] args) {\n        int a = 5, b = 3, c = 2;\n\n        // Compound arithmetic expression\n        int result = a * b + c;   // Multiplication happens before addition\n\n        // Making evaluation order explicit with parentheses\n        int resultWithParens = a * (b + c);  // Addition happens before multiplication\n\n        // Complex example breaking down evaluation steps\n        int complexResult = (a + b) * (c + 1) / 2;\n        // Let's break this down:\n        // 1. (a + b) = (5 + 3) = 8\n        // 2. (c + 1) = (2 + 1) = 3\n        // 3. 8 * 3 = 24\n        // 4. 24 / 2 = 12\n\n        System.out.println(\"Complex result: \" + complexResult);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#statements-complete-units-of-execution","title":"Statements: Complete Units of Execution","text":"<p>A statement is a complete unit of execution, like a complete sentence in language. Understanding different types of statements helps write clearer code: <pre><code>public class StatementTypes {\n    public static void main(String[] args) {\n        // Declaration statements\n        int counter;                   // Simple declaration\n        double price = 19.99;         // Declaration with initialization\n\n        // Expression statements\n        counter = 1;                  // Assignment statement\n        counter++;                    // Increment statement\n        System.out.println(counter);  // Method invocation statement\n\n        // Control flow statements\n        if (counter &gt; 0) {           // If statement\n            System.out.println(\"Counter is positive\");\n        }\n\n        // Multiple statements work together\n        for (int i = 0; i &lt; 3; i++) {    // For statement\n            counter += i;                 // Compound assignment statement\n            System.out.println(counter);  // Method invocation statement\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-statement-completion","title":"Understanding Statement Completion","text":"<p>Each statement in Java must be complete and properly terminated: <pre><code>public class StatementCompletion {\n    public static void main(String[] args) {\n        // Complete statements end with semicolons\n        int x = 5;\n\n        // A common mistake is forgetting semicolons\n        // int y = 10   // This would cause a compiler error\n\n        // Some statements don't use semicolons\n        if (x &gt; 0) {    // No semicolon here\n            x--;        // Semicolon needed here\n        }               // No semicolon here\n\n        // Method declarations don't use semicolons\n        void someMethod() {  // No semicolon\n            // Method body\n        }                    // No semicolon\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#blocks-organizing-code-into-logical-groups","title":"Blocks: Organizing Code into Logical Groups","text":"<p>Blocks group statements together, creating scope and structure in your code: <pre><code>public class BlockStructure {\n    public static void main(String[] args) {\n        // A block creates its own scope\n        {\n            int localVar = 42;  // This variable only exists in this block\n            System.out.println(localVar);\n        }\n        // localVar doesn't exist here\n\n        // Blocks are often used with control statements\n        int temperature = 75;\n\n        if (temperature &gt; 70) {\n            String status = \"Warm\";\n            System.out.println(status);\n        } // status variable dies here\n\n        // Nested blocks demonstrate scope levels\n        {\n            int outer = 1;\n            {\n                int inner = 2;\n                System.out.println(outer + inner);  // Can access both\n            }\n            // inner is not available here\n        }\n        // neither variable is available here\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#real-world-block-usage","title":"Real-World Block Usage","text":"<p>Understanding how blocks affect scope and visibility is crucial for writing maintainable code: <pre><code>public class BlockUsagePatterns {\n    public static void main(String[] args) {\n        // Using blocks for resource management\n        {\n            // Resource initialization\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"Hello\");\n            builder.append(\" World\");\n            System.out.println(builder.toString());\n            // Builder automatically eligible for garbage collection after block\n        }\n\n        // Blocks for temporary variable scope\n        int result;\n        {\n            int tempValue = 42;\n            int multiplier = 2;\n            result = tempValue * multiplier;\n        }\n        // tempValue and multiplier are gone, but result remains\n\n        // Blocks in loops\n        for (int i = 0; i &lt; 3; i++) {\n            // This entire block runs for each iteration\n            int temporary = i * 2;\n            System.out.println(temporary);\n            // temporary is recreated each iteration\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#special-considerations-for-floating-point-expressions","title":"Special Considerations for Floating-Point Expressions","text":"<p>Floating-point arithmetic requires special attention due to precision issues: <pre><code>public class FloatingPointConsiderations {\n    public static void main(String[] args) {\n        // This might not be what you expect\n        double result = 0.1 + 0.2;\n        System.out.println(result);  // Prints 0.30000000000000004\n\n        // For monetary calculations, use BigDecimal\n        BigDecimal price1 = new BigDecimal(\"0.10\");\n        BigDecimal price2 = new BigDecimal(\"0.20\");\n        BigDecimal total = price1.add(price2);\n        System.out.println(total);  // Prints exactly 0.30\n\n        // Comparing floating-point numbers\n        double a = 0.1 + 0.2;\n        double b = 0.3;\n\n        // Don't do this\n        // if (a == b) // Might not work as expected\n\n        // Do this instead\n        final double EPSILON = 0.00001;\n        if (Math.abs(a - b) &lt; EPSILON) {\n            System.out.println(\"Numbers are effectively equal\");\n        }\n    }\n}\n</code></pre> Understanding these fundamental building blocks of Java programming helps write more reliable and maintainable code. Remember that expressions evaluate to values, statements complete actions, and blocks organize code and control scope. These concepts work together to create clear, effective Java programs.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-control-flow-making-programs-dynamic","title":"Understanding Java Control Flow: Making Programs Dynamic","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-control-flow","title":"Introduction to Control Flow","text":"<p>Think of a program's control flow like a journey through your code. Just as we make decisions in life that affect our path forward, control flow statements determine which parts of our code execute and under what conditions. Understanding these statements is crucial because they give our programs the power to make decisions, repeat tasks, and respond dynamically to different situations.</p>"},{"location":"1.Fundamentals/e_java/#making-decisions-with-if-statements","title":"Making Decisions with If Statements","text":"<p>Let's start with the foundation of decision-making in Java: the if statement. Think of it as a gateway that only opens when certain conditions are met.</p>"},{"location":"1.Fundamentals/e_java/#the-basic-if-then-structure","title":"The Basic If-Then Structure","text":"<pre><code>public class BasicDecisions {\n    public void demonstrateIfThen(int temperature) {\n        // The if statement is like asking a yes/no question\n        if (temperature &gt; 30) {\n            System.out.println(\"It's hot today!\");\n            // This code only runs when the condition is true\n        }\n\n        // Program continues here regardless of the condition\n        System.out.println(\"Program continues...\");\n    }\n\n    // Let's see a real-world example with multiple conditions\n    public void checkVehicleStatus(int speed, int fuelLevel) {\n        // Notice how we check crucial conditions first\n        if (fuelLevel &lt; 10) {\n            System.out.println(\"Warning: Low fuel!\");\n            // Even after this warning, we continue checking other conditions\n        }\n\n        if (speed &gt; 120) {\n            System.out.println(\"Warning: Speed limit exceeded!\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#adding-alternatives-with-if-then-else","title":"Adding Alternatives with If-Then-Else","text":"<p>Sometimes we need to choose between two different paths. This is where if-then-else comes in: <pre><code>public class ConditionalChoices {\n    public String determineShippingMethod(double packageWeight) {\n        // A clear example of binary decision making\n        if (packageWeight &lt; 2.0) {\n            return \"Standard Post\";\n        } else {\n            return \"Express Shipping Required\";\n        }\n    }\n\n    // Real-world example: Grading system\n    public char calculateGrade(double score) {\n        // Notice how we check conditions from highest to lowest\n        if (score &gt;= 90) {\n            return 'A';\n        } else if (score &gt;= 80) {\n            return 'B';\n        } else if (score &gt;= 70) {\n            return 'C';\n        } else if (score &gt;= 60) {\n            return 'D';\n        } else {\n            return 'F';\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#repeating-actions-with-loops","title":"Repeating Actions with Loops","text":"<p>Loops allow us to perform tasks repeatedly. Understanding different loop types helps us choose the right tool for each situation.</p>"},{"location":"1.Fundamentals/e_java/#the-while-loop-continuing-while-a-condition-is-true","title":"The While Loop: Continuing While a Condition is True","text":"<pre><code>public class WhileLoopExamples {\n    public void downloadFile(int fileSize) {\n        int downloadedBytes = 0;\n\n        // While loops are perfect when we don't know exactly how many iterations we need\n        while (downloadedBytes &lt; fileSize) {\n            // Simulate downloading a chunk of data\n            downloadedBytes += 1024;\n            System.out.println(\"Downloaded \" + downloadedBytes + \" of \" + fileSize + \" bytes\");\n\n            // Important: Always ensure progress towards the condition becoming false\n            if (downloadedBytes &gt;= fileSize) {\n                break;  // Exit when download is complete\n            }\n        }\n    }\n\n    // Real-world example: Processing user input\n    public void processUserInput(Scanner scanner) {\n        String input = \"\";\n        while (!input.equals(\"quit\")) {\n            System.out.println(\"Enter command (or 'quit' to exit):\");\n            input = scanner.nextLine().toLowerCase();\n            processCommand(input);\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#the-do-while-loop-ensuring-at-least-one-execution","title":"The Do-While Loop: Ensuring at Least One Execution","text":"<pre><code>public class DoWhileExamples {\n    public int getUserChoice(Scanner scanner) {\n        int choice;\n\n        do {\n            System.out.println(\"\\nPlease select an option:\");\n            System.out.println(\"1. Start game\");\n            System.out.println(\"2. Load saved game\");\n            System.out.println(\"3. Exit\");\n\n            choice = scanner.nextInt();\n\n            if (choice &lt; 1 || choice &gt; 3) {\n                System.out.println(\"Invalid choice. Please try again.\");\n            }\n        } while (choice &lt; 1 || choice &gt; 3);\n\n        return choice;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#the-for-loop-when-you-know-the-number-of-iterations","title":"The For Loop: When You Know the Number of Iterations","text":"<pre><code>public class ForLoopExamples {\n    public void demonstrateForLoop() {\n        // Traditional for loop with counter\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(\"Iteration \" + i);\n        }\n\n        // Enhanced for loop (for-each) for collections\n        String[] colors = {\"Red\", \"Green\", \"Blue\"};\n        for (String color : colors) {\n            System.out.println(\"Processing color: \" + color);\n        }\n    }\n\n    // Real-world example: Processing a batch of records\n    public void processBatchRecords(List&lt;Record&gt; records, int batchSize) {\n        for (int i = 0; i &lt; records.size(); i += batchSize) {\n            int endIndex = Math.min(i + batchSize, records.size());\n            List&lt;Record&gt; batch = records.subList(i, endIndex);\n            processBatch(batch);\n\n            // Progress reporting\n            System.out.printf(\"Processed %d of %d records%n\", \n                            endIndex, records.size());\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#control-flow-modifiers-break-continue-and-return","title":"Control Flow Modifiers: Break, Continue, and Return","text":"<p>These statements give us fine-grained control over our program's flow: <pre><code>public class ControlFlowModifiers {\n    public void searchArray(int[] numbers, int target) {\n        // Using break to exit early\n        for (int i = 0; i &lt; numbers.length; i++) {\n            if (numbers[i] == target) {\n                System.out.println(\"Found at position: \" + i);\n                break;  // No need to continue searching\n            }\n        }\n    }\n\n    public void processRecords(List&lt;Record&gt; records) {\n        // Using continue to skip invalid records\n        for (Record record : records) {\n            if (!record.isValid()) {\n                System.out.println(\"Skipping invalid record: \" + record.getId());\n                continue;  // Skip to the next record\n            }\n\n            // Process valid record\n            processValidRecord(record);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_3","title":"Best Practices and Common Pitfalls","text":"<p>Understanding control flow is essential, but using it well requires careful consideration: <pre><code>public class ControlFlowBestPractices {\n    // GOOD: Clear, simple conditions\n    public void goodExample(int value) {\n        if (value &gt; 0) {\n            processPositiveValue(value);\n        } else if (value &lt; 0) {\n            processNegativeValue(value);\n        } else {\n            processZero();\n        }\n    }\n\n    // BAD: Nested conditions create complexity\n    public void badExample(int value) {\n        if (value &gt;= 0) {\n            if (value &gt; 0) {\n                if (value &gt; 10) {\n                    processLargeValue(value);\n                } else {\n                    processSmallValue(value);\n                }\n            } else {\n                processZero();\n            }\n        } else {\n            processNegativeValue(value);\n        }\n    }\n\n    // BETTER: Flattened logic with early returns\n    public void betterExample(int value) {\n        if (value &lt; 0) {\n            processNegativeValue(value);\n            return;\n        }\n\n        if (value == 0) {\n            processZero();\n            return;\n        }\n\n        if (value &gt; 10) {\n            processLargeValue(value);\n        } else {\n            processSmallValue(value);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-patterns-and-techniques","title":"Advanced Patterns and Techniques","text":"<p>As you become more comfortable with control flow, you can use more sophisticated patterns: <pre><code>public class AdvancedControlFlow {\n    // Pattern: State Machine\n    public void processWorkflow(Task task) {\n        while (task.getStatus() != Status.COMPLETED) {\n            switch (task.getStatus()) {\n                case NEW:\n                    initializeTask(task);\n                    break;\n                case IN_PROGRESS:\n                    continueProcessing(task);\n                    break;\n                case WAITING:\n                    checkDependencies(task);\n                    break;\n                default:\n                    handleUnknownStatus(task);\n            }\n        }\n    }\n\n    // Pattern: Guard Clauses\n    public void processRequest(Request request) {\n        // Validate preconditions first\n        if (request == null) {\n            throw new IllegalArgumentException(\"Request cannot be null\");\n        }\n\n        if (!request.isAuthenticated()) {\n            throw new SecurityException(\"Request must be authenticated\");\n        }\n\n        // Main processing follows...\n        processValidRequest(request);\n    }\n}\n</code></pre> By understanding these control flow concepts and patterns, you can write more elegant and maintainable Java code. Remember that the goal is not just to make your code work, but to make it clear, efficient, and easy to maintain. Choose the appropriate control flow structures based on your specific needs, and always consider readability and maintainability in your design decisions.</p>"},{"location":"1.Fundamentals/e_java/#java-switch-statements-making-clean-readable-code-decisions","title":"Java Switch Statements: Making Clean, Readable Code Decisions","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-switch-statements","title":"Introduction to Switch Statements","text":"<p>Imagine you're building a vending machine controller. The machine needs to respond differently based on which button the user presses. While you could write this using a series of if-else statements, a switch statement often provides a clearer, more maintainable solution. Let's explore how switch statements work and when to use them.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-basics","title":"Understanding the Basics","text":"<p>A switch statement is like a sophisticated routing system that directs your program's flow based on a single value. Think of it as a switchboard operator connecting calls to the right department. <pre><code>public class VendingMachineController {\n    public void processSelection(int buttonNumber) {\n        String item;\n\n        switch (buttonNumber) {\n            case 1:\n                item = \"Cola\";\n                break;\n            case 2:\n                item = \"Water\";\n                break;\n            case 3:\n                item = \"Coffee\";\n                break;\n            default:\n                item = \"Unknown Selection\";\n                break;\n        }\n\n        System.out.println(\"Selected item: \" + item);\n    }\n}\n</code></pre> Let's break down what's happening here:</p> <ol> <li>The  <code>buttonNumber</code>  is our selector variable - it determines which case executes</li> <li>Each  <code>case</code>  label represents a possible value of our selector</li> <li>The  <code>break</code>  statement prevents fall-through to the next case</li> <li>The  <code>default</code>  case handles any value not explicitly covered</li> </ol>"},{"location":"1.Fundamentals/e_java/#supported-types-for-switch-statements","title":"Supported Types for Switch Statements","text":"<p>Java allows specific types for the selector variable. Understanding these limitations helps prevent common errors: <pre><code>public class SwitchTypeExamples {\n    public void demonstrateSupportedTypes() {\n        // Primitive types\n        byte byteValue = 1;\n        switch (byteValue) { ... }\n\n        short shortValue = 100;\n        switch (shortValue) { ... }\n\n        char charValue = 'A';\n        switch (charValue) { ... }\n\n        int intValue = 1000;\n        switch (intValue) { ... }\n\n        // Wrapper classes\n        Integer wrappedInt = 42;\n        switch (wrappedInt) { ... }\n\n        // Strings (Java 7+)\n        String command = \"START\";\n        switch (command) { ... }\n\n        // Enums\n        DayOfWeek day = DayOfWeek.MONDAY;\n        switch (day) { ... }\n\n        // NOT supported:\n        // long, float, double, boolean\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-fall-through-behavior","title":"Understanding Fall-Through Behavior","text":"<p>Fall-through is a powerful feature that can either be very useful or create subtle bugs. Let's explore both scenarios: <pre><code>public class FallThroughExamples {\n    // Intentional fall-through for grouping similar cases\n    public String getSeasonForMonth(int month) {\n        String season;\n        switch (month) {\n            case 12:\n            case 1:\n            case 2:\n                season = \"Winter\";\n                break;\n            case 3:\n            case 4:\n            case 5:\n                season = \"Spring\";\n                break;\n            case 6:\n            case 7:\n            case 8:\n                season = \"Summer\";\n                break;\n            case 9:\n            case 10:\n            case 11:\n                season = \"Fall\";\n                break;\n            default:\n                season = \"Invalid month\";\n                break;\n        }\n        return season;\n    }\n\n    // Dangerous fall-through (potential bug)\n    public void demonstrateUnintentionalFallThrough(int status) {\n        switch (status) {\n            case 1:\n                System.out.println(\"Starting process\");\n                // Missing break! Falls through to next case\n            case 2:\n                System.out.println(\"Processing\");\n                break;\n            case 3:\n                System.out.println(\"Completed\");\n                break;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#working-with-string-cases","title":"Working with String Cases","text":"<p>String support in switch statements (added in Java 7) requires special consideration: <pre><code>public class StringSwitchExamples {\n    public int getDayNumber(String dayName) {\n        // Best practice: Handle null and normalize case\n        if (dayName == null) {\n            return -1;\n        }\n\n        switch (dayName.toLowerCase()) {\n            case \"monday\":\n                return 1;\n            case \"tuesday\":\n                return 2;\n            case \"wednesday\":\n                return 3;\n            case \"thursday\":\n                return 4;\n            case \"friday\":\n                return 5;\n            case \"saturday\":\n                return 6;\n            case \"sunday\":\n                return 0;\n            default:\n                return -1;\n        }\n    }\n\n    // Real-world example: Command processor\n    public void processCommand(String command) {\n        switch (command.toUpperCase()) {\n            case \"START\":\n                initializeSystem();\n                break;\n            case \"STOP\":\n                shutdownSystem();\n                break;\n            case \"RESTART\":\n                restartSystem();\n                break;\n            case \"STATUS\":\n                displayStatus();\n                break;\n            default:\n                System.out.println(\"Unknown command: \" + command);\n                displayHelp();\n                break;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#switch-statements-vs-if-else-making-the-right-choice","title":"Switch Statements vs If-Else: Making the Right Choice","text":"<p>Understanding when to use switch versus if-else improves code readability and maintainability: <pre><code>public class DecisionStructureComparison {\n    // Good case for switch: Simple equality checks against a single variable\n    public String getColorName(int colorCode) {\n        switch (colorCode) {\n            case 1: return \"Red\";\n            case 2: return \"Blue\";\n            case 3: return \"Green\";\n            default: return \"Unknown\";\n        }\n    }\n\n    // Better with if-else: Complex conditions\n    public String getWaterState(double temperature) {\n        if (temperature &lt; 0) {\n            return \"Ice\";\n        } else if (temperature &lt; 100) {\n            return \"Liquid\";\n        } else {\n            return \"Steam\";\n        }\n    }\n\n    // Better with if-else: Boolean conditions\n    public String getAccessLevel(boolean isAdmin, boolean isLoggedIn) {\n        if (isAdmin &amp;&amp; isLoggedIn) {\n            return \"Full Access\";\n        } else if (isLoggedIn) {\n            return \"User Access\";\n        } else {\n            return \"No Access\";\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_4","title":"Best Practices and Common Pitfalls","text":"<p>Understanding these guidelines helps write more reliable switch statements: <pre><code>public class SwitchBestPractices {\n    public void processStatus(Status status) {\n        // Best Practice 1: Always handle null before switch\n        if (status == null) {\n            throw new IllegalArgumentException(\"Status cannot be null\");\n        }\n\n        // Best Practice 2: Use enum for type safety\n        switch (status) {\n            case PENDING:\n                processPending();\n                break;\n            case ACTIVE:\n                processActive();\n                break;\n            case SUSPENDED:\n                processSuspended();\n                break;\n            case TERMINATED:\n                processTerminated();\n                break;\n            // Best Practice 3: Always include default\n            default:\n                handleUnknownStatus();\n                break;\n        }\n    }\n\n    // Best Practice 4: Consider extracting complex case logic to methods\n    public void processUserAction(UserAction action) {\n        switch (action) {\n            case LOGIN:\n                handleUserLogin();\n                break;\n            case LOGOUT:\n                handleUserLogout();\n                break;\n            case UPDATE_PROFILE:\n                handleProfileUpdate();\n                break;\n            default:\n                logUnknownAction(action);\n                break;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-patterns-with-switch-statements","title":"Advanced Patterns with Switch Statements","text":"<p>Here are some sophisticated ways to use switch statements effectively: <pre><code>public class AdvancedSwitchPatterns {\n    // Pattern: State Machine Transitions\n    public State getNextState(State currentState, Event event) {\n        switch (currentState) {\n            case IDLE:\n                switch (event) {\n                    case START: return State.RUNNING;\n                    case ERROR: return State.ERROR;\n                    default: return State.IDLE;\n                }\n            case RUNNING:\n                switch (event) {\n                    case PAUSE: return State.PAUSED;\n                    case STOP: return State.IDLE;\n                    case ERROR: return State.ERROR;\n                    default: return State.RUNNING;\n                }\n            // ... other states\n            default:\n                return currentState;\n        }\n    }\n\n    // Pattern: Command Pattern Implementation\n    public void executeCommand(String commandName, Context context) {\n        switch (commandName.toUpperCase()) {\n            case \"SAVE\":\n                if (!context.isValid()) {\n                    throw new IllegalStateException(\"Invalid context for save\");\n                }\n                performSave(context);\n                break;\n            case \"LOAD\":\n                if (!context.hasBackup()) {\n                    throw new IllegalStateException(\"No backup available\");\n                }\n                performLoad(context);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unknown command: \" + commandName);\n        }\n    }\n}\n</code></pre> Understanding these concepts and patterns helps you write more effective, maintainable Java code. Remember that switch statements are powerful tools when used appropriately, but they're not always the best choice. Consider your specific use case and choose the control structure that makes your code most clear and maintainable.</p>"},{"location":"1.Fundamentals/e_java/#java-switch-expressions-modern-safe-and-expressive-branching","title":"Java Switch Expressions: Modern, Safe, and Expressive Branching","text":""},{"location":"1.Fundamentals/e_java/#introduction_4","title":"Introduction","text":"<p>Think of traditional switch statements as an old rotary phone\u2014they get the job done but can be clunky and error-prone. Switch expressions, introduced in Java 14, are like a modern smartphone\u2014more elegant, safer, and more powerful. Let's explore how they transform the way we write branching code in Java.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-evolution","title":"Understanding the Evolution","text":"<p>Let's start by seeing how switch expressions solve common problems with traditional switch statements: <pre><code>public class SwitchEvolution {\n    // Traditional switch statement - notice the potential issues\n    public String getOldQuarterName(int quarter) {\n        String name;\n        switch (quarter) {\n            case 1:\n                name = \"Q1\";\n                break;  // Forgetting this break would cause problems\n            case 2:\n                name = \"Q2\";\n                break;\n            case 3:\n                name = \"Q3\";\n                break;\n            case 4:\n                name = \"Q4\";\n                break;\n            default:\n                name = \"Unknown\";\n                break;\n        }\n        return name;\n    }\n\n    // Modern switch expression - cleaner and safer\n    public String getQuarterName(int quarter) {\n        return switch (quarter) {\n            case 1 -&gt; \"Q1\";\n            case 2 -&gt; \"Q2\";\n            case 3 -&gt; \"Q3\";\n            case 4 -&gt; \"Q4\";\n            default -&gt; \"Unknown\";\n        };\n    }\n}\n</code></pre> Notice how the switch expression eliminates the need for:</p> <ol> <li>Break statements to prevent fall-through</li> <li>A separate variable declaration</li> <li>Multiple lines of boilerplate code</li> </ol>"},{"location":"1.Fundamentals/e_java/#key-features-and-benefits","title":"Key Features and Benefits","text":"<p>Let's explore the major improvements switch expressions bring: <pre><code>public class SwitchFeatures {\n    // 1. Multiple case labels in a single branch\n    public String getDayType(DayOfWeek day) {\n        return switch (day) {\n            case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; \"Weekday\";\n            case SATURDAY, SUNDAY -&gt; \"Weekend\";\n        };  // No default needed - enum covers all cases\n    }\n\n    // 2. Complex expressions in case blocks using yield\n    public String getSeasonDescription(Season season) {\n        return switch (season) {\n            case SPRING -&gt; {\n                String message = \"Flowers blooming\";\n                yield message + \" in spring\";  // Complex logic needs yield\n            }\n            case SUMMER -&gt; {\n                double temp = calculateAverageTemp();\n                yield String.format(\"Summer heat: %.1f\u00b0C\", temp);\n            }\n            case FALL -&gt; \"Leaves falling\";  // Simple returns don't need yield\n            case WINTER -&gt; \"Snow falling\";\n        };\n    }\n\n    // 3. Expression-based assignment\n    public void processDayType(DayOfWeek day) {\n        int workloadHours = switch (day) {\n            case MONDAY -&gt; 8;\n            case FRIDAY -&gt; 6;\n            case SATURDAY, SUNDAY -&gt; 0;\n            default -&gt; 7;\n        };\n\n        System.out.println(\"Expected hours: \" + workloadHours);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":"<p>Let's explore some sophisticated ways to use switch expressions: <pre><code>public class AdvancedSwitchPatterns {\n    // Pattern: Combining with methods\n    public record UserRole(String name, int level) {}\n\n    public String getPermissions(UserRole role) {\n        return switch (role.name().toLowerCase()) {\n            case \"admin\" -&gt; {\n                if (role.level() &lt; 5) {\n                    yield \"Limited Admin Access\";\n                }\n                yield \"Full Admin Access\";\n            }\n            case \"moderator\" -&gt; switch (role.level()) {\n                case 1 -&gt; \"Basic Moderation\";\n                case 2 -&gt; \"Advanced Moderation\";\n                default -&gt; \"Unknown Moderation Level\";\n            };\n            case \"user\" -&gt; \"Standard Access\";\n            default -&gt; throw new IllegalArgumentException(\"Unknown role: \" + role.name());\n        };\n    }\n\n    // Pattern: State Machine Transitions\n    public enum State { IDLE, RUNNING, PAUSED, ERROR }\n    public enum Event { START, STOP, PAUSE, RESUME, FAIL }\n\n    public State getNextState(State currentState, Event event) {\n        return switch (currentState) {\n            case IDLE -&gt; switch (event) {\n                case START -&gt; State.RUNNING;\n                case FAIL -&gt; State.ERROR;\n                default -&gt; State.IDLE;\n            };\n            case RUNNING -&gt; switch (event) {\n                case STOP -&gt; State.IDLE;\n                case PAUSE -&gt; State.PAUSED;\n                case FAIL -&gt; State.ERROR;\n                default -&gt; State.RUNNING;\n            };\n            case PAUSED -&gt; switch (event) {\n                case RESUME -&gt; State.RUNNING;\n                case STOP -&gt; State.IDLE;\n                default -&gt; State.PAUSED;\n            };\n            case ERROR -&gt; switch (event) {\n                case STOP -&gt; State.IDLE;\n                default -&gt; State.ERROR;\n            };\n        };\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-guidelines","title":"Best Practices and Guidelines","text":"<p>Let's understand how to use switch expressions effectively: <pre><code>public class SwitchBestPractices {\n    // 1. Use arrows (-&gt;) for simple cases\n    public String getSimpleLabel(Status status) {\n        return switch (status) {\n            case ACTIVE -&gt; \"Active\";\n            case INACTIVE -&gt; \"Inactive\";\n            case PENDING -&gt; \"Pending\";\n        };  // No default needed for enum\n    }\n\n    // 2. Use blocks with yield for complex logic\n    public String getComplexLabel(Status status) {\n        return switch (status) {\n            case ACTIVE -&gt; {\n                logStatus(\"Active status processed\");\n                yield \"Currently Active\";\n            }\n            case INACTIVE -&gt; {\n                logStatus(\"Inactive status processed\");\n                yield \"Currently Inactive\";\n            }\n            case PENDING -&gt; {\n                logStatus(\"Pending status processed\");\n                yield \"Awaiting Activation\";\n            }\n        };\n    }\n\n    // 3. Handle null values safely\n    public String processSafely(Status status) {\n        // Always check for null before the switch\n        if (status == null) {\n            return \"No status available\";\n        }\n\n        return switch (status) {\n            case ACTIVE -&gt; \"Active\";\n            case INACTIVE -&gt; \"Inactive\";\n            case PENDING -&gt; \"Pending\";\n        };\n    }\n\n    // 4. Use switch expressions for value assignment\n    public void processWithValue(Status status) {\n        int priority = switch (status) {\n            case ACTIVE -&gt; 1;\n            case PENDING -&gt; 2;\n            case INACTIVE -&gt; 3;\n        };\n\n        scheduleWithPriority(priority);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-and-how-to-avoid-them_1","title":"Common Pitfalls and How to Avoid Them","text":"<p>Understanding potential issues helps write better code: <pre><code>public class SwitchPitfalls {\n    // Pitfall 1: Mixing arrow syntax with colon syntax\n    public void demonstrateMixedSyntax(int value) {\n        // DON'T DO THIS - mixing styles is confusing\n        int result = switch (value) {\n            case 1 -&gt; 10;\n            case 2: yield 20;  // Don't mix -&gt; and :\n            default -&gt; 0;\n        };\n    }\n\n    // Pitfall 2: Forgetting yield in blocks\n    public String demonstrateYieldUsage(Status status) {\n        return switch (status) {\n            case ACTIVE -&gt; {\n                logStatus(status);\n                yield \"Active\";  // Required in blocks\n            }\n            case INACTIVE -&gt; \"Inactive\";  // No yield needed for single expression\n            case PENDING -&gt; {\n                // This would cause a compilation error without yield\n                logStatus(status);\n                yield \"Pending\";\n            }\n        };\n    }\n}\n</code></pre> Switch expressions represent a significant improvement in Java's branching capabilities. They make code more concise, safer, and more expressive while eliminating common sources of errors found in traditional switch statements. By understanding their features and following best practices, you can write cleaner, more maintainable code.</p> <p>Remember that switch expressions are not just a syntactic improvement\u2014they represent a fundamental shift in how we think about branching in Java, moving from imperative statements to expressive, value-producing expressions.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-methods-a-complete-developers-guide","title":"Understanding Java Methods: A Complete Developer's Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_5","title":"Introduction","text":"<p>Methods are the building blocks of any Java program - they encapsulate logic, enable code reuse, and help organize our code into manageable, functional units. Think of methods as specialized workers in a factory, each with a specific job to perform.</p>"},{"location":"1.Fundamentals/e_java/#method-fundamentals","title":"Method Fundamentals","text":""},{"location":"1.Fundamentals/e_java/#basic-anatomy-of-a-method","title":"Basic Anatomy of a Method","text":"<p><pre><code>public static int calculateSum(int a, int b) {\n    // Method body\n    int result = a + b;\n    return result;\n}\n</code></pre> Let's break down each component:</p> <ol> <li>Access Modifier (<code>public</code>): Controls visibility</li> <li>Optional Modifiers (<code>static</code>): Defines behavior characteristics</li> <li>Return Type (<code>int</code>): Specifies output type</li> <li>Method Name (<code>calculateSum</code>): Identifies the method</li> <li>Parameters (<code>int a, int b</code>): Input values</li> <li>Method Body: Contains the actual logic</li> </ol>"},{"location":"1.Fundamentals/e_java/#method-declaration-best-practices","title":"Method Declaration Best Practices","text":"<pre><code>public class MethodNamingExample {\n    // Good: verb + noun, clear purpose\n    public void processPayment(Payment payment) { }\n\n    // Good: boolean methods often start with is/has/can\n    public boolean isValidTransaction(Transaction t) { }\n\n    // Good: get + noun for accessors\n    public String getCustomerName() { }\n\n    // Bad: unclear purpose, poor naming\n    public void process(Object o) { }  // Too vague\n\n    // Bad: noun only, doesn't indicate action\n    public void transaction() { }      // What about the transaction?\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#types-of-methods","title":"Types of Methods","text":""},{"location":"1.Fundamentals/e_java/#instance-methods","title":"Instance Methods","text":"<p>Instance methods operate on object-level data and require an instance of the class: <pre><code>public class BankAccount {\n    private double balance;\n\n    // Instance method - operates on object state\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n            notifyDeposit(amount);  // Can call other instance methods\n        }\n    }\n\n    private void notifyDeposit(double amount) {\n        System.out.println(\"Deposited: $\" + amount);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#static-methods","title":"Static Methods","text":"<p>Static methods belong to the class itself and don't require an instance: <pre><code>public class MathUtils {\n    // Static method - utility function\n    public static double calculateArea(double radius) {\n        return Math.PI * radius * radius;\n    }\n\n    // Static factory method\n    public static MathUtils createWithDefaults() {\n        return new MathUtils();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#accessor-and-mutator-methods","title":"Accessor and Mutator Methods","text":"<pre><code>public class Employee {\n    private String name;\n    private double salary;\n\n    // Accessor (getter)\n    public String getName() {\n        return name;\n    }\n\n    // Mutator (setter) with validation\n    public void setSalary(double newSalary) {\n        if (newSalary &gt;= 0) {\n            this.salary = newSalary;\n        } else {\n            throw new IllegalArgumentException(\"Salary cannot be negative\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#method-parameters-and-return-values","title":"Method Parameters and Return Values","text":""},{"location":"1.Fundamentals/e_java/#parameter-passing","title":"Parameter Passing","text":"<p>Java uses pass-by-value for all parameter passing: <pre><code>public class ParameterExample {\n    public static void main(String[] args) {\n        int x = 10;\n        String text = \"Hello\";\n        StringBuilder sb = new StringBuilder(\"Hello\");\n\n        modifyValues(x, text, sb);\n\n        System.out.println(x);      // Still 10\n        System.out.println(text);   // Still \"Hello\"\n        System.out.println(sb);     // \"Hello World\" - object was modified\n    }\n\n    public static void modifyValues(int a, String s, StringBuilder sb) {\n        a = 20;              // Modifies local copy only\n        s = \"World\";         // Modifies local reference only\n        sb.append(\" World\"); // Modifies the actual object\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#method-overloading","title":"Method Overloading","text":"<p>Methods can be overloaded by changing parameter types or count: <pre><code>public class Calculator {\n    // Different parameter types\n    public double add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    // Different parameter count\n    public double add(double a, double b, double c) {\n        return a + b + c;\n    }\n\n    // Varargs for flexible parameter count\n    public double add(double... numbers) {\n        double sum = 0;\n        for (double num : numbers) {\n            sum += num;\n        }\n        return sum;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-method-concepts","title":"Advanced Method Concepts","text":""},{"location":"1.Fundamentals/e_java/#method-design-patterns","title":"Method Design Patterns","text":"<pre><code>public class MethodPatterns {\n    // Builder pattern method chaining\n    public MethodPatterns setName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    // Template method pattern\n    public final void processOrder() {\n        validateOrder();\n        calculateTotal();\n        applyDiscount();\n        finalizeOrder();\n    }\n\n    // Factory method pattern\n    public static Payment createPayment(String type) {\n        return switch (type) {\n            case \"CREDIT\" -&gt; new CreditPayment();\n            case \"DEBIT\" -&gt; new DebitPayment();\n            default -&gt; throw new IllegalArgumentException(\"Unknown payment type\");\n        };\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#exception-handling-in-methods","title":"Exception Handling in Methods","text":"<pre><code>public class ExceptionHandlingExample {\n    // Checked exception - must be declared\n    public void readFile(String path) throws IOException {\n        // File reading logic\n    }\n\n    // Runtime exception - optional declaration\n    public void processData(String data) {\n        if (data == null) {\n            throw new IllegalArgumentException(\"Data cannot be null\");\n        }\n        // Processing logic\n    }\n\n    // Exception handling best practices\n    public void robustMethod() {\n        try {\n            // Risky operations\n        } catch (Exception e) {\n            // Log the error\n            logger.error(\"Operation failed\", e);\n            // Throw a more specific exception\n            throw new ServiceException(\"Could not complete operation\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices-and-guidelines_1","title":"Best Practices and Guidelines","text":"<ol> <li>Method Naming:<ul> <li>Use verb-noun combinations</li> <li>Be specific and descriptive</li> <li>Follow naming conventions</li> </ul> </li> <li>Method Length:<ul> <li>Keep methods focused and concise</li> <li>Consider splitting long methods</li> <li>Follow the Single Responsibility Principle</li> </ul> </li> <li>Parameter Handling:<ul> <li>Validate parameters early</li> <li>Use defensive copying when needed</li> <li>Consider using builder pattern for many parameters</li> </ul> </li> <li>Documentation:<ul> <li>Write clear Javadoc comments</li> <li>Document exceptions and parameters</li> <li>Include usage examples for complex methods <pre><code>public class BestPracticesExample {\n    /**\n     * Processes a customer order and returns the order confirmation.\n     *\n     * @param order The order to process\n     * @param user The user placing the order\n     * @return OrderConfirmation with the processed order details\n     * @throws InvalidOrderException if the order is invalid\n     * @throws UserNotFoundException if the user doesn't exist\n     */\n    public OrderConfirmation processOrder(Order order, User user) {\n        validateOrder(order);\n        validateUser(user);\n\n        // Process the order\n        OrderConfirmation confirmation = new OrderConfirmation();\n        // ... processing logic\n\n        return confirmation;\n    }\n}\n</code></pre> By following these guidelines and understanding method concepts thoroughly, you can write more maintainable, readable, and efficient Java code. Remember that methods are not just about functionality - they're about creating clear, reusable, and well-organized code that other developers can understand and maintain.</li> </ul> </li> </ol>"},{"location":"1.Fundamentals/e_java/#java-lambda-expressions-a-comprehensive-guide","title":"Java Lambda Expressions: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_6","title":"Introduction","text":"<p>Lambda expressions, introduced in Java 8, represent a significant shift in Java programming, enabling functional programming capabilities. Think of them as compact methods that can be passed around as data - similar to passing a behavior rather than just values.</p>"},{"location":"1.Fundamentals/e_java/#basic-syntax-and-structure","title":"Basic Syntax and Structure","text":"<p>Lambda expressions have three main parts:</p> <ol> <li>Parameter list</li> <li>Arrow operator (<code>-&gt;</code>)</li> <li>Body <pre><code>public class LambdaBasics {\n    public static void main(String[] args) {\n        // Basic lambda with one parameter\n        Function&lt;String, Integer&gt; strLength = s -&gt; s.length();\n\n        // Lambda with multiple parameters\n        BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b;\n\n        // Lambda with explicit type declaration\n        BiFunction&lt;String, String, String&gt; concat = \n            (String a, String b) -&gt; a + b;\n\n        // Lambda with a block of code\n        Consumer&lt;String&gt; printer = message -&gt; {\n            System.out.println(\"Printing: \");\n            System.out.println(message);\n        };\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#common-use-cases","title":"Common Use Cases","text":""},{"location":"1.Fundamentals/e_java/#working-with-collections","title":"Working with Collections","text":"<pre><code>public class CollectionExamples {\n    public void demonstrateCollectionUsage() {\n        List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n        // Iterating over a collection\n        names.forEach(name -&gt; System.out.println(name));\n\n        // Filtering elements\n        List&lt;String&gt; longNames = names.stream()\n            .filter(name -&gt; name.length() &gt; 4)\n            .collect(Collectors.toList());\n\n        // Transforming elements\n        List&lt;Integer&gt; nameLengths = names.stream()\n            .map(name -&gt; name.length())\n            .collect(Collectors.toList());\n    }\n\n    public void demonstrateSorting() {\n        List&lt;Person&gt; people = getPeople();\n\n        // Sorting with a lambda\n        people.sort((p1, p2) -&gt; p1.getAge() - p2.getAge());\n\n        // Multiple criteria sorting\n        people.sort((p1, p2) -&gt; {\n            int compareLastNames = p1.getLastName().compareTo(p2.getLastName());\n            if (compareLastNames != 0) {\n                return compareLastNames;\n            }\n            return p1.getFirstName().compareTo(p2.getFirstName());\n        });\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#event-handling","title":"Event Handling","text":"<pre><code>public class EventHandlingExample {\n    public void setupUI() {\n        Button button = new Button(\"Click Me\");\n\n        // Simple event handler\n        button.setOnAction(event -&gt; System.out.println(\"Button clicked!\"));\n\n        // Event handler with multiple statements\n        button.setOnAction(event -&gt; {\n            System.out.println(\"Processing click...\");\n            processClick();\n            updateUI();\n        });\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#working-with-functional-interfaces","title":"Working with Functional Interfaces","text":"<pre><code>public class FunctionalInterfaceExamples {\n    // Custom functional interface\n    @FunctionalInterface\n    interface Validator&lt;T&gt; {\n        boolean validate(T t);\n    }\n\n    public void demonstrateFunctionalInterfaces() {\n        // Using built-in functional interfaces\n        Predicate&lt;String&gt; isLongString = s -&gt; s.length() &gt; 10;\n        Consumer&lt;String&gt; print = s -&gt; System.out.println(s);\n        Function&lt;Integer, String&gt; intToString = i -&gt; String.valueOf(i);\n        Supplier&lt;LocalDate&gt; today = () -&gt; LocalDate.now();\n\n        // Using custom functional interface\n        Validator&lt;String&gt; emailValidator = email -&gt; \n            email.contains(\"@\") &amp;&amp; email.contains(\".\");\n\n        // Combining predicates\n        Predicate&lt;String&gt; isNotEmpty = s -&gt; !s.isEmpty();\n        Predicate&lt;String&gt; isValidEmail = isNotEmpty.and(emailValidator::validate);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#advanced-lambda-concepts","title":"Advanced Lambda Concepts","text":""},{"location":"1.Fundamentals/e_java/#variable-capture","title":"Variable Capture","text":"<pre><code>public class VariableCaptureExample {\n    private int instanceVar = 0;\n\n    public void demonstrateCapture() {\n        final int finalLocal = 1;\n        int effectivelyFinal = 2;\n        int mutable = 3;\n\n        // Valid: capturing instance variable\n        Runnable r1 = () -&gt; System.out.println(instanceVar);\n\n        // Valid: capturing final variable\n        Runnable r2 = () -&gt; System.out.println(finalLocal);\n\n        // Valid: capturing effectively final variable\n        Runnable r3 = () -&gt; System.out.println(effectivelyFinal);\n\n        // Invalid: capturing mutable variable\n        // Runnable r4 = () -&gt; System.out.println(mutable);\n        mutable = 4; // Makes the variable not effectively final\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#method-references","title":"Method References","text":"<pre><code>public class MethodReferenceExample {\n    public void demonstrateMethodReferences() {\n        List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n        // Instance method reference\n        names.forEach(System.out::println);\n\n        // Static method reference\n        names.stream()\n            .map(String::toUpperCase)\n            .collect(Collectors.toList());\n\n        // Constructor reference\n        Supplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new;\n\n        // Instance method reference of arbitrary object\n        names.sort(String::compareToIgnoreCase);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices-and-guidelines_2","title":"Best Practices and Guidelines","text":"<p><pre><code>public class LambdaBestPractices {\n    public void demonstrateBestPractices() {\n        List&lt;Person&gt; people = getPeople();\n\n        // GOOD: Keep lambdas short and readable\n        people.removeIf(person -&gt; person.getAge() &lt; 18);\n\n        // BAD: Complex logic in lambda\n        people.removeIf(person -&gt; {\n            if (person.getAge() &lt; 18) {\n                if (person.hasParentalConsent()) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        });\n\n        // BETTER: Extract complex logic to method\n        people.removeIf(this::isNotEligible);\n    }\n\n    private boolean isNotEligible(Person person) {\n        if (person.getAge() &lt; 18) {\n            return !person.hasParentalConsent();\n        }\n        return false;\n    }\n\n    // GOOD: Use method references when possible\n    public void processStrings(List&lt;String&gt; strings) {\n        // Instead of: strings.forEach(s -&gt; System.out.println(s));\n        strings.forEach(System.out::println);\n    }\n}\n</code></pre> Remember that lambdas are powerful tools for writing more concise and functional code, but they should be used judiciously. Keep them simple and readable, and consider extracting complex logic to named methods when appropriate.</p>"},{"location":"1.Fundamentals/e_java/#java-date-and-time-apis-a-comprehensive-guide","title":"Java Date and Time APIs: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_7","title":"Introduction","text":"<p>Working with dates and times is a critical aspect of many applications, especially in domains like finance, healthcare, and scheduling. Java 8 introduced a new set of Date-Time APIs that address the limitations of legacy classes while providing a more robust and intuitive approach to handling temporal data.</p>"},{"location":"1.Fundamentals/e_java/#legacy-vs-modern-apis","title":"Legacy vs. Modern APIs","text":""},{"location":"1.Fundamentals/e_java/#legacy-challenges-pre-java-8","title":"Legacy Challenges (pre-Java 8)","text":"<pre><code>public class LegacyDateChallenges {\n    public void demonstrateIssues() {\n        // Problem 1: Date represents both date and time\n        Date now = new Date();  // Contains time components too\n\n        // Problem 2: Calendar's zero-based months are confusing\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(2023, Calendar.JANUARY, 1);  // January is 0, not 1\n\n        // Problem 3: Mutable objects lead to thread-safety issues\n        Date date = new Date();\n        doSomething(date);  // Date could be modified inside method\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#modern-solutions-java-8","title":"Modern Solutions (Java 8+)","text":"<pre><code>public class ModernDateTimeExample {\n    public void demonstrateModernApproach() {\n        // Clear separation of concerns\n        LocalDate today = LocalDate.now();  // Date only\n        LocalTime now = LocalTime.now();    // Time only\n        LocalDateTime current = LocalDateTime.now();  // Both date and time\n\n        // More intuitive month handling\n        LocalDate newYear = LocalDate.of(2023, Month.JANUARY, 1);\n\n        // Immutable objects ensure thread safety\n        LocalDate date = LocalDate.now();\n        someMethod(date);  // Original date cannot be modified\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#working-with-local-dates-and-times","title":"Working with Local Dates and Times","text":""},{"location":"1.Fundamentals/e_java/#date-operations","title":"Date Operations","text":"<pre><code>public class DateOperations {\n    public void demonstrateDateUsage() {\n        LocalDate today = LocalDate.now();\n\n        // Creating specific dates\n        LocalDate specificDate = LocalDate.of(2023, Month.DECEMBER, 25);\n        LocalDate parsedDate = LocalDate.parse(\"2023-12-25\");\n\n        // Date arithmetic\n        LocalDate nextWeek = today.plusWeeks(1);\n        LocalDate lastMonth = today.minusMonths(1);\n\n        // Date comparisons\n        boolean isBefore = today.isBefore(nextWeek);\n        boolean isAfter = today.isAfter(lastMonth);\n\n        // Getting date components\n        int year = today.getYear();\n        Month month = today.getMonth();\n        int dayOfMonth = today.getDayOfMonth();\n        DayOfWeek dayOfWeek = today.getDayOfWeek();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#time-operations","title":"Time Operations","text":"<pre><code>public class TimeOperations {\n    public void demonstrateTimeUsage() {\n        LocalTime now = LocalTime.now();\n\n        // Creating specific times\n        LocalTime specificTime = LocalTime.of(13, 30, 0);  // 1:30 PM\n        LocalTime parsedTime = LocalTime.parse(\"13:30:00\");\n\n        // Time arithmetic\n        LocalTime later = now.plusHours(2);\n        LocalTime earlier = now.minusMinutes(30);\n\n        // Time comparisons\n        boolean isBefore = now.isBefore(later);\n        boolean isAfter = now.isAfter(earlier);\n\n        // Getting time components\n        int hour = now.getHour();\n        int minute = now.getMinute();\n        int second = now.getSecond();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#working-with-time-zones","title":"Working With Time Zones","text":"<pre><code>public class TimeZoneOperations {\n    public void demonstrateTimeZoneUsage() {\n        // Getting time in specific zones\n        ZonedDateTime tokyoTime = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\n        ZonedDateTime londonTime = ZonedDateTime.now(ZoneId.of(\"Europe/London\"));\n\n        // Converting between time zones\n        ZonedDateTime localTime = ZonedDateTime.now();\n        ZonedDateTime parisTime = localTime.withZoneSameInstant(ZoneId.of(\"Europe/Paris\"));\n\n        // Handling daylight savings\n        ZoneId newYork = ZoneId.of(\"America/New_York\");\n        ZonedDateTime nyWinter = ZonedDateTime.of(\n            LocalDateTime.of(2023, 1, 1, 12, 0),\n            newYork\n        );\n        ZonedDateTime nySummer = nyWinter.plusMonths(6);  // Automatically handles DST\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#duration-and-period","title":"Duration and Period","text":"<pre><code>public class TimeCalculations {\n    public void demonstrateDurationAndPeriod() {\n        // Duration: time-based amount\n        LocalTime start = LocalTime.of(9, 0);\n        LocalTime end = LocalTime.of(17, 0);\n        Duration workDay = Duration.between(start, end);\n        System.out.println(\"Hours worked: \" + workDay.toHours());\n\n        // Period: date-based amount\n        LocalDate startDate = LocalDate.of(2023, 1, 1);\n        LocalDate endDate = LocalDate.of(2024, 1, 1);\n        Period period = Period.between(startDate, endDate);\n        System.out.println(\"Time span: \" + period.getYears() + \" years, \" +\n                         period.getMonths() + \" months, \" +\n                         period.getDays() + \" days\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#formatting-and-parsing","title":"Formatting and Parsing","text":"<pre><code>public class DateTimeFormatting {\n    public void demonstrateFormatting() {\n        LocalDateTime now = LocalDateTime.now();\n\n        // Using predefined formatters\n        String basic = now.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n\n        // Custom patterns\n        DateTimeFormatter customFormatter = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm\");\n        String custom = now.format(customFormatter);\n\n        // Locale-specific formatting\n        DateTimeFormatter frenchFormatter = DateTimeFormatter\n            .ofPattern(\"d MMMM yyyy\")\n            .withLocale(Locale.FRENCH);\n        String french = now.format(frenchFormatter);\n\n        // Parsing\n        LocalDate parsed = LocalDate.parse(\"2023-12-25\");\n        LocalDateTime customParsed = LocalDateTime.parse(\n            \"25-12-2023 15:30\",\n            customFormatter\n        );\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices_1","title":"Best Practices","text":"<p><pre><code>public class DateTimeBestPractices {\n    // 1. Use appropriate types for your needs\n    public void demonstrateBestPractices() {\n        // For date only\n        LocalDate date = LocalDate.now();\n\n        // For time only\n        LocalTime time = LocalTime.now();\n\n        // For date and time without time zone\n        LocalDateTime dateTime = LocalDateTime.now();\n\n        // For date and time with time zone\n        ZonedDateTime zonedDateTime = ZonedDateTime.now();\n    }\n\n    // 2. Use standard ISO formats for storage\n    public String serializeDateTime(LocalDateTime dateTime) {\n        return dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n    }\n\n    // 3. Handle time zones explicitly\n    public ZonedDateTime scheduleGlobalMeeting(LocalDateTime meetingTime, String timeZone) {\n        return meetingTime.atZone(ZoneId.of(timeZone));\n    }\n\n    // 4. Use appropriate duration types\n    public void calculateTimeframes() {\n        // Use Duration for time-based calculations\n        Duration timeElapsed = Duration.between(\n            LocalTime.of(9, 0),\n            LocalTime.of(17, 0)\n        );\n\n        // Use Period for date-based calculations\n        Period timeSpan = Period.between(\n            LocalDate.of(2023, 1, 1),\n            LocalDate.of(2024, 1, 1)\n        );\n    }\n}\n</code></pre> Remember that the modern Date-Time API is immutable and thread-safe, making it much more reliable for concurrent applications. Always prefer these modern classes over the legacy <code>Date</code> and <code>Calendar</code> classes for new development.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-loops-from-basics-to-best-practices","title":"Understanding Java Loops: From Basics to Best Practices","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-loops-in-java","title":"Introduction to Loops in Java","text":"<p>Imagine you need to perform a task repeatedly - perhaps printing a message 100 times or processing each element in a list. This is where loops come in. Loops are fundamental programming constructs that allow us to execute a block of code multiple times. Let's explore how Java implements these powerful tools.</p>"},{"location":"1.Fundamentals/e_java/#the-three-types-of-java-loops","title":"The Three Types of Java Loops","text":"<p>Java provides three main types of loops, each suited for different scenarios:</p> <ol> <li>The  <code>for</code>  loop - When you know exactly how many times you want to iterate</li> <li>The  <code>while</code>  loop - When you want to continue until a condition is met</li> <li>The  <code>do-while</code>  loop - When you want to execute the code at least once before checking the condition</li> </ol> <p>Let's explore each one in detail.</p>"},{"location":"1.Fundamentals/e_java/#the-for-loop-when-you-know-your-boundaries","title":"The for Loop: When You Know Your Boundaries","text":"<p>The  <code>for</code>  loop is perfect when you know exactly how many iterations you need. Think of it as planning a fixed number of repetitions in advance. Here's its structure: <pre><code>for (initialization; condition; update) {\n    // code to be repeated\n}\n</code></pre> Let's break this down with a real-world example: <pre><code>public class GradePrinter {\n    public void printGrades(int numberOfStudents) {\n        // We know exactly how many times we need to iterate\n        for (int student = 1; student &lt;= numberOfStudents; student++) {\n            System.out.println(\"Processing grades for student \" + student);\n\n            // This demonstrates how we can nest calculations within our loop\n            double average = calculateStudentAverage(student);\n            System.out.println(\"Student \" + student + \" average: \" + average);\n        }\n    }\n\n    private double calculateStudentAverage(int studentId) {\n        // Simplified for example\n        return 85.0;\n    }\n}\n</code></pre> This code demonstrates several important concepts:</p> <ul> <li>The initialization (<code>int student = 1</code>) happens once at the start</li> <li>The condition (<code>student &lt;= numberOfStudents</code>) is checked before each iteration</li> <li>The update (<code>student++</code>) happens after each iteration</li> </ul>"},{"location":"1.Fundamentals/e_java/#the-while-loop-when-youre-waiting-for-something","title":"The while Loop: When You're Waiting for Something","text":"<p>The  <code>while</code>  loop is ideal when you don't know exactly how many iterations you'll need, but you know the condition that should stop the loop. Think of it like waiting for a bus - you'll keep waiting until the bus arrives: <pre><code>public class DataProcessor {\n    public void processDataStream(DataStream stream) {\n        while (stream.hasMoreData()) {\n            Data chunk = stream.readNext();\n\n            // Process the data chunk\n            if (chunk.isCorrupted()) {\n                System.out.println(\"Found corrupted data, stopping processing\");\n                break;  // Demonstrates how to exit a loop early\n            }\n\n            processChunk(chunk);\n        }\n    }\n\n    private void processChunk(Data chunk) {\n        // Processing logic here\n    }\n}\n</code></pre> This example shows how  <code>while</code>  loops are perfect for:</p> <ul> <li>Processing data streams</li> <li>Waiting for user input</li> <li>Running background tasks</li> <li>Any scenario where you need to continue until a condition is met</li> </ul>"},{"location":"1.Fundamentals/e_java/#the-do-while-loop-when-you-need-to-act-first-ask-questions-later","title":"The do-while Loop: When You Need to Act First, Ask Questions Later","text":"<p>Sometimes you need to execute code at least once before checking if you should continue. The  <code>do-while</code>  loop is perfect for these scenarios: <pre><code>public class UserInterface {\n    public void getUserChoice(Scanner scanner) {\n        int choice;\n        do {\n            System.out.println(\"\\nPlease select an option:\");\n            System.out.println(\"1. Start new game\");\n            System.out.println(\"2. Load saved game\");\n            System.out.println(\"3. Exit\");\n\n            choice = scanner.nextInt();\n\n            if (choice &lt; 1 || choice &gt; 3) {\n                System.out.println(\"Invalid choice. Please try again.\");\n            }\n        } while (choice &lt; 1 || choice &gt; 3);\n\n        // Process valid choice\n        processUserChoice(choice);\n    }\n}\n</code></pre> This pattern is especially useful for:</p> <ul> <li>Input validation</li> <li>Menu systems</li> <li>Any scenario where you need at least one iteration</li> </ul>"},{"location":"1.Fundamentals/e_java/#advanced-loop-concepts","title":"Advanced Loop Concepts","text":""},{"location":"1.Fundamentals/e_java/#enhanced-for-loop-for-each","title":"Enhanced for Loop (for-each)","text":"<p>When working with collections or arrays, the enhanced for loop provides a cleaner syntax: <pre><code>public class CollectionProcessor {\n    public void processItems(List&lt;String&gt; items) {\n        // Traditional for loop\n        for (int i = 0; i &lt; items.size(); i++) {\n            String item = items.get(i);\n            processItem(item);\n        }\n\n        // Enhanced for loop - much cleaner!\n        for (String item : items) {\n            processItem(item);\n        }\n    }\n\n    private void processItem(String item) {\n        // Processing logic\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#loop-control-statements","title":"Loop Control Statements","text":"<p>Java provides several ways to control loop execution: <pre><code>public class LoopController {\n    public void processNumbers(List&lt;Integer&gt; numbers) {\n        for (Integer number : numbers) {\n            // Skip negative numbers\n            if (number &lt; 0) {\n                continue;  // Skips to the next iteration\n            }\n\n            // Stop if we find 100\n            if (number == 100) {\n                break;  // Exits the loop entirely\n            }\n\n            processNumber(number);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#nested-loops","title":"Nested Loops","text":"<p>Sometimes you need loops within loops. Here's a practical example: <pre><code>public class MatrixProcessor {\n    public void printMatrix(int[][] matrix) {\n        for (int row = 0; row &lt; matrix.length; row++) {\n            for (int col = 0; col &lt; matrix[row].length; col++) {\n                System.out.printf(\"%4d\", matrix[row][col]);\n            }\n            System.out.println();  // New line after each row\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-using-loops","title":"Best Practices for Using Loops","text":"<ol> <li>Choose the Right Loop<ul> <li>Use  <code>for</code>  when you know the number of iterations</li> <li>Use  <code>while</code>  when you don't know how many iterations but know the stopping condition</li> <li>Use  <code>do-while</code>  when you need at least one iteration</li> </ul> </li> <li>Avoid Infinite Loops <pre><code>// Bad - potential infinite loop\nwhile (true) {\n    // Dangerous if no break condition\n}\n\n// Good - clear exit condition\nwhile (shouldContinue()) {\n    // Loop body\n    updateContinueCondition();\n}\n</code></pre></li> <li>Consider Performance <pre><code>// Less efficient - creates new List object each iteration\nfor (int i = 0; i &lt; list.size(); i++) { }\n\n// More efficient - stores size once\nfor (int i = 0, size = list.size(); i &lt; size; i++) { }\n</code></pre></li> <li>Use Clear Iterator Names <pre><code>// Unclear\nfor (int x = 0; x &lt; 10; x++) { }\n\n// Clear and meaningful\nfor (int studentIndex = 0; studentIndex &lt; numberOfStudents; studentIndex++) { }\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-and-how-to-avoid-them_2","title":"Common Pitfalls and How to Avoid Them","text":"<ol> <li>Off-by-One Errors <pre><code>// Common mistake\nfor (int i = 0; i &lt;= array.length; i++) {  // Will cause ArrayIndexOutOfBoundsException\n    array[i] = 0;\n}\n\n// Correct version\nfor (int i = 0; i &lt; array.length; i++) {\n    array[i] = 0;\n}\n</code></pre></li> <li>Modifying Loop Variables <pre><code>// Dangerous - modifying loop variable inside loop\nfor (int i = 0; i &lt; 10; i++) {\n    // ... some code ...\n    i++;  // Don't do this!\n}\n\n// Better - clear and predictable\nfor (int i = 0; i &lt; 10; i++) {\n    // ... some code ...\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#conclusion","title":"Conclusion","text":"<p>Loops are fundamental building blocks in Java programming. By understanding when to use each type of loop and following best practices, you can write more efficient and maintainable code. Remember:</p> <ul> <li>Use  <code>for</code>  loops when you know the iteration count</li> <li>Use  <code>while</code>  loops when you have a condition to check</li> <li>Use  <code>do-while</code>  loops when you need at least one iteration</li> <li>Always ensure your loops have a clear exit condition</li> <li>Choose meaningful variable names</li> <li>Be careful with loop variable manipulation</li> </ul> <p>Practice working with different types of loops and their variations to become more comfortable with these essential programming constructs.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-exception-handling-from-fundamentals-to-best-practices","title":"Understanding Java Exception Handling: From Fundamentals to Best Practices","text":""},{"location":"1.Fundamentals/e_java/#introduction-why-exception-handling-matters","title":"Introduction: Why Exception Handling Matters","text":"<p>Imagine you're driving a car. Even with perfect driving skills, unexpected situations can arise - a flat tire, an engine warning light, or running low on fuel. Just as cars have warning systems and safety measures, programs need mechanisms to handle unexpected situations gracefully. This is where exception handling comes in.</p> <p>In Java, exception handling is our way of dealing with unexpected events that could disrupt our program's normal flow. Let's explore how it works and why it's crucial for writing robust applications.</p>"},{"location":"1.Fundamentals/e_java/#understanding-exceptions-the-basics","title":"Understanding Exceptions: The Basics","text":"<p>An exception in Java represents an abnormal condition that occurs during program execution. Think of it as a special signal that says \"something unexpected happened.\" Here's a simple example: <pre><code>public class BankAccount {\n    private double balance;\n\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount &gt; balance) {\n            // Something unexpected happened - not enough money!\n            throw new InsufficientFundsException(\"Insufficient balance: \" + balance);\n        }\n        balance -= amount;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#the-exception-hierarchy","title":"The Exception Hierarchy","text":"<p>Java organizes exceptions in a hierarchy, much like a family tree. Understanding this hierarchy helps us handle exceptions more effectively: <pre><code>public class ExceptionHierarchyExample {\n    public static void main(String[] args) {\n        try {\n            // Demonstrate different types of exceptions\n            demonstrateChecked();\n            demonstrateUnchecked();\n            demonstrateError();\n        } catch (Exception e) {\n            System.out.println(\"Caught exception: \" + e.getMessage());\n        }\n    }\n\n    // Checked Exception example\n    private static void demonstrateChecked() throws IOException {\n        // This might throw a checked exception\n        File file = new File(\"nonexistent.txt\");\n        FileInputStream stream = new FileInputStream(file);\n    }\n\n    // Unchecked Exception example\n    private static void demonstrateUnchecked() {\n        int[] array = new int[5];\n        // This will throw ArrayIndexOutOfBoundsException\n        array[10] = 50;\n    }\n\n    // Error example\n    private static void demonstrateError() {\n        // This might cause OutOfMemoryError\n        int[] hugeArray = new int[Integer.MAX_VALUE];\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#the-three-categories-of-throwable-objects","title":"The Three Categories of Throwable Objects","text":""},{"location":"1.Fundamentals/e_java/#1-checked-exceptions","title":"1. Checked Exceptions","text":"<p>These are exceptions that must be handled or declared. They represent conditions that a well-written application should anticipate and recover from. <pre><code>public class FileProcessor {\n    public String readFile(String path) {\n        try {\n            // Attempting to read a file - this could fail!\n            return Files.readString(Path.of(path));\n        } catch (IOException e) {\n            // Handle the exception gracefully\n            logError(\"Failed to read file\", e);\n            return \"\"; // Return a sensible default\n        }\n    }\n\n    private void logError(String message, Exception e) {\n        // Logging logic here\n        System.err.println(message + \": \" + e.getMessage());\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-unchecked-exceptions-runtime-exceptions","title":"2. Unchecked Exceptions (Runtime Exceptions)","text":"<p>These represent programming errors that might occur anywhere in your program. <pre><code>public class ArrayProcessor {\n    public double calculateAverage(int[] numbers) {\n        // Guard against null input\n        if (numbers == null) {\n            throw new IllegalArgumentException(\"Input array cannot be null\");\n        }\n\n        // Guard against empty array\n        if (numbers.length == 0) {\n            throw new IllegalArgumentException(\"Input array cannot be empty\");\n        }\n\n        double sum = 0;\n        for (int number : numbers) {\n            sum += number;\n        }\n\n        return sum / numbers.length;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-errors","title":"3. Errors","text":"<p>These represent serious problems that most applications should not try to handle. <pre><code>public class MemoryConsumer {\n    public void demonstrateError() {\n        try {\n            while (true) {\n                // This might cause OutOfMemoryError\n                long[] array = new long[Integer.MAX_VALUE];\n            }\n        } catch (OutOfMemoryError e) {\n            // While we can catch Errors, it's generally not recommended\n            System.err.println(\"Memory exhausted: \" + e.getMessage());\n            // Proper handling might include logging and graceful shutdown\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#exception-handling-best-practices","title":"Exception Handling Best Practices","text":""},{"location":"1.Fundamentals/e_java/#1-use-specific-exception-types","title":"1. Use Specific Exception Types","text":"<p>Instead of catching general exceptions, catch specific ones: <pre><code>public class ResourceManager {\n    public void processResource() {\n        try {\n            // Resource processing code\n        } catch (FileNotFoundException e) {\n            // Handle missing file specifically\n            System.err.println(\"Resource file not found: \" + e.getMessage());\n        } catch (IOException e) {\n            // Handle other I/O problems differently\n            System.err.println(\"Error accessing resource: \" + e.getMessage());\n        } catch (Exception e) {\n            // Last resort - catch any other unexpected exceptions\n            System.err.println(\"Unexpected error: \" + e.getMessage());\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-always-close-resources","title":"2. Always Close Resources","text":"<p>Use try-with-resources for automatic resource management: <pre><code>public class FileReader {\n    public List&lt;String&gt; readLines(String filename) {\n        List&lt;String&gt; lines = new ArrayList&lt;&gt;();\n\n        // Resources are automatically closed after the try block\n        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                lines.add(line);\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error reading file: \" + e.getMessage());\n        }\n\n        return lines;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-maintain-exception-chain","title":"3. Maintain Exception Chain","text":"<p>When wrapping exceptions, preserve the original cause: <pre><code>public class DatabaseWrapper {\n    public void saveRecord(Record record) {\n        try {\n            // Database operation\n            performDatabaseOperation(record);\n        } catch (SQLException e) {\n            // Wrap the SQL exception but keep its information\n            throw new DatabaseException(\"Failed to save record\", e);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#4-create-custom-exceptions-when-needed","title":"4. Create Custom Exceptions When Needed","text":"<p>For domain-specific error conditions: <pre><code>public class CustomExceptionExample {\n    public class InsufficientFundsException extends Exception {\n        private final double available;\n        private final double required;\n\n        public InsufficientFundsException(double available, double required) {\n            super(String.format(\"Insufficient funds: available %.2f, required %.2f\",\n                              available, required));\n            this.available = available;\n            this.required = required;\n        }\n\n        public double getDeficit() {\n            return required - available;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-exception-handling-techniques","title":"Advanced Exception Handling Techniques","text":""},{"location":"1.Fundamentals/e_java/#1-exception-filtering","title":"1. Exception Filtering","text":"<p>Use conditional catch blocks to handle exceptions differently based on conditions: <pre><code>public class ExceptionFilter {\n    public void processWithFiltering(String input) {\n        try {\n            processInput(input);\n        } catch (Exception e) {\n            if (e instanceof NumberFormatException &amp;&amp; input.trim().isEmpty()) {\n                // Handle empty input specially\n                System.err.println(\"Empty input provided\");\n            } else if (e instanceof IllegalArgumentException) {\n                // Handle invalid arguments\n                System.err.println(\"Invalid argument: \" + e.getMessage());\n            } else {\n                // Handle other exceptions\n                System.err.println(\"Unexpected error: \" + e.getMessage());\n            }\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-multi-catch-blocks","title":"2. Multi-catch Blocks","text":"<p>Handle multiple exceptions in the same way: <pre><code>public class MultiCatchExample {\n    public void processWithMultiCatch() {\n        try {\n            // Some processing\n        } catch (IOException | SQLException e) {\n            // Handle both types of exceptions the same way\n            System.err.println(\"Error processing data: \" + e.getMessage());\n            logException(e);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conclusion_1","title":"Conclusion","text":"<p>Exception handling is not just about catching errors - it's about making your application more robust and maintainable. By following these practices and understanding the different types of exceptions, you can write code that gracefully handles unexpected situations while remaining clean and maintainable.</p> <p>Remember:</p> <ul> <li>Use specific exception types</li> <li>Always close resources properly</li> <li>Maintain the exception chain</li> <li>Create custom exceptions when appropriate</li> <li>Consider the context when choosing between checked and unchecked exceptions</li> <li>Use advanced features like try-with-resources and multi-catch blocks when appropriate</li> </ul> <p>Exception handling is an art as much as it is a science - with practice and attention to these principles, you can master it to create more reliable applications.</p>"},{"location":"1.Fundamentals/e_java/#java-objects-and-classes-a-complete-guide","title":"Java Objects and Classes: A Complete Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_8","title":"Introduction","text":"<p>Objects and classes are the foundation of Object-Oriented Programming in Java. Think of a class as a blueprint and objects as the actual structures built from that blueprint. Just as you can build multiple houses from the same blueprint, you can create multiple objects from the same class.</p>"},{"location":"1.Fundamentals/e_java/#understanding-classes","title":"Understanding Classes","text":"<p>A class is a template that defines:</p> <ul> <li>State (fields/attributes)</li> <li>Behavior (methods)</li> <li>Initialization (constructors) <pre><code>public class BankAccount {\n    // State - fields\n    private double balance;\n    private String accountNumber;\n    private String ownerName;\n\n    // Initialization - constructor\n    public BankAccount(String accountNumber, String ownerName) {\n        this.accountNumber = accountNumber;\n        this.ownerName = ownerName;\n        this.balance = 0.0;\n    }\n\n    // Behavior - methods\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        }\n    }\n\n    public boolean withdraw(double amount) {\n        if (amount &lt;= balance &amp;&amp; amount &gt; 0) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n\n    public double getBalance() {\n        return balance;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#class-components","title":"Class Components","text":"<ol> <li>Fields (Instance Variables): <pre><code>public class Employee {\n    // Instance variables represent state\n    private int id;\n    private String name;\n    private double salary;\n\n    // Static variable shared across all instances\n    private static int employeeCount = 0;\n}\n</code></pre></li> <li>Methods: <pre><code>public class Calculator {\n    // Instance method\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    // Static method\n    public static double multiply(double a, double b) {\n        return a * b;\n    }\n}\n</code></pre></li> <li>Constructors: <pre><code>public class Person {\n    private String name;\n    private int age;\n\n    // Default constructor\n    public Person() {\n        this.name = \"Unknown\";\n        this.age = 0;\n    }\n\n    // Parameterized constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#working-with-objects","title":"Working with Objects","text":"<p>Objects are instances of classes. Here's how to create and work with them:  <pre><code>public class ObjectDemo {\n    public static void main(String[] args) {\n        // Creating objects\n        BankAccount account1 = new BankAccount(\"1001\", \"John Doe\");\n        BankAccount account2 = new BankAccount(\"1002\", \"Jane Smith\");\n\n        // Using object methods\n        account1.deposit(1000);\n        account2.deposit(500);\n\n        // Accessing object state through methods\n        System.out.println(\"Account 1 balance: \" + account1.getBalance());\n        System.out.println(\"Account 2 balance: \" + account2.getBalance());\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#object-initialization-techniques","title":"Object Initialization Techniques","text":"<pre><code>public class ObjectInitialization {\n    public static void main(String[] args) {\n        // 1. Using constructor\n        Car car1 = new Car(\"Toyota\", \"Camry\");\n\n        // 2. Using setter methods\n        Car car2 = new Car();\n        car2.setMake(\"Honda\");\n        car2.setModel(\"Civic\");\n\n        // 3. Using initialization blocks\n        Car car3 = new Car() {{\n            setMake(\"Ford\");\n            setModel(\"Mustang\");\n        }};\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices_2","title":"Best Practices","text":""},{"location":"1.Fundamentals/e_java/#1-encapsulation","title":"1. Encapsulation","text":"<pre><code>public class Student {\n    // Private fields for encapsulation\n    private String name;\n    private int grade;\n\n    // Public methods to access and modify state\n    public String getName() {\n        return name;\n    }\n\n    public void setGrade(int grade) {\n        if (grade &gt;= 0 &amp;&amp; grade &lt;= 100) {\n            this.grade = grade;\n        } else {\n            throw new IllegalArgumentException(\"Grade must be between 0 and 100\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-immutable-classes","title":"2. Immutable Classes","text":"<pre><code>public final class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    // No setter methods - class is immutable\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-method-design","title":"3. Method Design","text":"<pre><code>public class OrderProcessor {\n    // Good: Method does one thing\n    public boolean validateOrder(Order order) {\n        return order != null &amp;&amp; \n               order.getItems() != null &amp;&amp; \n               !order.getItems().isEmpty() &amp;&amp;\n               order.getTotalAmount() &gt; 0;\n    }\n\n    // Good: Clear method name and parameters\n    public void processPayment(Order order, PaymentMethod method) {\n        if (!validateOrder(order)) {\n            throw new IllegalArgumentException(\"Invalid order\");\n        }\n        // Process payment logic...\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#real-world-example-building-a-library-system","title":"Real-World Example: Building a Library System","text":"<p><pre><code>public class Library {\n    private List&lt;Book&gt; books;\n    private Map&lt;String, Member&gt; members;\n\n    public Library() {\n        this.books = new ArrayList&lt;&gt;();\n        this.members = new HashMap&lt;&gt;();\n    }\n\n    public void addBook(Book book) {\n        books.add(book);\n    }\n\n    public boolean lendBook(String bookId, String memberId) {\n        Book book = findBook(bookId);\n        Member member = members.get(memberId);\n\n        if (book != null &amp;&amp; member != null &amp;&amp; book.isAvailable()) {\n            book.setAvailable(false);\n            member.borrowBook(book);\n            return true;\n        }\n        return false;\n    }\n\n    private Book findBook(String bookId) {\n        return books.stream()\n                   .filter(b -&gt; b.getId().equals(bookId))\n                   .findFirst()\n                   .orElse(null);\n    }\n}\n\npublic class Book {\n    private String id;\n    private String title;\n    private String author;\n    private boolean available;\n\n    // Constructor, getters, setters...\n}\n\npublic class Member {\n    private String id;\n    private String name;\n    private List&lt;Book&gt; borrowedBooks;\n\n    public void borrowBook(Book book) {\n        borrowedBooks.add(book);\n    }\n\n    public void returnBook(Book book) {\n        borrowedBooks.remove(book);\n        book.setAvailable(true);\n    }\n}\n</code></pre> This comprehensive guide covers the fundamentals of objects and classes in Java. Remember that good object-oriented design focuses on creating classes that are:</p> <ul> <li>Well-encapsulated</li> <li>Single-responsibility focused</li> <li>Easy to understand and maintain</li> <li>Reusable and extensible</li> </ul>"},{"location":"1.Fundamentals/e_java/#understanding-java-inheritance","title":"Understanding Java Inheritance","text":""},{"location":"1.Fundamentals/e_java/#introduction_9","title":"Introduction","text":"<p>Inheritance is a fundamental concept in Object-Oriented Programming that allows a class to inherit properties and behaviors from another class. Think of it like genetic inheritance: just as children inherit traits from their parents, a subclass inherits characteristics from its superclass.</p>"},{"location":"1.Fundamentals/e_java/#basic-inheritance-concepts","title":"Basic Inheritance Concepts","text":"<p> <pre><code>// Parent/Super class\npublic class Animal {\n    protected String name;\n    protected String species;\n\n    public Animal(String name, String species) {\n        this.name = name;\n        this.species = species;\n    }\n\n    public void makeSound() {\n        System.out.println(\"Some generic animal sound\");\n    }\n}\n\n// Child/Sub class\npublic class Dog extends Animal {\n    private String breed;\n\n    public Dog(String name, String breed) {\n        super(name, \"Canis familiaris\");  // Call parent constructor\n        this.breed = breed;\n    }\n\n    // Method overriding\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#types-of-inheritance","title":"Types of Inheritance","text":""},{"location":"1.Fundamentals/e_java/#1-single-inheritance","title":"1. Single Inheritance","text":"<pre><code>public class Vehicle {\n    protected String brand;\n    protected String model;\n\n    public void start() {\n        System.out.println(\"Starting vehicle\");\n    }\n}\n\npublic class Car extends Vehicle {\n    private int numberOfDoors;\n\n    public void accelerate() {\n        System.out.println(\"Car accelerating\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-multilevel-inheritance","title":"2. Multilevel Inheritance","text":"<pre><code>public class Vehicle {\n    protected String brand;\n\n    public void start() {\n        System.out.println(\"Starting vehicle\");\n    }\n}\n\npublic class Car extends Vehicle {\n    protected int numberOfDoors;\n\n    public void accelerate() {\n        System.out.println(\"Car accelerating\");\n    }\n}\n\npublic class ElectricCar extends Car {\n    private int batteryCapacity;\n\n    public void charge() {\n        System.out.println(\"Charging electric car\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-hierarchical-inheritance","title":"3. Hierarchical Inheritance","text":"<p><pre><code>public class Shape {\n    protected double area;\n\n    public double getArea() {\n        return area;\n    }\n}\n\npublic class Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n        this.area = Math.PI * radius * radius;\n    }\n}\n\npublic class Rectangle extends Shape {\n    private double length;\n    private double width;\n\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n        this.area = length * width;\n    }\n}\n</code></pre> </p>"},{"location":"1.Fundamentals/e_java/#working-with-super-keyword","title":"Working with super Keyword","text":"<p>The  <code>super</code>  keyword is used to:</p> <ol> <li>Call parent class constructor</li> <li>Access parent class methods</li> <li>Access parent class fields <pre><code>public class Employee {\n    protected String name;\n    protected double baseSalary;\n\n    public Employee(String name, double baseSalary) {\n        this.name = name;\n        this.baseSalary = baseSalary;\n    }\n\n    public double calculateSalary() {\n        return baseSalary;\n    }\n}\n\npublic class Manager extends Employee {\n    private double bonus;\n\n    public Manager(String name, double baseSalary, double bonus) {\n        super(name, baseSalary);  // Call parent constructor\n        this.bonus = bonus;\n    }\n\n    @Override\n    public double calculateSalary() {\n        return super.calculateSalary() + bonus;  // Call parent method\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#method-overriding-rules","title":"Method Overriding Rules","text":"<ol> <li>Method signature must be identical</li> <li>Return type must be same or covariant</li> <li>Access level must be same or less restrictive</li> <li>Can't override static or final methods <pre><code>public class Animal {\n    public void makeSound() {\n        System.out.println(\"Animal sound\");\n    }\n\n    public Animal reproduce() {\n        return new Animal();\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {  // Same signature\n        System.out.println(\"Woof!\");\n    }\n\n    @Override\n    public Dog reproduce() {   // Covariant return type\n        return new Dog();\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#understanding-type-casting-in-inheritance","title":"Understanding Type Casting in Inheritance","text":"<pre><code>public class CastingExample {\n    public void demonstrateCasting() {\n        // Upcasting - implicit\n        Animal dog = new Dog();\n\n        // Downcasting - explicit\n        if (dog instanceof Dog) {\n            Dog specificDog = (Dog) dog;\n            specificDog.wagTail();\n        }\n\n        // Preventing ClassCastException\n        Animal cat = new Cat();\n        if (cat instanceof Dog) {\n            Dog impossibleDog = (Dog) cat;  // Won't execute\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices_3","title":"Best Practices","text":""},{"location":"1.Fundamentals/e_java/#1-use-inheritance-for-is-a-relationships","title":"1. Use Inheritance for \"is-a\" Relationships","text":"<pre><code>// Good - A Car IS-A Vehicle\npublic class Car extends Vehicle { }\n\n// Bad - A Car HAS-A Engine (should use composition)\npublic class Car extends Engine { }  // Incorrect usage\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-favor-composition-over-inheritance","title":"2. Favor Composition Over Inheritance","text":"<pre><code>// Better approach using composition\npublic class Car {\n    private Engine engine;\n    private Transmission transmission;\n\n    public Car(Engine engine, Transmission transmission) {\n        this.engine = engine;\n        this.transmission = transmission;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-design-for-inheritance-or-prohibit-it","title":"3. Design for Inheritance or Prohibit It","text":"<pre><code>// Designed for inheritance\npublic class AbstractVehicle {\n    protected final void startEngine() {  // Template method\n        performSafetyChecks();\n        initializeEngine();\n        notifyEngineStarted();\n    }\n\n    protected abstract void performSafetyChecks();\n    protected abstract void initializeEngine();\n}\n\n// Prohibited from inheritance\npublic final class ImmutableConfig {\n    private final String setting;\n\n    public ImmutableConfig(String setting) {\n        this.setting = setting;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#4-document-inheritance-points","title":"4. Document Inheritance Points","text":"<pre><code>/**\n * Abstract base class for payment processors.\n * Subclasses must implement the process method and\n * should override validatePayment if additional validation is needed.\n */\npublic abstract class PaymentProcessor {\n    /**\n     * Template method for processing payments.\n     * @param amount The amount to process\n     * @throws PaymentException if processing fails\n     */\n    public final void processPayment(double amount) {\n        validatePayment(amount);\n        process(amount);\n        notifySuccess();\n    }\n\n    /**\n     * Override this method to implement specific payment logic.\n     * @param amount The amount to process\n     */\n    protected abstract void process(double amount);\n\n    /**\n     * Basic payment validation.\n     * Subclasses may override to add additional validation.\n     */\n    protected void validatePayment(double amount) {\n        if (amount &lt;= 0) {\n            throw new IllegalArgumentException(\"Amount must be positive\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Breaking encapsulation in subclasses</li> <li>Deep inheritance hierarchies</li> <li>Inheritance for code reuse rather than modeling</li> <li>Not considering the Liskov Substitution Principle</li> </ol> <p>Remember that inheritance is a powerful feature but should be used judiciously. Always consider whether composition might be a better choice for your specific use case.</p>"},{"location":"1.Fundamentals/e_java/#java-polymorphism-a-complete-guide","title":"Java Polymorphism: A Complete Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction_10","title":"Introduction","text":"<p>Polymorphism is one of the four fundamental principles of Object-Oriented Programming, allowing objects to take multiple forms. In Java, polymorphism enables you to perform a single action in different ways, providing flexibility and reusability in your code.</p>"},{"location":"1.Fundamentals/e_java/#types-of-polymorphism","title":"Types of Polymorphism","text":""},{"location":"1.Fundamentals/e_java/#1-compile-time-polymorphism-method-overloading","title":"1. Compile-time Polymorphism (Method Overloading)","text":"<pre><code>public class Calculator {\n    // Method overloading examples\n\n    // Basic addition\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    // Three parameter version\n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n\n    // Double version\n    public double add(double a, double b) {\n        return a + b;\n    }\n\n    // String concatenation\n    public String add(String a, String b) {\n        return a + b;\n    }\n}\n\n// Usage example\npublic class CompileTimeExample {\n    public static void main(String[] args) {\n        Calculator calc = new Calculator();\n\n        System.out.println(calc.add(5, 3));          // Uses first method\n        System.out.println(calc.add(5, 3, 2));       // Uses second method\n        System.out.println(calc.add(5.5, 3.2));      // Uses third method\n        System.out.println(calc.add(\"Hello \", \"World\")); // Uses fourth method\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-runtime-polymorphism-method-overriding","title":"2. Runtime Polymorphism (Method Overriding)","text":"<pre><code>// Base class\npublic class Animal {\n    public void makeSound() {\n        System.out.println(\"Some generic animal sound\");\n    }\n\n    public void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\n// Derived classes\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n\n    @Override\n    public void eat() {\n        System.out.println(\"Dog is eating bones\");\n    }\n}\n\npublic class Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n\n    @Override\n    public void eat() {\n        System.out.println(\"Cat is eating fish\");\n    }\n}\n\n// Usage example\npublic class RuntimeExample {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();    // Upcasting\n        Animal myCat = new Cat();    // Upcasting\n\n        // Method calls are resolved at runtime\n        myDog.makeSound();  // Outputs: Woof!\n        myCat.makeSound();  // Outputs: Meow!\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#understanding-dynamic-method-dispatch","title":"Understanding Dynamic Method Dispatch","text":"<p>Dynamic Method Dispatch is the mechanism by which Java implements runtime polymorphism: <pre><code>public class PaymentProcessor {\n    // Base class with common payment processing logic\n    public void processPayment() {\n        validatePayment();\n        performPayment();\n        notifyUser();\n    }\n\n    protected void validatePayment() {\n        System.out.println(\"Basic payment validation\");\n    }\n\n    protected void performPayment() {\n        System.out.println(\"Generic payment processing\");\n    }\n\n    private void notifyUser() {\n        System.out.println(\"Payment notification sent\");\n    }\n}\n\npublic class CreditCardProcessor extends PaymentProcessor {\n    @Override\n    protected void validatePayment() {\n        System.out.println(\"Credit card validation\");\n    }\n\n    @Override\n    protected void performPayment() {\n        System.out.println(\"Processing credit card payment\");\n    }\n}\n\npublic class PayPalProcessor extends PaymentProcessor {\n    @Override\n    protected void validatePayment() {\n        System.out.println(\"PayPal account validation\");\n    }\n\n    @Override\n    protected void performPayment() {\n        System.out.println(\"Processing PayPal payment\");\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#important-rules-and-considerations","title":"Important Rules and Considerations","text":""},{"location":"1.Fundamentals/e_java/#method-overriding-rules_1","title":"Method Overriding Rules","text":"<ol> <li>Method signature must be identical</li> <li>Return type must be same or covariant</li> <li>Access level must be same or less restrictive</li> <li>Can't override static or final methods <pre><code>public class OverridingRules {\n    class Parent {\n        protected Number getValue() {\n            return 42;\n        }\n    }\n\n    class Child extends Parent {\n        @Override\n        public Integer getValue() {  // Covariant return type\n            return 100;\n        }\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#data-member-access","title":"Data Member Access","text":"<p>Runtime polymorphism applies to methods, not data members: <pre><code>public class DataMemberExample {\n    class Parent {\n        int value = 100;\n    }\n\n    class Child extends Parent {\n        int value = 200;  // Hides parent's value\n    }\n\n    public void demonstrate() {\n        Parent p = new Child();\n        System.out.println(p.value);  // Prints 100, not 200\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices_4","title":"Best Practices","text":""},{"location":"1.Fundamentals/e_java/#1-use-override-annotation","title":"1. Use @Override Annotation","text":"<pre><code>public class BestPractices {\n    class Parent {\n        void doWork() { }\n    }\n\n    class Child extends Parent {\n        @Override  // Catches errors if method signature doesn't match\n        void doWork() {\n            // Implementation\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-design-for-inheritance","title":"2. Design for Inheritance","text":"<pre><code>public abstract class AbstractProcessor {\n    // Template method pattern\n    public final void process() {  // Final prevents override\n        preProcess();\n        doProcess();   // Abstract method\n        postProcess();\n    }\n\n    protected abstract void doProcess();  // Must be implemented\n\n    protected void preProcess() {  // Can be overridden\n        // Default implementation\n    }\n\n    protected void postProcess() {  // Can be overridden\n        // Default implementation\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-favor-composition-over-inheritance","title":"3. Favor Composition Over Inheritance","text":"<pre><code>// Instead of inheritance hierarchy\npublic class PaymentStrategy {\n    private final PaymentProcessor processor;\n\n    public PaymentStrategy(PaymentProcessor processor) {\n        this.processor = processor;\n    }\n\n    public void executePayment() {\n        processor.processPayment();\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#common-use-cases_1","title":"Common Use Cases","text":""},{"location":"1.Fundamentals/e_java/#1-plugin-architecture","title":"1. Plugin Architecture","text":"<pre><code>public interface Plugin {\n    void initialize();\n    void execute();\n    void shutdown();\n}\n\n// Different plugins can be loaded dynamically\npublic class ImageProcessorPlugin implements Plugin {\n    @Override\n    public void initialize() { /* Implementation */ }\n\n    @Override\n    public void execute() { /* Implementation */ }\n\n    @Override\n    public void shutdown() { /* Implementation */ }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-strategy-pattern","title":"2. Strategy Pattern","text":"<p><pre><code>public interface SortStrategy {\n    void sort(int[] array);\n}\n\npublic class QuickSort implements SortStrategy {\n    @Override\n    public void sort(int[] array) {\n        // QuickSort implementation\n    }\n}\n\npublic class MergeSort implements SortStrategy {\n    @Override\n    public void sort(int[] array) {\n        // MergeSort implementation\n    }\n}\n</code></pre> Polymorphism is a powerful feature that enables you to write more flexible and maintainable code. Remember to use it judiciously and always consider whether inheritance is the best solution for your specific use case.</p>"},{"location":"1.Fundamentals/e_java/#understanding-abstraction-in-java","title":"Understanding Abstraction in Java","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-abstraction","title":"Introduction to Abstraction","text":"<p>Abstraction is the process of hiding implementation details and showing only the functionality to the user. Think of it like driving a car - you just need to know how to use the steering wheel, pedals, and gear shift, not how the engine internally works.</p>"},{"location":"1.Fundamentals/e_java/#basic-concepts","title":"Basic Concepts","text":"<p><pre><code>// Abstract class example\npublic abstract class Vehicle {\n    // Abstract method - no implementation\n    public abstract void start();\n\n    // Concrete method with implementation\n    public void stop() {\n        System.out.println(\"Vehicle is stopping\");\n    }\n}\n\n// Concrete class implementing abstract class\npublic class Car extends Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Car is starting with key ignition\");\n    }\n}\n</code></pre> </p>"},{"location":"1.Fundamentals/e_java/#types-of-abstraction","title":"Types of Abstraction","text":""},{"location":"1.Fundamentals/e_java/#1-abstract-classes","title":"1. Abstract Classes","text":"<pre><code>public abstract class BankAccount {\n    protected double balance;\n\n    // Abstract method\n    public abstract void deposit(double amount);\n\n    // Abstract method\n    public abstract void withdraw(double amount);\n\n    // Concrete method\n    public double getBalance() {\n        return balance;\n    }\n}\n\npublic class SavingsAccount extends BankAccount {\n    @Override\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n            System.out.println(\"Deposited: \" + amount);\n        }\n    }\n\n    @Override\n    public void withdraw(double amount) {\n        if (amount &lt;= balance) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: \" + amount);\n        } else {\n            System.out.println(\"Insufficient funds\");\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-interfaces","title":"2. Interfaces","text":"<pre><code>public interface PaymentProcessor {\n    void processPayment(double amount);\n    void refundPayment(double amount);\n    boolean validatePayment(double amount);\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment: \" + amount);\n        // Implementation details\n    }\n\n    @Override\n    public void refundPayment(double amount) {\n        System.out.println(\"Processing credit card refund: \" + amount);\n        // Implementation details\n    }\n\n    @Override\n    public boolean validatePayment(double amount) {\n        // Validation logic\n        return amount &gt; 0 &amp;&amp; amount &lt;= 5000;\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#abstract-class-vs-interface","title":"Abstract Class vs Interface","text":""},{"location":"1.Fundamentals/e_java/#abstract-class","title":"Abstract Class","text":"<ul> <li>Can have both abstract and concrete methods</li> <li>Can have constructor and state</li> <li>Supports partial implementation</li> <li>Single inheritance only</li> </ul>"},{"location":"1.Fundamentals/e_java/#interface","title":"Interface","text":"<ul> <li>All methods are abstract by default (prior to Java 8)</li> <li>No constructors or state (except constants)</li> <li>Complete abstraction</li> <li>Multiple inheritance supported <pre><code>// Abstract class example\npublic abstract class Shape {\n    protected String color;\n\n    public Shape(String color) {\n        this.color = color;\n    }\n\n    abstract double calculateArea();\n\n    // Concrete method\n    public void displayColor() {\n        System.out.println(\"Color is \" + color);\n    }\n}\n\n// Interface example\npublic interface Drawable {\n    void draw();\n    void resize(double factor);\n}\n\n// Class implementing both\npublic class Circle extends Shape implements Drawable {\n    private double radius;\n\n    public Circle(String color, double radius) {\n        super(color);\n        this.radius = radius;\n    }\n\n    @Override\n    double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing circle\");\n    }\n\n    @Override\n    public void resize(double factor) {\n        this.radius *= factor;\n    }\n}\n</code></pre></li> </ul>"},{"location":"1.Fundamentals/e_java/#best-practices_5","title":"Best Practices","text":""},{"location":"1.Fundamentals/e_java/#1-design-for-abstraction","title":"1. Design for Abstraction","text":"<pre><code>// Good abstraction - focuses on what, not how\npublic interface MessageSender {\n    void sendMessage(String message);\n}\n\n// Implementation details hidden\npublic class EmailSender implements MessageSender {\n    @Override\n    public void sendMessage(String message) {\n        // Email sending implementation\n    }\n}\n\npublic class SMSSender implements MessageSender {\n    @Override\n    public void sendMessage(String message) {\n        // SMS sending implementation\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-user-interfaces-for-api-design","title":"2. User Interfaces for API Design","text":"<pre><code>public interface DataStorage {\n    void save(String key, Object data);\n    Object retrieve(String key);\n    void delete(String key);\n}\n\n// Different implementations can be swapped without affecting client code\npublic class DatabaseStorage implements DataStorage {\n    // Database implementation\n}\n\npublic class FileStorage implements DataStorage {\n    // File system implementation\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-abstract-classes-for-common-functionality","title":"3. Abstract Classes for Common Functionality","text":"<pre><code>public abstract class AbstractLogger {\n    protected LogLevel level;\n\n    // Common functionality\n    protected void formatMessage(String message) {\n        // Common message formatting logic\n    }\n\n    // Must be implemented by specific loggers\n    abstract void log(String message);\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#real-world-example-report-generator","title":"Real-World Example: Report Generator","text":"<p><pre><code>// Abstract base class for report generation\npublic abstract class ReportGenerator {\n    protected final String reportName;\n    protected final Date generationDate;\n\n    public ReportGenerator(String reportName) {\n        this.reportName = reportName;\n        this.generationDate = new Date();\n    }\n\n    // Template method pattern\n    public final void generateReport() {\n        gatherData();\n        processData();\n        formatReport();\n        deliverReport();\n    }\n\n    protected abstract void gatherData();\n    protected abstract void processData();\n    protected abstract void formatReport();\n\n    // Common implementation\n    protected void deliverReport() {\n        System.out.println(\"Delivering report: \" + reportName);\n    }\n}\n\n// Concrete implementation\npublic class SalesReport extends ReportGenerator {\n    private final String region;\n\n    public SalesReport(String region) {\n        super(\"Sales Report - \" + region);\n        this.region = region;\n    }\n\n    @Override\n    protected void gatherData() {\n        System.out.println(\"Gathering sales data for region: \" + region);\n    }\n\n    @Override\n    protected void processData() {\n        System.out.println(\"Processing sales statistics\");\n    }\n\n    @Override\n    protected void formatReport() {\n        System.out.println(\"Formatting sales report\");\n    }\n}\n</code></pre> Remember that abstraction is about hiding complexity and exposing only what's necessary. When designing abstractions:</p> <ul> <li>Focus on what the code does, not how it does it</li> <li>Keep interfaces simple and cohesive</li> <li>Use abstract classes for partial implementation and shared state</li> <li>Use interfaces for defining contracts and enabling multiple inheritance</li> </ul>"},{"location":"1.Fundamentals/e_java/#understanding-encapsulation-in-java-a-technical-deep-dive","title":"Understanding Encapsulation in Java: A Technical Deep Dive","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-encapsulation","title":"Introduction to Encapsulation","text":"<p>Encapsulation is a fundamental Object-Oriented Programming (OOP) principle that combines data and the methods that operate on that data into a single unit called a class. While often conflated with data hiding, encapsulation is actually a broader concept that focuses on bundling related components together to create more maintainable and modular code.</p>"},{"location":"1.Fundamentals/e_java/#core-concepts-of-encapsulation","title":"Core Concepts of Encapsulation","text":""},{"location":"1.Fundamentals/e_java/#bundling-related-elements","title":"Bundling Related Elements","text":"<p>At its heart, encapsulation is about organizing code by grouping related data fields and the methods that manipulate them. Consider this foundational example: <pre><code>public class BankAccount {\n    private double balance;\n    private String accountNumber;\n\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n        }\n    }\n\n    public void withdraw(double amount) {\n        if (amount &gt; 0 &amp;&amp; amount &lt;= balance) {\n            balance -= amount;\n        }\n    }\n}\n</code></pre> In this example, the  <code>balance</code>  and  <code>accountNumber</code>  fields are bundled with methods that operate on them, creating a cohesive unit that represents a bank account's functionality.</p>"},{"location":"1.Fundamentals/e_java/#access-control","title":"Access Control","text":"<p>Encapsulation provides mechanisms for controlling access to class members through access modifiers:</p> <ul> <li><code>private</code>: Accessible only within the declaring class</li> <li><code>protected</code>: Accessible within the package and by subclasses</li> <li><code>public</code>: Accessible from any class</li> <li>Default (no modifier): Accessible only within the package</li> </ul>"},{"location":"1.Fundamentals/e_java/#data-hiding-vs-encapsulation","title":"Data Hiding vs. Encapsulation","text":"<p>While encapsulation enables data hiding, they are distinct concepts:</p> <ol> <li>Encapsulation is about bundling related elements and providing controlled access to them</li> <li>Data hiding is specifically about restricting direct access to class fields</li> </ol>"},{"location":"1.Fundamentals/e_java/#implementing-effective-encapsulation","title":"Implementing Effective Encapsulation","text":""},{"location":"1.Fundamentals/e_java/#the-gettersetter-pattern","title":"The Getter/Setter Pattern","text":"<p><pre><code>public class Employee {\n    private String name;\n    private int age;\n    private double salary;\n\n    // Getter methods\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    // Setter methods with validation\n    public void setName(String name) {\n        if (name != null &amp;&amp; !name.trim().isEmpty()) {\n            this.name = name;\n        }\n    }\n\n    public void setAge(int age) {\n        if (age &gt;= 18 &amp;&amp; age &lt;= 65) {\n            this.age = age;\n        } else {\n            throw new IllegalArgumentException(\"Age must be between 18 and 65\");\n        }\n    }\n}\n</code></pre> This pattern provides several benefits:</p> <ol> <li>Validation: You can enforce business rules when setting values</li> <li>Flexibility: Implementation details can change without affecting client code</li> <li>Read/Write Control: You can make properties read-only or write-only as needed</li> </ol>"},{"location":"1.Fundamentals/e_java/#advanced-encapsulation-techniques","title":"Advanced Encapsulation Techniques","text":""},{"location":"1.Fundamentals/e_java/#immutable-classes","title":"Immutable Classes","text":"<p>Creating immutable classes is an advanced form of encapsulation: <pre><code>public final class ImmutablePerson {\n    private final String name;\n    private final int age;\n\n    public ImmutablePerson(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n    // No setter methods - class is immutable\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#builder-pattern","title":"Builder Pattern","text":"<p>For complex objects with many fields, the Builder pattern provides controlled object construction: <pre><code>public class Person {\n    private final String firstName;\n    private final String lastName;\n    private final int age;\n    private final String address;\n\n    private Person(Builder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.age = builder.age;\n        this.address = builder.address;\n    }\n\n    public static class Builder {\n        private String firstName;\n        private String lastName;\n        private int age;\n        private String address;\n\n        public Builder firstName(String firstName) {\n            this.firstName = firstName;\n            return this;\n        }\n\n        // Additional builder methods...\n\n        public Person build() {\n            return new Person(this);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices_6","title":"Best Practices","text":"<ol> <li>Always make instance variables private unless there's a compelling reason not to</li> <li>Provide public getter/setter methods only when necessary</li> <li>Include validation logic in setter methods to maintain object state integrity</li> <li>Consider using immutable classes for objects that shouldn't change after creation</li> <li>Use builder patterns for complex object construction</li> <li>Document public methods thoroughly to guide proper usage</li> </ol>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ol> <li>Exposing Mutable Objects: When returning mutable objects, return defensive copies <pre><code>public class CustomerData {\n    private List&lt;String&gt; transactions;\n\n    // Wrong\n    public List&lt;String&gt; getTransactions() {\n        return transactions;\n    }\n\n    // Right\n    public List&lt;String&gt; getTransactions() {\n        return new ArrayList&lt;&gt;(transactions);\n    }\n}\n</code></pre></li> <li>Over-encapsulation: Don't create getters and setters for every field automatically</li> <li>Breaking Encapsulation: Avoid exposing internal implementation details through method signatures</li> </ol>"},{"location":"1.Fundamentals/e_java/#conclusion_2","title":"Conclusion","text":"<p>Effective encapsulation is crucial for creating maintainable and robust Java applications. By properly bundling related elements and controlling access to them, we create code that is easier to understand, maintain, and modify. Remember that encapsulation is not just about hiding data\u2014it's about creating well-organized, modular code that can evolve with changing requirements while maintaining its integrity.</p>"},{"location":"1.Fundamentals/e_java/#understanding-association-in-java-a-deep-dive","title":"Understanding Association in Java: A Deep Dive","text":""},{"location":"1.Fundamentals/e_java/#introduction_11","title":"Introduction","text":"<p>Association in Java represents one of the fundamental ways objects can relate to each other. Think of it as defining relationships between classes, much like how we define relationships in the real world. When we say a car has an engine, or a university has students, we're describing associations.</p>"},{"location":"1.Fundamentals/e_java/#core-concepts_1","title":"Core Concepts","text":"<p>Association defines how objects communicate and interact with each other. Unlike inheritance, which creates an \"is-a\" relationship, association creates a \"has-a\" relationship between objects. These relationships can exist in different forms, each serving specific design needs.</p> <p>Let's explore an example that illustrates a basic association: <pre><code>public class Student {\n    private String name;\n    private int studentId;\n\n    public Student(String name, int studentId) {\n        this.name = name;\n        this.studentId = studentId;\n    }\n\n    // Getters and setters\n}\n\npublic class Course {\n    private String courseName;\n    private List&lt;Student&gt; enrolledStudents;\n\n    public Course(String courseName) {\n        this.courseName = courseName;\n        this.enrolledStudents = new ArrayList&lt;&gt;();\n    }\n\n    public void enrollStudent(Student student) {\n        enrolledStudents.add(student);\n    }\n}\n</code></pre> In this example, the Course class has an association with the Student class through the  <code>enrolledStudents</code>  list. This demonstrates how objects of different classes can be connected while remaining independent entities.</p>"},{"location":"1.Fundamentals/e_java/#types-of-association","title":"Types of Association","text":""},{"location":"1.Fundamentals/e_java/#1-one-to-one-association","title":"1. One-to-One Association","text":"<p>One-to-one association occurs when an object of one class is associated with exactly one object of another class. Consider this real-world example: <pre><code>public class Person {\n    private String name;\n    private Passport passport;  // One-to-one association\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    public void setPassport(Passport passport) {\n        this.passport = passport;\n    }\n}\n\npublic class Passport {\n    private String passportNumber;\n    private Person owner;  // One-to-one association\n\n    public Passport(String passportNumber, Person owner) {\n        this.passportNumber = passportNumber;\n        this.owner = owner;\n    }\n}\n</code></pre> Here, each Person has exactly one Passport, and each Passport belongs to exactly one Person. </p>"},{"location":"1.Fundamentals/e_java/#2-one-to-many-association","title":"2. One-to-Many Association","text":"<p>One-to-many association occurs when one object is associated with multiple objects of another class. Let's look at a practical example: <pre><code>public class Department {\n    private String name;\n    private List&lt;Employee&gt; employees;  // One-to-many association\n\n    public Department(String name) {\n        this.name = name;\n        this.employees = new ArrayList&lt;&gt;();\n    }\n\n    public void addEmployee(Employee employee) {\n        employees.add(employee);\n    }\n\n    public List&lt;Employee&gt; getEmployees() {\n        return new ArrayList&lt;&gt;(employees);  // Return a copy to maintain encapsulation\n    }\n}\n\npublic class Employee {\n    private String name;\n    private Department department;  // Many-to-one association\n\n    public Employee(String name, Department department) {\n        this.name = name;\n        this.department = department;\n    }\n}\n</code></pre> </p>"},{"location":"1.Fundamentals/e_java/#3-many-to-many-association","title":"3. Many-to-Many Association","text":"<p>Many-to-many association occurs when multiple objects of one class are associated with multiple objects of another class. Here's an example: <pre><code>public class Student {\n    private String name;\n    private Set&lt;Course&gt; courses;  // Many-to-many association\n\n    public Student(String name) {\n        this.name = name;\n        this.courses = new HashSet&lt;&gt;();\n    }\n\n    public void enrollInCourse(Course course) {\n        courses.add(course);\n        course.addStudent(this);\n    }\n}\n\npublic class Course {\n    private String courseName;\n    private Set&lt;Student&gt; students;  // Many-to-many association\n\n    public Course(String courseName) {\n        this.courseName = courseName;\n        this.students = new HashSet&lt;&gt;();\n    }\n\n    public void addStudent(Student student) {\n        students.add(student);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#association-vs-aggregation-vs-composition","title":"Association vs Aggregation vs Composition","text":"<p>It's important to understand how association differs from related concepts:</p> <ol> <li>Association  is the most general relationship between objects. Objects are independent and have their own lifecycle.</li> <li>Aggregation  is a specialized form of association where objects have a \"whole-part\" relationship, but parts can exist independently: <pre><code>public class University {\n    private List&lt;Department&gt; departments;  // Aggregation\n\n    public void addDepartment(Department department) {\n        departments.add(department);\n    }\n}\n</code></pre></li> <li>Composition is a stronger form of aggregation where the lifecycle of the part depends on the whole: <pre><code>public class Car {\n    private final Engine engine;  // Composition\n\n    public Car() {\n        engine = new Engine();  // Engine is created with Car\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#best-practices_7","title":"Best Practices","text":"<p>When implementing associations in Java, consider these best practices:</p> <ol> <li>Use appropriate collection types based on your needs:<ul> <li><code>List</code>  when order matters or duplicates are allowed</li> <li><code>Set</code>  when uniqueness is required</li> <li><code>Map</code>  when key-value associations are needed</li> </ul> </li> <li>Maintain encapsulation by:<ul> <li>Making fields private</li> <li>Returning copies of collections rather than references</li> <li>Using immutable collections when appropriate</li> </ul> </li> <li>Consider bidirectional associations carefully:<ul> <li>Implement both sides of the relationship consistently</li> <li>Maintain referential integrity</li> <li>Be aware of potential circular references in toString() methods</li> </ul> </li> <li>Use appropriate access modifiers to control visibility and maintain encapsulation</li> </ol>"},{"location":"1.Fundamentals/e_java/#practical-implementation-tips","title":"Practical Implementation Tips","text":"<p>Here's a complete example showing how to implement a robust association: <pre><code>public class School {\n    private final String name;\n    private final Map&lt;Integer, Teacher&gt; teachers;\n    private final Map&lt;Integer, Student&gt; students;\n\n    public School(String name) {\n        this.name = name;\n        this.teachers = new HashMap&lt;&gt;();\n        this.students = new HashMap&lt;&gt;();\n    }\n\n    public void addTeacher(Teacher teacher) {\n        teachers.put(teacher.getId(), teacher);\n    }\n\n    public void addStudent(Student student) {\n        students.put(student.getId(), student);\n    }\n\n    // Return immutable views of collections\n    public Collection&lt;Teacher&gt; getTeachers() {\n        return Collections.unmodifiableCollection(teachers.values());\n    }\n\n    public Collection&lt;Student&gt; getStudents() {\n        return Collections.unmodifiableCollection(students.values());\n    }\n}\n</code></pre> This implementation demonstrates several important principles:</p> <ul> <li>Immutable references to collections</li> <li>Proper encapsulation</li> <li>Clear and consistent API design</li> <li>Type safety</li> <li>Efficient lookup using maps</li> </ul>"},{"location":"1.Fundamentals/e_java/#conclusion_3","title":"Conclusion","text":"<p>Association in Java provides a powerful way to model relationships between objects. Understanding the different types of associations and when to use each one is crucial for designing maintainable and scalable applications. Remember that the choice between association, aggregation, and composition should be based on the specific requirements of your system and the real-world relationships you're modeling.</p>"},{"location":"1.Fundamentals/e_java/#understanding-aggregation-in-java-from-basics-to-best-practices","title":"Understanding Aggregation in Java: From Basics to Best Practices","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-aggregation","title":"Introduction to Aggregation","text":"<p>Aggregation represents one of the fundamental ways objects can relate to each other in object-oriented programming. Think of aggregation as a \"has-a\" relationship, where one class contains a reference to another class, but both classes can exist independently. This concept is crucial for building modular, maintainable code.</p> <p>To understand aggregation, consider a real-world analogy: A university has departments, and departments have professors. While these entities are related, they can exist independently. A professor could work at a different university, and departments could function with different professors.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-fundamentals","title":"Understanding the Fundamentals","text":"<p>Let's start with a simple example to illustrate the basic concept: <pre><code>public class Engine {\n    private String type;\n    private int horsepower;\n\n    public Engine(String type, int horsepower) {\n        this.type = type;\n        this.horsepower = horsepower;\n    }\n\n    public void start() {\n        System.out.println(\"Engine starting: \" + type);\n    }\n}\n\npublic class Car {\n    private String model;\n    private Engine engine;    // This is aggregation\n\n    public Car(String model, Engine engine) {\n        this.model = model;\n        this.engine = engine;\n    }\n\n    public void startCar() {\n        engine.start();    // Using the aggregated object\n    }\n}\n</code></pre> In this example, the Car class has-a Engine. Notice several important characteristics:</p> <ol> <li>The Engine can exist without the Car</li> <li>The same Engine could potentially be used in different Cars</li> <li>The Car class uses the Engine's functionality but doesn't control its lifecycle</li> </ol>"},{"location":"1.Fundamentals/e_java/#the-difference-between-aggregation-and-composition","title":"The Difference Between Aggregation and Composition","text":"<p>To truly understand aggregation, it's helpful to contrast it with composition. While both are \"has-a\" relationships, they differ in object lifecycle management: <pre><code>// Aggregation Example\npublic class University {\n    private List&lt;Department&gt; departments;    // Departments can exist without the university\n\n    public University() {\n        this.departments = new ArrayList&lt;&gt;();\n    }\n\n    public void addDepartment(Department department) {\n        departments.add(department);\n    }\n}\n\n// Composition Example\npublic class House {\n    private final Room[] rooms;    // Rooms cannot exist without the house\n\n    public House(int numberOfRooms) {\n        this.rooms = new Room[numberOfRooms];\n        for (int i = 0; i &lt; numberOfRooms; i++) {\n            this.rooms[i] = new Room();    // Rooms are created with the house\n        }\n    }\n}\n</code></pre> The key distinction is that in aggregation, the contained object (Department) can exist independently of the container (University). In composition, the contained object (Room) cannot exist without its container (House).</p>"},{"location":"1.Fundamentals/e_java/#practical-implementation-patterns","title":"Practical Implementation Patterns","text":"<p>Let's explore a more complex example that demonstrates how aggregation can be used effectively in a real-world scenario: <pre><code>public class Course {\n    private String courseId;\n    private String name;\n\n    public Course(String courseId, String name) {\n        this.courseId = courseId;\n        this.name = name;\n    }\n\n    // Getters and necessary methods\n}\n\npublic class Professor {\n    private String name;\n    private String specialization;\n    private List&lt;Course&gt; coursesTaught;    // Aggregation\n\n    public Professor(String name, String specialization) {\n        this.name = name;\n        this.specialization = specialization;\n        this.coursesTaught = new ArrayList&lt;&gt;();\n    }\n\n    public void assignCourse(Course course) {\n        // Notice how we can add or remove courses without affecting their existence\n        coursesTaught.add(course);\n    }\n\n    public void removeCourse(Course course) {\n        coursesTaught.remove(course);\n        // The course continues to exist even after removal\n    }\n\n    public List&lt;Course&gt; getCoursesTaught() {\n        // Return a defensive copy to maintain encapsulation\n        return new ArrayList&lt;&gt;(coursesTaught);\n    }\n}\n</code></pre> This implementation demonstrates several important principles:</p> <ol> <li>Independent Lifecycle Management: Courses exist independently of Professors</li> <li>Flexible Relationships: Courses can be assigned and removed dynamically</li> <li>Encapsulation: The internal list is protected through defensive copying</li> </ol>"},{"location":"1.Fundamentals/e_java/#best-practices-for-using-aggregation","title":"Best Practices for Using Aggregation","text":"<p>When implementing aggregation in your code, consider these guidelines: <pre><code>public class Department {\n    private String name;\n    private List&lt;Employee&gt; employees;    // Aggregation relationship\n\n    public Department(String name) {\n        this.name = name;\n        this.employees = new ArrayList&lt;&gt;();\n    }\n\n    // GOOD: Defensive copying in getter\n    public List&lt;Employee&gt; getEmployees() {\n        return new ArrayList&lt;&gt;(employees);\n    }\n\n    // GOOD: Clear method names that express intent\n    public void addEmployee(Employee employee) {\n        if (employee == null) {\n            throw new IllegalArgumentException(\"Employee cannot be null\");\n        }\n        employees.add(employee);\n    }\n\n    // GOOD: Proper validation and error handling\n    public boolean removeEmployee(Employee employee) {\n        return employees.remove(employee);\n    }\n\n    // GOOD: Clear method to check state\n    public boolean hasEmployee(Employee employee) {\n        return employees.contains(employee);\n    }\n}\n</code></pre> Key practices demonstrated above:</p> <ol> <li>Protect internal collections through defensive copying</li> <li>Validate input parameters</li> <li>Provide clear, intention-revealing method names</li> <li>Implement proper error handling</li> <li>Include methods for state verification</li> </ol>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-to-avoid_1","title":"Common Pitfalls to Avoid","text":"<p>Here are some situations to watch out for when implementing aggregation: <pre><code>public class Library {\n    // BAD: Exposing internal collection directly\n    public List&lt;Book&gt; books;    // Don't do this\n\n    // BAD: Returning internal collection reference\n    public List&lt;Book&gt; getBooks() {\n        return books;    // Don't do this\n    }\n\n    // BAD: Not handling null values\n    public void addBook(Book book) {\n        books.add(book);    // Don't do this\n    }\n\n    // GOOD: Proper implementation\n    private final List&lt;Book&gt; books = new ArrayList&lt;&gt;();\n\n    public List&lt;Book&gt; getBooks() {\n        return new ArrayList&lt;&gt;(books);\n    }\n\n    public void addBook(Book book) {\n        if (book == null) {\n            throw new IllegalArgumentException(\"Book cannot be null\");\n        }\n        books.add(book);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-aggregation-patterns","title":"Advanced Aggregation Patterns","text":"<p>For more complex scenarios, consider these advanced patterns: <pre><code>public class Organization {\n    private final Map&lt;String, Department&gt; departments = new HashMap&lt;&gt;();\n    private final ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    public void addDepartment(Department dept) {\n        lock.writeLock().lock();\n        try {\n            departments.put(dept.getName(), dept);\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    public Optional&lt;Department&gt; getDepartment(String name) {\n        lock.readLock().lock();\n        try {\n            return Optional.ofNullable(departments.get(name));\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n}\n</code></pre> This advanced implementation shows:</p> <ol> <li>Thread-safe aggregation using read-write locks</li> <li>Use of Optional for null-safety</li> <li>Immutable collection initialization</li> <li>Proper resource management</li> </ol>"},{"location":"1.Fundamentals/e_java/#conclusion_4","title":"Conclusion","text":"<p>Aggregation is a powerful tool in object-oriented design that allows us to create flexible, maintainable relationships between objects. By understanding when to use aggregation versus composition, and by following best practices in implementation, we can create more robust and maintainable code. Remember that the key characteristic of aggregation is the independent lifecycle of the related objects, and design your classes accordingly.</p>"},{"location":"1.Fundamentals/e_java/#understanding-composition-in-java-a-deep-dive","title":"Understanding Composition in Java: A Deep Dive","text":""},{"location":"1.Fundamentals/e_java/#introduction_12","title":"Introduction","text":"<p>Composition is one of the fundamental ways to create relationships between classes in object-oriented programming. Think of composition as building something complex by combining simpler parts, much like how a car is composed of an engine, wheels, and other components. When we use composition, we're saying that one object is made up of other objects, and these component objects are an essential part of the whole.</p>"},{"location":"1.Fundamentals/e_java/#the-nature-of-composition","title":"The Nature of Composition","text":"<p>Unlike inheritance, which creates an \"is-a\" relationship, composition creates a \"contains-a\" or \"has-a\" relationship where the lifecycle of the contained objects is tied to the lifecycle of the container. Let's understand this through a real-world analogy:</p> <p>Think of a house and its rooms. The rooms can't exist without the house - if you demolish the house, the rooms cease to exist too. This is exactly how composition works in Java - when the parent object is destroyed, its composed objects are destroyed as well.</p> <p>Let's see this concept in code: <pre><code>public class Room {\n    private String name;\n    private double area;\n\n    public Room(String name, double area) {\n        this.name = name;\n        this.area = area;\n    }\n}\n\npublic class House {\n    // These rooms are composed into the house - they cannot exist without it\n    private final Room livingRoom;\n    private final Room kitchen;\n    private final Room bedroom;\n\n    public House() {\n        // Rooms are created when the house is created\n        this.livingRoom = new Room(\"Living Room\", 20.0);\n        this.kitchen = new Room(\"Kitchen\", 15.0);\n        this.bedroom = new Room(\"Bedroom\", 12.0);\n    }\n\n    // When House object is garbage collected, the Room objects will be too\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-strong-life-cycle-coupling","title":"Understanding Strong Life-Cycle Coupling","text":"<p>The key characteristic that distinguishes composition from weaker relationships like aggregation is the strong lifecycle coupling between objects. Let's explore this with a more detailed example: <pre><code>public class Engine {\n    private final String type;\n    private boolean running;\n\n    public Engine(String type) {\n        this.type = type;\n        this.running = false;\n    }\n\n    public void start() {\n        running = true;\n    }\n\n    public void stop() {\n        running = false;\n    }\n}\n\npublic class Car {\n    // Engine is composed into Car - it cannot exist independently\n    private final Engine engine;\n    private final String model;\n\n    public Car(String model, String engineType) {\n        this.model = model;\n        // Engine is created as part of Car construction\n        this.engine = new Engine(engineType);\n    }\n\n    public void startCar() {\n        engine.start();\n    }\n\n    public void stopCar() {\n        engine.stop();\n    }\n}\n</code></pre> In this example, the Engine is an integral part of the Car. You don't create an Engine separately and pass it to the Car - instead, the Car creates and manages its own Engine instance. This is composition in action.</p>"},{"location":"1.Fundamentals/e_java/#practical-implementation-patterns_1","title":"Practical Implementation Patterns","text":"<p>Let's explore some common patterns for implementing composition effectively:</p>"},{"location":"1.Fundamentals/e_java/#1-immutable-composition","title":"1. Immutable Composition","text":"<p>When using composition, it's often beneficial to make the relationship immutable: <pre><code>public class Document {\n    private final Header header;\n    private final Body body;\n    private final Footer footer;\n\n    public Document(String title, String content, String footerText) {\n        this.header = new Header(title);\n        this.body = new Body(content);\n        this.footer = new Footer(footerText);\n    }\n\n    // Provide methods to access the composed objects, but never expose them directly\n    public String getTitle() {\n        return header.getTitle();\n    }\n\n    public String getContent() {\n        return body.getContent();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-collection-based-composition","title":"2. Collection-Based Composition","text":"<p>Sometimes we need to compose multiple objects of the same type: <pre><code>public class Library {\n    private final List&lt;Book&gt; books;\n\n    public Library() {\n        // Initialize the composed collection\n        this.books = new ArrayList&lt;&gt;();\n    }\n\n    public void addBook(String title, String author) {\n        // Create and manage Book objects internally\n        books.add(new Book(title, author));\n    }\n\n    public List&lt;String&gt; getBookTitles() {\n        // Return only the necessary information, not the objects themselves\n        return books.stream()\n                   .map(Book::getTitle)\n                   .collect(Collectors.toList());\n    }\n\n    // Books are managed entirely within the Library\n    private static class Book {\n        private final String title;\n        private final String author;\n\n        Book(String title, String author) {\n            this.title = title;\n            this.author = author;\n        }\n\n        String getTitle() {\n            return title;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-composition","title":"Best Practices for Composition","text":"<p>Let's examine some key practices that make composition more effective:</p>"},{"location":"1.Fundamentals/e_java/#1-encapsulation-of-composed-objects","title":"1. Encapsulation of Composed Objects","text":"<p>Always protect your composed objects: <pre><code>public class Computer {\n    private final CPU cpu;\n    private final Memory memory;\n    private final Storage storage;\n\n    public Computer(String cpuModel, int memorySize, int storageSize) {\n        this.cpu = new CPU(cpuModel);\n        this.memory = new Memory(memorySize);\n        this.storage = new Storage(storageSize);\n    }\n\n    // Instead of exposing objects, provide specific functionality\n    public void processTask(String task) {\n        cpu.execute(task);\n        memory.allocate(task);\n        storage.store(task);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-initialization-safety","title":"2. Initialization Safety","text":"<p>Ensure composed objects are properly initialized: <pre><code>public class EmailService {\n    private final EmailValidator validator;\n    private final EmailSender sender;\n    private final EmailLogger logger;\n\n    public EmailService() {\n        // Initialize all composed objects in a specific order\n        this.validator = new EmailValidator();\n        this.sender = new EmailSender();\n        this.logger = new EmailLogger();\n\n        // Verify initialization\n        validateComponents();\n    }\n\n    private void validateComponents() {\n        Objects.requireNonNull(validator, \"Email validator must be initialized\");\n        Objects.requireNonNull(sender, \"Email sender must be initialized\");\n        Objects.requireNonNull(logger, \"Email logger must be initialized\");\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#composition-vs-inheritance","title":"Composition vs. Inheritance","text":"<p>Understanding when to use composition instead of inheritance is crucial: <pre><code>// Instead of inheritance:\npublic class SpecialArrayList extends ArrayList&lt;String&gt; {\n    // This creates tight coupling and might break encapsulation\n}\n\n// Prefer composition:\npublic class UniqueList {\n    private final List&lt;String&gt; items;\n\n    public UniqueList() {\n        this.items = new ArrayList&lt;&gt;();\n    }\n\n    public void addItem(String item) {\n        if (!items.contains(item)) {\n            items.add(item);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conclusion_5","title":"Conclusion","text":"<p>Composition is a powerful tool in object-oriented design that allows us to build complex objects from simpler ones while maintaining strong encapsulation and proper lifecycle management. By following the principles and patterns outlined in this guide, you can create more maintainable and flexible code that better represents real-world relationships between objects.</p> <p>Remember that composition is often preferable to inheritance because it:</p> <ul> <li>Provides better encapsulation</li> <li>Allows for more flexible designs</li> <li>Makes it easier to modify implementations</li> <li>Results in more maintainable code</li> <li>Better represents many real-world relationships between objects</li> </ul> <p>When designing your classes, consider whether the relationship you're modeling truly represents a whole-part relationship where the lifecycle of the components is tied to the lifecycle of the container. If so, composition is likely the right choice.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-packages-in-java-from-fundamentals-to-advanced-concepts","title":"Understanding Java Packages in Java: From Fundamentals to Advanced Concepts","text":""},{"location":"1.Fundamentals/e_java/#introduction-why-packages-matter","title":"Introduction: Why Packages Matter","text":"<p>Imagine you're organizing a large library. Without any organization system, finding a specific book would be nearly impossible. Just as libraries use classification systems to organize books, Java uses packages to organize classes and interfaces. Let's explore how this organizational system works and why it's crucial for building maintainable applications.</p>"},{"location":"1.Fundamentals/e_java/#the-fundamentals-of-java-packages","title":"The Fundamentals of Java Packages","text":"<p>A package in Java is more than just a folder for your classes - it's a namespace that organizes a set of related classes, interfaces, and sub-packages. Think of it like a family tree for your code.</p> <p>Let's start with a simple example: <pre><code>// File: Employee.java\npackage com.company.hr;\n\npublic class Employee {\n    private String name;\n    private String department;\n\n    public Employee(String name, String department) {\n        this.name = name;\n        this.department = department;\n    }\n\n    // Methods for employee management\n}\n</code></pre> In this example, we've placed our  <code>Employee</code>  class in the  <code>com.company.hr</code>  package. This tells other developers that this class is related to HR functionality and belongs to our company's codebase.</p>"},{"location":"1.Fundamentals/e_java/#package-naming-conventions","title":"Package Naming Conventions","text":"<p>Package names follow a hierarchical naming pattern, typically starting with your organization's reversed domain name. Let's understand why: <pre><code>// Standard package naming convention\npackage com.companydomain.project.module;\n\n// Examples for different types of applications:\npackage com.amazon.shopping.cart;     // For an Amazon shopping module\npackage org.apache.commons.lang3;     // For Apache Commons library\npackage edu.stanford.cs.graphics;     // For Stanford CS department code\n</code></pre> This convention helps ensure unique package names across different organizations and projects.</p>"},{"location":"1.Fundamentals/e_java/#accessing-classes-from-packages","title":"Accessing Classes from Packages","text":"<p>There are three main ways to use classes from other packages. Let's examine each approach:</p>"},{"location":"1.Fundamentals/e_java/#1-using-fully-qualified-names","title":"1. Using Fully Qualified Names","text":"<pre><code>public class PayrollSystem {\n    public void processPayroll() {\n        // Using fully qualified name\n        com.company.hr.Employee employee = new com.company.hr.Employee(\"John Doe\", \"Engineering\");\n\n        // Process payroll logic\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-using-single-type-import","title":"2. Using Single-Type Import","text":"<pre><code>// Import a specific class\nimport com.company.hr.Employee;\n\npublic class PayrollSystem {\n    public void processPayroll() {\n        // Can use Employee directly\n        Employee employee = new Employee(\"John Doe\", \"Engineering\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-using-wildcard-import","title":"3. Using Wildcard Import","text":"<pre><code>// Import all classes from the package\nimport com.company.hr.*;\n\npublic class PayrollSystem {\n    public void processPayroll() {\n        Employee employee = new Employee(\"John Doe\", \"Engineering\");\n        Department dept = new Department(\"Engineering\");\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#package-organization-best-practices","title":"Package Organization Best Practices","text":"<p>Let's explore how to structure packages effectively: <pre><code>// Root package\npackage com.company.projectname;\n\n// Feature-based sub-packages\npackage com.company.projectname.user;\npackage com.company.projectname.order;\npackage com.company.projectname.payment;\n\n// Layer-based sub-packages within features\npackage com.company.projectname.user.controller;\npackage com.company.projectname.user.service;\npackage com.company.projectname.user.repository;\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#example-of-a-well-structured-package","title":"Example of a Well-Structured Package","text":"<pre><code>// File structure:\ncom/\n  company/\n    projectname/\n      user/\n        controller/\n          UserController.java\n        service/\n          UserService.java\n        model/\n          User.java\n        repository/\n          UserRepository.java\n</code></pre>"},{"location":"1.Fundamentals/e_java/#working-with-package-access-levels","title":"Working with Package Access Levels","text":"<p>Java packages play a crucial role in access control. Let's understand the different access levels: <pre><code>package com.company.hr;\n\nclass Department {  // Package-private class\n    private String name;\n    protected int employeeCount;  // Accessible to subclasses\n    public String getLocation() { return \"HQ\"; }  // Accessible to all\n\n    void updateEmployeeCount() {  // Package-private method\n        // Only accessible within the same package\n        employeeCount++;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-package-concepts","title":"Advanced Package Concepts","text":""},{"location":"1.Fundamentals/e_java/#1-static-imports","title":"1. Static Imports","text":"<p>Static imports can make your code cleaner when using static members: <pre><code>// Without static import\nimport java.lang.Math;\ndouble result = Math.sqrt(25);\n\n// With static import\nimport static java.lang.Math.sqrt;\ndouble result = sqrt(25);  // Cleaner syntax\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-package-info-files","title":"2. Package-Info Files","text":"<p>Package-level documentation and annotations can be added using package-info.java: <pre><code>/**\n * This package contains core HR functionality.\n * \n * @author Company Name\n * @version 1.0\n */\n@PackageAnnotation\npackage com.company.hr;\n\nimport com.company.annotations.PackageAnnotation;\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-package-management","title":"Best Practices for Package Management","text":"<ol> <li>Logical Organization: Group related classes together: <pre><code>// Good organization\npackage com.company.hr.employees;      // Employee-related classes\npackage com.company.hr.payroll;        // Payroll-related classes\npackage com.company.hr.benefits;       // Benefits-related classes\n</code></pre></li> <li>Package by Feature: Organize packages by business features rather than technical layers: <pre><code>// Instead of this (organized by layer):\ncom.company.controllers\ncom.company.services\ncom.company.repositories\n\n// Do this (organized by feature):\ncom.company.user\ncom.company.product\ncom.company.order\n</code></pre></li> <li>Avoid Cyclic Dependencies: Ensure packages don't depend on each other in a circular manner: <pre><code>// Bad - cyclic dependency\npackage com.company.a;\nclass ClassA {\n    com.company.b.ClassB b;  // Depends on package b\n}\n\npackage com.company.b;\nclass ClassB {\n    com.company.a.ClassA a;  // Depends on package a\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#practical-package-usage-examples","title":"Practical Package Usage Examples","text":""},{"location":"1.Fundamentals/e_java/#creating-a-library-management-system","title":"Creating a Library Management System","text":"<pre><code>// Base package structure\npackage com.library.management;\n\n// Book management\npackage com.library.management.book;\npublic class Book {\n    private String isbn;\n    private String title;\n\n    public Book(String isbn, String title) {\n        this.isbn = isbn;\n        this.title = title;\n    }\n}\n\n// User management\npackage com.library.management.user;\npublic class LibraryUser {\n    private String id;\n    private List&lt;Book&gt; borrowedBooks;\n\n    public void borrowBook(Book book) {\n        // Borrowing logic\n    }\n}\n\n// Transaction management\npackage com.library.management.transaction;\npublic class BorrowTransaction {\n    private LibraryUser user;\n    private Book book;\n    private LocalDateTime borrowDate;\n\n    public void processBorrow() {\n        // Transaction logic\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#conclusion_6","title":"Conclusion","text":"<p>Java packages are fundamental to creating well-organized, maintainable code. They provide:</p> <ul> <li>Logical organization of related code</li> <li>Access control mechanisms</li> <li>Name conflict resolution</li> <li>Modular code structure</li> </ul> <p>Remember these key points:</p> <ul> <li>Use meaningful package names that reflect your organization and code structure</li> <li>Follow package naming conventions</li> <li>Organize packages by feature when possible</li> <li>Use appropriate access modifiers</li> <li>Document your packages using package-info.java</li> <li>Avoid circular dependencies between packages</li> </ul> <p>By following these guidelines and understanding package concepts thoroughly, you'll be better equipped to create well-structured Java applications that are easier to maintain and scale.</p>"},{"location":"1.Fundamentals/e_java/#modern-java-file-operations-a-complete-developers-guide","title":"Modern Java File Operations: A Complete Developer's Guide","text":""},{"location":"1.Fundamentals/e_java/#understanding-the-evolution-of-java-file-apis","title":"Understanding the Evolution of Java File APIs","text":"<p>Java has provided file handling capabilities since its earliest days, but the landscape has evolved significantly. Think of it like the difference between a paper map and modern GPS navigation - while both can get you to your destination, the newer approach offers more features and reliability.</p> <p>The original  <code>java.io.File</code>  API, introduced in Java 1.0 (1996), served its purpose but had limitations. The newer  <code>java.nio.file.Path</code>  API, available since Java 1.7 (2011), provides a more robust and feature-rich approach to file handling. Let's explore why this matters and how to use it effectively.</p>"},{"location":"1.Fundamentals/e_java/#getting-started-with-paths","title":"Getting Started with Paths","text":"<p>Before we can work with files, we need to understand how to reference them. In modern Java, this means working with the  <code>Path</code>  interface. Let's explore the various ways to create paths: <pre><code>// The modern way (Java 11+)\nPath filePath = Path.of(\"data/config.json\");\n\n// For Java 7-10 compatibility\nPath legacyPath = Paths.get(\"data/config.json\");\n\n// Working with multiple path segments\nPath segmentedPath = Path.of(\"data\", \"user\", \"settings.json\");\n\n// Creating paths from URIs\nPath uriPath = Path.of(new URI(\"file:///C:/data/config.json\"));\n\n// Using parent paths with child resolution\nPath parentPath = Path.of(\"data\");\nPath childPath = parentPath.resolve(\"config.json\");\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-path-types","title":"Understanding Path Types","text":"<p>Think of paths like giving directions - you can give absolute directions from a known starting point, or relative directions from your current location. Java supports both approaches: <pre><code>// Absolute path - like giving coordinates\nPath absolutePath = Path.of(\"C:/projects/myapp/data/config.json\");\n\n// Relative path - like saying \"from here, go to the data folder\"\nPath relativePath = Path.of(\"./data/config.json\");\n\n// Converting between them\nPath convertedToAbsolute = relativePath.toAbsolutePath();\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#reading-and-writing-files","title":"Reading and Writing Files","text":"<p>Modern Java provides several elegant ways to read and write files. Let's explore them:</p>"},{"location":"1.Fundamentals/e_java/#reading-files","title":"Reading Files","text":"<pre><code>// Reading an entire file as a string (Java 11+)\nPath filePath = Path.of(\"data.txt\");\nString content = Files.readString(filePath, StandardCharsets.UTF_8);\n\n// Reading lines into a stream\ntry (Stream&lt;String&gt; lines = Files.lines(filePath, StandardCharsets.UTF_8)) {\n    lines.forEach(line -&gt; {\n        // Process each line\n        System.out.println(\"Processing: \" + line);\n    });\n}\n\n// Using a BufferedReader for more control\ntry (BufferedReader reader = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        // Process each line with more control\n        if (line.startsWith(\"IMPORTANT:\")) {\n            // Special handling for important lines\n            processImportantLine(line);\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#writing-files","title":"Writing Files","text":"<pre><code>// Writing a string to a file (Java 11+)\nPath outputPath = Path.of(\"output.txt\");\nString data = \"Hello, World!\";\nFiles.writeString(outputPath, data, StandardCharsets.UTF_8);\n\n// Writing multiple lines\nList&lt;String&gt; lines = Arrays.asList(\"Line 1\", \"Line 2\", \"Line 3\");\nFiles.write(outputPath, lines, StandardCharsets.UTF_8,\n    StandardOpenOption.CREATE,\n    StandardOpenOption.TRUNCATE_EXISTING);\n\n// Using a BufferedWriter for more control\ntry (BufferedWriter writer = Files.newBufferedWriter(outputPath, StandardCharsets.UTF_8)) {\n    writer.write(\"First line\");\n    writer.newLine();\n    writer.write(\"Second line\");\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#working-with-directories","title":"Working with Directories","text":"<p>Directories require special handling. Here's how to work with them effectively: <pre><code>// Creating directories\nPath dirPath = Path.of(\"data/user/documents\");\nFiles.createDirectories(dirPath);  // Creates parent directories if needed\n\n// Listing directory contents\ntry (Stream&lt;Path&gt; entries = Files.list(dirPath)) {\n    entries.forEach(entry -&gt; {\n        // Process each entry\n        System.out.println(\"Found: \" + entry.getFileName());\n    });\n}\n\n// Walking a directory tree recursively\ntry (Stream&lt;Path&gt; entries = Files.walk(dirPath)) {\n    entries\n        .filter(Files::isRegularFile)\n        .filter(p -&gt; p.toString().endsWith(\".txt\"))\n        .forEach(System.out::println);\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#file-operations-and-attributes","title":"File Operations and Attributes","text":"<p>Modern Java provides rich capabilities for file operations and attribute handling: <pre><code>// Copying files with options\nPath source = Path.of(\"source.txt\");\nPath target = Path.of(\"target.txt\");\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n// Moving/Renaming files\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n\n// Checking file attributes\nboolean exists = Files.exists(source);\nboolean isReadable = Files.isReadable(source);\nboolean isDirectory = Files.isDirectory(source);\n\n// Getting detailed file attributes\nBasicFileAttributes attrs = Files.readAttributes(source, BasicFileAttributes.class);\nSystem.out.println(\"Creation time: \" + attrs.creationTime());\nSystem.out.println(\"Last modified: \" + attrs.lastModifiedTime());\nSystem.out.println(\"Size: \" + attrs.size());\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#watching-for-file-changes","title":"Watching for File Changes","text":"<p>Java provides a powerful mechanism for watching directory changes: <pre><code>// Creating a watch service\ntry (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n    Path dir = Path.of(\"watched-directory\");\n\n    // Register for different types of events\n    dir.register(watcher,\n        StandardWatchEventKinds.ENTRY_CREATE,\n        StandardWatchEventKinds.ENTRY_DELETE,\n        StandardWatchEventKinds.ENTRY_MODIFY);\n\n    while (true) {\n        WatchKey key = watcher.take();  // Blocks until events are available\n\n        for (WatchEvent&lt;?&gt; event : key.pollEvents()) {\n            WatchEvent.Kind&lt;?&gt; kind = event.kind();\n\n            // Handle overflow events\n            if (kind == StandardWatchEventKinds.OVERFLOW) {\n                continue;\n            }\n\n            @SuppressWarnings(\"unchecked\")\n            WatchEvent&lt;Path&gt; ev = (WatchEvent&lt;Path&gt;) event;\n            Path filename = ev.context();\n\n            // Process the event\n            System.out.println(kind + \": \" + filename);\n        }\n\n        // Reset the key - required to receive further events\n        boolean valid = key.reset();\n        if (!valid) {\n            break;\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#in-memory-file-systems","title":"In-Memory File Systems","text":"<p>For testing or special use cases, Java supports in-memory file systems. Here's how to use them: <pre><code>// Using JimFS (Google's in-memory file system)\ntry (FileSystem fs = Jimfs.newFileSystem(Configuration.unix())) {\n    Path memPath = fs.getPath(\"/test.txt\");\n    Files.writeString(memPath, \"Hello, Memory!\");\n\n    String content = Files.readString(memPath);\n    System.out.println(\"Read from memory: \" + content);\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#43-best-practices-and-common-pitfalls","title":"43 # Best Practices and Common Pitfalls","text":"<ol> <li>Always Use Explicit Character Encoding <pre><code>// Don't rely on platform default encoding\nFiles.writeString(path, content, StandardCharsets.UTF_8);\n</code></pre></li> <li>Use Try-With-Resources for Automatic Resource Cleanup <pre><code>try (InputStream in = Files.newInputStream(path)) {\n    // Resource will be automatically closed\n}\n</code></pre></li> <li>Handle File Operations in a Thread-Safe Manner <pre><code>// Use atomic operations when possible\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n</code></pre></li> <li>Properly Handle Temporary Files <pre><code>Path tempFile = Files.createTempFile(\"prefix\", \".tmp\");\ntry {\n    // Use the temporary file\n} finally {\n    Files.deleteIfExists(tempFile);\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#understanding-javas-file-class-from-basics-to-advanced-usage","title":"Understanding Java's File Class: From Basics to Advanced Usage","text":""},{"location":"1.Fundamentals/e_java/#introduction-the-foundation-of-file-operations","title":"Introduction: The Foundation of File Operations","text":"<p>Before we dive into modern file handling in Java, we need to understand the  <code>File</code>  class - a fundamental building block that has been part of Java since its earliest days. Think of the  <code>File</code>  class as a map that helps you navigate your computer's file system. It doesn't actually contain the file's contents; rather, it represents the file's location and properties, much like a street address represents a house but isn't the house itself.</p>"},{"location":"1.Fundamentals/e_java/#core-concepts_2","title":"Core Concepts","text":"<p>The  <code>File</code>  class represents an abstract pathname, which can point to either a file or a directory. Let's break this down with practical examples: <pre><code>public class FileBasics {\n    public void demonstrateFileCreation() {\n        // Creating a File object with different constructors\n        File singlePath = new File(\"/home/user/documents/report.txt\");\n\n        // Using parent and child paths\n        File parent = new File(\"/home/user/documents\");\n        File childFile = new File(parent, \"report.txt\");\n\n        // Using separate parent and child strings\n        File withParentString = new File(\"/home/user/documents\", \"report.txt\");\n\n        // Creating from URI\n        try {\n            File fromUri = new File(new URI(\"file:///home/user/documents/report.txt\"));\n        } catch (URISyntaxException e) {\n            // Handle URI formatting issues\n            System.err.println(\"Invalid URI format: \" + e.getMessage());\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-path-representations","title":"Understanding Path Representations","text":"<p>Java's File class works with both absolute and relative paths. Let's explore the difference: <pre><code>public class PathTypes {\n    public void demonstratePathTypes() {\n        // Absolute path - complete path from root\n        File absolutePath = new File(\"/home/user/documents/report.txt\");\n        System.out.println(\"Is absolute: \" + absolutePath.isAbsolute());\n\n        // Relative path - relative to current working directory\n        File relativePath = new File(\"documents/report.txt\");\n        System.out.println(\"Is absolute: \" + relativePath.isAbsolute());\n\n        // Getting absolute path from relative path\n        String fullPath = relativePath.getAbsolutePath();\n        System.out.println(\"Full path: \" + fullPath);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#file-operations","title":"File Operations","text":"<p>Let's explore common operations you can perform with the File class:</p>"},{"location":"1.Fundamentals/e_java/#basic-file-operations","title":"Basic File Operations","text":"<pre><code>public class FileOperations {\n    public void demonstrateBasicOperations() {\n        File file = new File(\"example.txt\");\n\n        try {\n            // Creating a new file\n            boolean created = file.createNewFile();\n            if (created) {\n                System.out.println(\"File created successfully\");\n            } else {\n                System.out.println(\"File already exists\");\n            }\n\n            // Checking basic properties\n            System.out.println(\"Exists: \" + file.exists());\n            System.out.println(\"Can read: \" + file.canRead());\n            System.out.println(\"Can write: \" + file.canWrite());\n            System.out.println(\"Can execute: \" + file.canExecute());\n            System.out.println(\"File size: \" + file.length() + \" bytes\");\n\n            // Getting file metadata\n            System.out.println(\"Last modified: \" + new Date(file.lastModified()));\n            System.out.println(\"Is hidden: \" + file.isHidden());\n\n        } catch (IOException e) {\n            System.err.println(\"Error handling file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#directory-operations","title":"Directory Operations","text":"<pre><code>public class DirectoryOperations {\n    public void demonstrateDirectoryOperations() {\n        File directory = new File(\"myDirectory\");\n\n        // Creating a directory\n        if (directory.mkdir()) {\n            System.out.println(\"Directory created\");\n        }\n\n        // Creating multiple nested directories\n        File nestedDirs = new File(\"parent/child/grandchild\");\n        if (nestedDirs.mkdirs()) {\n            System.out.println(\"Nested directories created\");\n        }\n\n        // Listing directory contents\n        if (directory.isDirectory()) {\n            String[] contents = directory.list();\n            System.out.println(\"Directory contents:\");\n            for (String item : contents) {\n                System.out.println(item);\n            }\n\n            // Getting detailed file information\n            File[] files = directory.listFiles();\n            for (File f : files) {\n                System.out.printf(\"Name: %s, Size: %d bytes, Directory: %b%n\",\n                    f.getName(), f.length(), f.isDirectory());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#advanced-usage","title":"Advanced Usage","text":""},{"location":"1.Fundamentals/e_java/#working-with-file-filters","title":"Working with File Filters","text":"<pre><code>public class FileFiltering {\n    public void demonstrateFileFiltering() {\n        File directory = new File(\"documents\");\n\n        // Using FilenameFilter for simple name filtering\n        FilenameFilter textFilter = (dir, name) -&gt; name.endsWith(\".txt\");\n        String[] textFiles = directory.list(textFilter);\n\n        // Using FileFilter for more complex filtering\n        FileFilter largeFileFilter = (file) -&gt; \n            file.isFile() &amp;&amp; file.length() &gt; 1024 * 1024; // Files larger than 1MB\n\n        File[] largeFiles = directory.listFiles(largeFileFilter);\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#temporary-file-creation","title":"Temporary File Creation","text":"<pre><code>public class TempFileOperations {\n    public void demonstrateTempFiles() {\n        try {\n            // Creating a temporary file\n            File tempFile = File.createTempFile(\"prefix-\", \"-suffix\");\n\n            // Making sure it's deleted when the JVM exits\n            tempFile.deleteOnExit();\n\n            // Getting the temp directory location\n            String tempDirPath = System.getProperty(\"java.io.tmpdir\");\n            System.out.println(\"Temp directory: \" + tempDirPath);\n\n        } catch (IOException e) {\n            System.err.println(\"Error creating temp file: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_5","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/e_java/#1-path-separator-handling","title":"1. Path Separator Handling","text":"<pre><code>public class PathSeparatorHandling {\n    public void demonstratePathSeparators() {\n        // Using system-independent separator\n        File portable = new File(\"documents\" + File.separator + \"reports\");\n\n        // Wrong way - hardcoding separators\n        File nonPortable = new File(\"documents\\\\reports\"); // Don't do this!\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-resource-cleanup","title":"2. Resource Cleanup","text":"<pre><code>public class ResourceHandling {\n    public void demonstrateResourceHandling() {\n        File tempFile = null;\n        try {\n            tempFile = File.createTempFile(\"temp-\", \".tmp\");\n            // Use the temp file\n        } catch (IOException e) {\n            System.err.println(\"Error creating temp file: \" + e.getMessage());\n        } finally {\n            if (tempFile != null) {\n                tempFile.delete();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-error-handling","title":"3. Error Handling","text":"<pre><code>public class RobustErrorHandling {\n    public void demonstrateErrorHandling() {\n        File file = new File(\"important.dat\");\n\n        // Check permissions before operations\n        if (!file.canWrite()) {\n            throw new SecurityException(\"No write permission for file: \" + file);\n        }\n\n        // Handle potential security issues\n        try {\n            boolean created = file.createNewFile();\n        } catch (SecurityException e) {\n            System.err.println(\"Security violation: \" + e.getMessage());\n        } catch (IOException e) {\n            System.err.println(\"IO error: \" + e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#modern-alternatives","title":"Modern Alternatives","text":"<p>While the File class is still widely used, modern Java applications often prefer the newer  <code>java.nio.file.Path</code>  API introduced in Java 7. Here's a quick comparison: <pre><code>public class ModernAlternative {\n    public void demonstrateModernApproach() {\n        // Old way with File\n        File legacyFile = new File(\"example.txt\");\n\n        // Modern way with Path\n        Path modernPath = Paths.get(\"example.txt\");\n\n        // Converting between File and Path\n        Path pathFromFile = legacyFile.toPath();\n        File fileFromPath = pathFromFile.toFile();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conclusion_7","title":"Conclusion","text":"<p>The File class remains a fundamental part of Java's file handling capabilities. While newer APIs like  <code>java.nio.file.Path</code>  offer more features, understanding the File class is crucial because:</p> <ol> <li>Many existing codebases use it extensively</li> <li>Many libraries still use it in their APIs</li> <li>It provides simple, straightforward operations for basic file handling</li> </ol> <p>Remember these key points:</p> <ul> <li>The File class represents a path, not the actual file contents</li> <li>Always use system-independent path separators</li> <li>Check file permissions before operations</li> <li>Handle errors appropriately</li> <li>Consider using the modern Path API for new code</li> </ul> <p>By understanding these concepts and following the best practices outlined above, you can write robust and maintainable file handling code in Java.</p>"},{"location":"1.Fundamentals/e_java/#understanding-javas-modern-httpclient-a-complete-guide","title":"Understanding Java's Modern HttpClient: A Complete Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction-the-evolution-of-http-in-java","title":"Introduction: The Evolution of HTTP in Java","text":"<p>Imagine you're an architect upgrading an old house for modern living. Just as you'd want to replace outdated plumbing with modern fixtures, Java needed to upgrade its HTTP capabilities for today's web. The HttpClient API, introduced in Java 11, represents this modernization of Java's HTTP capabilities.</p> <p>Before this, developers often relied on the dated  <code>HttpURLConnection</code>  or third-party libraries like Apache HttpClient. The new HttpClient brings Java's HTTP capabilities into the modern era, with support for HTTP/2, WebSocket, and asynchronous operations built right in.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-core-components","title":"Understanding the Core Components","text":"<p>The HttpClient API is built around three main classes that work together like a well-oiled machine: <pre><code>public class HttpClientExample {\n    public void demonstrateCoreConcepts() throws Exception {\n        // The client - like a configured web browser\n        HttpClient client = HttpClient.newBuilder()\n            .version(Version.HTTP_2)\n            .followRedirects(Redirect.NORMAL)\n            .connectTimeout(Duration.ofSeconds(20))\n            .build();\n\n        // The request - like filling out a form\n        HttpRequest request = HttpRequest.newBuilder()\n            .uri(new URI(\"https://api.example.com/data\"))\n            .header(\"Accept\", \"application/json\")\n            .GET()\n            .build();\n\n        // The response - like the paper you receive back\n        HttpResponse&lt;String&gt; response = client.send(\n            request, \n            HttpResponse.BodyHandlers.ofString()\n        );\n    }\n}\n</code></pre> Let's break down each component to understand its role better.</p>"},{"location":"1.Fundamentals/e_java/#the-httpclient-your-configurable-web-browser","title":"The HttpClient: Your Configurable Web Browser","text":"<p>Think of HttpClient as a configurable web browser. Just as you configure your browser with settings like proxy servers or cookie preferences, you configure the HttpClient with similar options: <pre><code>public class HttpClientConfiguration {\n    public HttpClient createConfiguredClient() {\n        // Create a robust client with common configurations\n        return HttpClient.newBuilder()\n            // Prefer HTTP/2 but fallback to HTTP/1.1 if necessary\n            .version(Version.HTTP_2)\n\n            // Handle redirects automatically - like when a page has moved\n            .followRedirects(Redirect.NORMAL)\n\n            // Don't wait forever for a response\n            .connectTimeout(Duration.ofSeconds(20))\n\n            // Use a custom executor for async operations\n            .executor(Executors.newFixedThreadPool(5))\n\n            // Configure proxy if needed\n            .proxy(ProxySelector.getDefault())\n\n            // Handle cookies\n            .cookieHandler(new CookieManager(null, CookiePolicy.ACCEPT_ALL))\n\n            .build();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#the-httprequest-crafting-your-web-request","title":"The HttpRequest: Crafting Your Web Request","text":"<p>The HttpRequest is like filling out a detailed form of what you want from the web server. Let's explore different types of requests: <pre><code>public class RequestExamples {\n    public void demonstrateRequestTypes() throws Exception {\n        // Simple GET request - like clicking a link\n        HttpRequest getRequest = HttpRequest.newBuilder()\n            .uri(new URI(\"https://api.example.com/data\"))\n            .GET()  // GET is actually the default\n            .build();\n\n        // POST request with JSON body - like submitting a form\n        String jsonBody = \"{\\\"name\\\": \\\"John\\\", \\\"age\\\": 30}\";\n        HttpRequest postRequest = HttpRequest.newBuilder()\n            .uri(new URI(\"https://api.example.com/users\"))\n            .header(\"Content-Type\", \"application/json\")\n            .POST(HttpRequest.BodyPublishers.ofString(jsonBody))\n            .build();\n\n        // Multipart request - like uploading a file\n        String boundary = \"Boundary-\" + System.currentTimeMillis();\n        String multipartBody = \"--\" + boundary + \"\\r\\n\" +\n            \"Content-Disposition: form-data; name=\\\"file\\\"; filename=\\\"test.txt\\\"\\r\\n\" +\n            \"Content-Type: text/plain\\r\\n\\r\\n\" +\n            \"Hello, World!\\r\\n\" +\n            \"--\" + boundary + \"--\";\n\n        HttpRequest multipartRequest = HttpRequest.newBuilder()\n            .uri(new URI(\"https://api.example.com/upload\"))\n            .header(\"Content-Type\", \"multipart/form-data; boundary=\" + boundary)\n            .POST(HttpRequest.BodyPublishers.ofString(multipartBody))\n            .build();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#handling-responses-processing-what-you-receive","title":"Handling Responses: Processing What You Receive","text":"<p>The HttpResponse interface provides access to everything the server sends back. Here's how to handle different types of responses: <pre><code>public class ResponseHandling {\n    private final HttpClient client = HttpClient.newHttpClient();\n\n    public void demonstrateResponseHandling() throws Exception {\n        // String response - good for JSON/XML/text responses\n        HttpResponse&lt;String&gt; textResponse = client.send(\n            createRequest(\"https://api.example.com/data\"),\n            HttpResponse.BodyHandlers.ofString()\n        );\n        System.out.println(\"Text body: \" + textResponse.body());\n\n        // Binary response - good for files/images\n        HttpResponse&lt;byte[]&gt; binaryResponse = client.send(\n            createRequest(\"https://api.example.com/image\"),\n            HttpResponse.BodyHandlers.ofByteArray()\n        );\n        // Process binary data...\n\n        // Stream response - good for large responses\n        HttpResponse&lt;Stream&lt;String&gt;&gt; streamResponse = client.send(\n            createRequest(\"https://api.example.com/large-data\"),\n            HttpResponse.BodyHandlers.ofLines()\n        );\n        streamResponse.body().forEach(line -&gt; {\n            // Process each line...\n        });\n    }\n\n    private HttpRequest createRequest(String uri) throws Exception {\n        return HttpRequest.newBuilder()\n            .uri(new URI(uri))\n            .build();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#asynchronous-operations-non-blocking-requests","title":"Asynchronous Operations: Non-Blocking Requests","text":"<p>One of the most powerful features of the new HttpClient is its built-in support for asynchronous operations: <pre><code>public class AsyncOperations {\n    private final HttpClient client = HttpClient.newHttpClient();\n\n    public void demonstrateAsyncOperations() throws Exception {\n        // Single async request\n        CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; future = client.sendAsync(\n            createRequest(\"https://api.example.com/data\"),\n            HttpResponse.BodyHandlers.ofString()\n        );\n\n        future.thenAccept(response -&gt; {\n            System.out.println(\"Got response: \" + response.body());\n        });\n\n        // Multiple parallel requests\n        List&lt;URI&gt; urls = Arrays.asList(\n            new URI(\"https://api.example.com/1\"),\n            new URI(\"https://api.example.com/2\"),\n            new URI(\"https://api.example.com/3\")\n        );\n\n        List&lt;CompletableFuture&lt;String&gt;&gt; futures = urls.stream()\n            .map(uri -&gt; client.sendAsync(\n                HttpRequest.newBuilder(uri).build(),\n                HttpResponse.BodyHandlers.ofString())\n                .thenApply(HttpResponse::body))\n            .collect(Collectors.toList());\n\n        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n            .thenRun(() -&gt; System.out.println(\"All requests completed!\"));\n    }\n\n    private HttpRequest createRequest(String uri) throws Exception {\n        return HttpRequest.newBuilder()\n            .uri(new URI(uri))\n            .build();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-patterns","title":"Best Practices and Common Patterns","text":"<p>Here are some recommended patterns for using the HttpClient effectively:</p>"},{"location":"1.Fundamentals/e_java/#1-reuse-httpclient-instances","title":"1. Reuse HttpClient Instances","text":"<pre><code>public class HttpClientBestPractices {\n    // Create once, reuse many times\n    private static final HttpClient client = HttpClient.newBuilder()\n        .version(Version.HTTP_2)\n        .connectTimeout(Duration.ofSeconds(10))\n        .build();\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-proper-resource-management","title":"2. Proper Resource Management","text":"<pre><code>public class ResourceManagement {\n    public void demonstrateResourceManagement() {\n        try (HttpClient client = HttpClient.newBuilder().build()) {\n            // Use client...\n        } // Client and its resources are automatically closed\n    }\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-error-handling_1","title":"3. Error Handling","text":"<pre><code>public class ErrorHandling {\n    private final HttpClient client = HttpClient.newHttpClient();\n\n    public void demonstrateErrorHandling() {\n        try {\n            HttpResponse&lt;String&gt; response = client.send(\n                HttpRequest.newBuilder()\n                    .uri(new URI(\"https://api.example.com/data\"))\n                    .build(),\n                HttpResponse.BodyHandlers.ofString()\n            );\n\n            if (response.statusCode() &gt;= 400) {\n                handleErrorResponse(response);\n            } else {\n                processSuccessResponse(response);\n            }\n        } catch (IOException e) {\n            // Handle network/connection errors\n            handleNetworkError(e);\n        } catch (InterruptedException e) {\n            // Handle interruption\n            Thread.currentThread().interrupt();\n            handleInterruption(e);\n        }\n    }\n\n    private void handleErrorResponse(HttpResponse&lt;String&gt; response) {\n        // Handle different types of error responses\n        switch (response.statusCode()) {\n            case 404:\n                // Handle not found\n                break;\n            case 401:\n                // Handle unauthorized\n                break;\n            default:\n                // Handle other errors\n        }\n    }\n\n    // Additional handling methods...\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#conclusion_8","title":"Conclusion","text":"<p>The modern HttpClient API represents a significant improvement in Java's HTTP capabilities. It provides:</p> <ul> <li>Built-in support for HTTP/2 and WebSocket</li> <li>Clean, fluent API design</li> <li>Powerful asynchronous operations</li> <li>Efficient resource management</li> <li>Comprehensive error handling</li> </ul> <p>Remember these key points:</p> <ol> <li>Reuse HttpClient instances when possible</li> <li>Choose appropriate response handlers for your data</li> <li>Use asynchronous operations for better performance</li> <li>Implement proper error handling</li> <li>Consider HTTP/2 features when available</li> </ol> <p>By following these guidelines and understanding the core concepts, you can build robust and efficient HTTP communications in your Java applications.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-generics-from-fundamentals-to-advanced-concepts","title":"Understanding Java Generics: From Fundamentals to Advanced Concepts","text":""},{"location":"1.Fundamentals/e_java/#introduction-why-generics-matter","title":"Introduction: Why Generics Matter","text":"<p>Imagine you're building a library where you store different types of items - books, DVDs, and magazines. Without some way to specify what type of item is stored where, you'd need separate systems for each type, or risk mixing them up. This is exactly the problem Java Generics solves in programming - it lets us create type-safe collections and classes that work with any type we specify.</p> <p>Before generics, developers had to cast objects and hope they got the types right. Now, we can catch these issues at compile time, making our code both safer and more readable.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-basics_1","title":"Understanding the Basics","text":"<p>Let's start with a simple example to understand how generics work: <pre><code>// Before generics (pre-Java 5)\nList list = new ArrayList();\nlist.add(\"Hello\");\nString text = (String) list.get(0);  // Requires casting, potential runtime error\n\n// With generics\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"Hello\");\nString text = list.get(0);  // No casting needed, compile-time type safety\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#creating-generic-classes","title":"Creating Generic Classes","text":"<p>Let's build our own generic class to understand how they work: <pre><code>public class Box&lt;T&gt; {\n    private T content;\n\n    public void store(T item) {\n        this.content = item;\n    }\n\n    public T retrieve() {\n        return content;\n    }\n}\n\n// Usage\nBox&lt;String&gt; stringBox = new Box&lt;&gt;();\nstringBox.store(\"Hello Generics\");\nString message = stringBox.retrieve();  // No casting needed\n\nBox&lt;Integer&gt; intBox = new Box&lt;&gt;();\nintBox.store(42);\nint number = intBox.retrieve();  // No casting needed\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#type-parameters-and-naming-conventions","title":"Type Parameters and Naming Conventions","text":"<p>In Java generics, we use specific letters by convention to represent different types. Understanding these conventions makes code more readable: <pre><code>public class TypeConventions&lt;T, U, E, K, V&gt; {\n    // T - Type (general purpose)\n    private T typeData;\n\n    // U - Another type (when T is already used)\n    private U secondTypeData;\n\n    // E - Element (commonly used in collections)\n    private List&lt;E&gt; elements;\n\n    // K, V - Key and Value (commonly used in maps)\n    private Map&lt;K, V&gt; mappedData;\n\n    // Example method showing usage\n    public void processData(T data, List&lt;E&gt; elementList, Map&lt;K, V&gt; mapping) {\n        // Processing logic\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#understanding-bounds","title":"Understanding Bounds","text":"<p>Generics become more powerful when we can restrict what types can be used. This is done through bounds: <pre><code>public class NumberProcessor&lt;T extends Number&gt; {\n    private T number;\n\n    public NumberProcessor(T number) {\n        this.number = number;\n    }\n\n    public double getDoubleValue() {\n        // Can safely call doubleValue() because T must be a Number\n        return number.doubleValue();\n    }\n}\n\n// Usage\nNumberProcessor&lt;Integer&gt; intProcessor = new NumberProcessor&lt;&gt;(42);\nNumberProcessor&lt;Double&gt; doubleProcessor = new NumberProcessor&lt;&gt;(3.14);\n// NumberProcessor&lt;String&gt; stringProcessor = new NumberProcessor&lt;&gt;(\"Hello\"); // Won't compile\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#multiple-bounds","title":"Multiple Bounds","text":"<p>We can also specify multiple bounds using the &amp; operator: <pre><code>public class DataProcessor&lt;T extends Number &amp; Comparable&lt;T&gt;&gt; {\n    private T data;\n\n    public DataProcessor(T data) {\n        this.data = data;\n    }\n\n    public boolean isLargerThan(T other) {\n        return data.compareTo(other) &gt; 0;\n    }\n\n    public double processValue() {\n        return data.doubleValue();\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#wildcards-understanding-flexibility","title":"Wildcards: Understanding Flexibility","text":"<p>Wildcards provide flexibility when working with generic types. There are three types of wildcards:</p>"},{"location":"1.Fundamentals/e_java/#1-upper-bounded-wildcards","title":"1. Upper Bounded Wildcards","text":"<pre><code>public class AnimalShelter {\n    // Can accept a list of any Animal subtype\n    public void feedAnimals(List&lt;? extends Animal&gt; animals) {\n        for (Animal animal : animals) {\n            animal.feed();  // Safe because we know it's some type of Animal\n        }\n    }\n\n    // Usage\n    List&lt;Dog&gt; dogs = Arrays.asList(new Dog(), new Dog());\n    List&lt;Cat&gt; cats = Arrays.asList(new Cat(), new Cat());\n    feedAnimals(dogs);  // Works with dogs\n    feedAnimals(cats);  // Works with cats\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#2-lower-bounded-wildcards","title":"2. Lower Bounded Wildcards","text":"<pre><code>public class NumberContainer {\n    // Can add Integers or any supertype of Integer\n    public void addNumbers(List&lt;? super Integer&gt; numbers) {\n        numbers.add(42);    // Safe because Integer can be added to any of its supertypes\n        numbers.add(123);   // Also safe\n    }\n\n    // Usage\n    List&lt;Number&gt; numberList = new ArrayList&lt;&gt;();\n    List&lt;Object&gt; objectList = new ArrayList&lt;&gt;();\n    addNumbers(numberList);  // Works with Number\n    addNumbers(objectList);  // Works with Object\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#3-unbounded-wildcards","title":"3. Unbounded Wildcards","text":"<pre><code>public class GenericUtility {\n    // Can work with any type of list\n    public void printList(List&lt;?&gt; list) {\n        for (Object item : list) {\n            System.out.println(\"Item: \" + item);\n        }\n    }\n\n    // Usage\n    List&lt;String&gt; strings = Arrays.asList(\"Hello\", \"World\");\n    List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3);\n    printList(strings);  // Works with strings\n    printList(numbers);  // Works with numbers\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#advanced-generic-methods","title":"Advanced Generic Methods","text":"<p>Generic methods provide type safety and reusability at the method level: <pre><code>public class GenericMethods {\n    // Generic method to swap array elements\n    public static &lt;T&gt; void swap(T[] array, int i, int j) {\n        T temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    // Generic method with bounded type parameter\n    public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(List&lt;T&gt; list) {\n        if (list.isEmpty()) {\n            throw new IllegalArgumentException(\"List is empty\");\n        }\n\n        T max = list.get(0);\n        for (T item : list) {\n            if (item.compareTo(max) &gt; 0) {\n                max = item;\n            }\n        }\n        return max;\n    }\n\n    // Generic method with multiple type parameters\n    public static &lt;K, V&gt; Map&lt;V, K&gt; reverseMap(Map&lt;K, V&gt; map) {\n        Map&lt;V, K&gt; reversed = new HashMap&lt;&gt;();\n        for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {\n            reversed.put(entry.getValue(), entry.getKey());\n        }\n        return reversed;\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-and-common-pitfalls_6","title":"Best Practices and Common Pitfalls","text":""},{"location":"1.Fundamentals/e_java/#1-type-erasure-understanding","title":"1. Type Erasure Understanding","text":"<p>Remember that generics are enforced at compile time but erased at runtime: <pre><code>// This won't work as expected due to type erasure\npublic class TypeErasureExample&lt;T&gt; {\n    public boolean isType(Object obj) {\n        // Won't compile: Cannot perform instanceof check against type parameter\n        // return obj instanceof T;\n\n        // Instead, pass the Class object\n        return ((Class&lt;T&gt;) obj.getClass()).isInstance(obj);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-collections-and-arrays","title":"2. Collections and Arrays","text":"<p>Be careful when mixing generics with arrays: <pre><code>// This won't compile\n// List&lt;String&gt;[] stringLists = new List&lt;String&gt;[10];  // Error\n\n// Instead use List of Lists\nList&lt;List&lt;String&gt;&gt; listOfStringLists = new ArrayList&lt;&gt;();\n\n// Or use wildcard\nList&lt;?&gt;[] wildcardLists = new List&lt;?&gt;[10];  // OK\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-generic-type-inference","title":"3. Generic Type Inference","text":"<pre><code>public class TypeInference {\n    // Let the compiler infer types when possible\n    Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();  // Instead of new HashMap&lt;String, List&lt;Integer&gt;&gt;()\n\n    // Use diamond operator for cleaner code\n    List&lt;String&gt; strings = new ArrayList&lt;&gt;();\n}\n</code></pre>"},{"location":"1.Fundamentals/e_java/#conclusion_9","title":"Conclusion","text":"<p>Java Generics provide a powerful way to write type-safe, reusable code. Remember these key points:</p> <ol> <li>Use generics to achieve compile-time type safety</li> <li>Understand bounded type parameters to restrict type arguments</li> <li>Use wildcards appropriately for flexibility</li> <li>Be aware of type erasure limitations</li> <li>Follow naming conventions for better code readability</li> <li>Consider using generic methods for type-safe operations</li> </ol> <p>By following these guidelines and understanding the concepts presented, you can write more robust and maintainable Java code that leverages the full power of generics.</p>"},{"location":"1.Fundamentals/e_java/#understanding-the-java-virtual-machine-a-comprehensive-guide","title":"Understanding the Java Virtual Machine: A Comprehensive Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction-what-is-the-jvm","title":"Introduction: What is the JVM?","text":"<p>Imagine you're a world traveler who can speak many languages. When you visit different countries, you act as a translator, helping people understand each other regardless of their native language. The Java Virtual Machine (JVM) plays a similar role in the world of computing - it's a remarkable piece of software that translates Java programs into machine code that any computer can understand, while also managing the program's resources efficiently.</p>"},{"location":"1.Fundamentals/e_java/#the-core-purpose-write-once-run-anywhere","title":"The Core Purpose: Write Once, Run Anywhere","text":"<p>When Java was introduced in 1995, it revolutionized software development with a powerful promise: \"Write Once, Run Anywhere.\" To understand why this was revolutionary, let's consider how programs typically work: <pre><code>// This Java code will run on any platform with a JVM\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, World!\");\n    }\n}\n</code></pre> When you compile this code, it doesn't turn directly into machine code for Windows, Mac, or Linux. Instead, it becomes platform-independent bytecode that the JVM can understand. The JVM then acts as an interpreter and translator on each platform, converting this bytecode into the specific machine code needed for that system.</p>"},{"location":"1.Fundamentals/e_java/#the-jvm-architecture-a-three-layer-system","title":"The JVM Architecture: A Three-Layer System","text":"<p>The JVM operates through three main components working together:</p>"},{"location":"1.Fundamentals/e_java/#1-class-loader-subsystem","title":"1. Class Loader Subsystem","text":"<p>Think of the class loader as a librarian who knows exactly where to find and organize all the books (classes) your program needs: <pre><code>public class ClassLoaderExample {\n    public static void demonstrate() {\n        // The class loader follows three principles:\n\n        // 1. Delegation Hierarchy\n        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();\n        ClassLoader extensionClassLoader = systemClassLoader.getParent();\n        ClassLoader bootstrapClassLoader = extensionClassLoader.getParent();\n\n        // 2. Visibility Principle\n        // Child class loaders can see classes loaded by parent class loaders\n        // Parents cannot see classes loaded by children\n\n        // 3. Uniqueness Principle\n        // Classes should be loaded only once\n        Class&lt;?&gt; stringClass1 = String.class;\n        Class&lt;?&gt; stringClass2 = String.class;\n        System.out.println(\"Same class? \" + (stringClass1 == stringClass2)); // Always true\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-runtime-data-areas","title":"2. Runtime Data Areas","text":"<p>The JVM manages several critical memory areas: <pre><code>public class MemoryAreasExample {\n    // Method Area: Stores class structure, methods, constructors\n    static class Configuration {\n        static String appName = \"MyApp\"; // Stored in method area\n    }\n\n    public void demonstrateMemoryAreas() {\n        // Heap: Where objects live\n        Object myObject = new Object(); // Created in heap\n\n        // Stack: Where method calls and local variables live\n        int localVar = 42; // Stored in stack\n\n        // PC Register: Stores current execution point\n        // JVM Native Method Stack: For native method calls\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-execution-engine","title":"3. Execution Engine","text":"<p>The execution engine is like a highly efficient translator who can read bytecode and convert it into machine code: <pre><code>public class ExecutionEngineDemo {\n    public void demonstrate() {\n        // The Execution Engine has three main components:\n\n        // 1. Interpreter\n        // Reads bytecode instruction by instruction\n        int result = 10 + 20; // Each operation interpreted\n\n        // 2. JIT Compiler\n        // Compiles frequently used code for better performance\n        for (int i = 0; i &lt; 10000; i++) {\n            // This loop might get JIT compiled\n            result += i;\n        }\n\n        // 3. Garbage Collector\n        // Automatically manages memory\n        Object obj = new Object();\n        obj = null; // Object becomes eligible for garbage collection\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#memory-management-and-garbage-collection","title":"Memory Management and Garbage Collection","text":"<p>One of the JVM's most powerful features is automatic memory management. Here's how it works: <pre><code>public class MemoryManagementExample {\n    public void demonstrateMemoryManagement() {\n        // Objects are created in the Young Generation\n        Object newObject = new Object();\n\n        // After surviving several garbage collections,\n        // objects move to the Old Generation\n        for (int i = 0; i &lt; 1000000; i++) {\n            Object temp = new Object();\n            // temp becomes eligible for GC after each iteration\n        }\n\n        // Different GC algorithms can be selected:\n        // -XX:+UseSerialGC\n        // -XX:+UseParallelGC\n        // -XX:+UseG1GC\n        // -XX:+UseZGC\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#advanced-features-jit-compilation-and-performance-optimization","title":"Advanced Features: JIT Compilation and Performance Optimization","text":"<p>The JVM includes sophisticated optimization techniques: <pre><code>public class OptimizationExample {\n    private int counter = 0;\n\n    // This method might get JIT compiled due to frequent use\n    public void incrementCounter() {\n        counter++;\n        // JIT compiler might inline this method if called frequently\n    }\n\n    // Method that demonstrates various optimizations\n    public void demonstrateOptimizations() {\n        // Loop unrolling\n        for (int i = 0; i &lt; 4; i++) {\n            incrementCounter();\n        }\n        // Might be optimized to:\n        // counter++; counter++; counter++; counter++;\n\n        // Dead code elimination\n        if (false) {\n            System.out.println(\"Never reached\");\n            // JIT will remove this code entirely\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#security-and-the-jvm","title":"Security and the JVM","text":"<p>The JVM provides several security features: <pre><code>public class SecurityExample {\n    public void demonstrateSecurity() {\n        // Security Manager checks permissions\n        SecurityManager securityManager = System.getSecurityManager();\n        if (securityManager != null) {\n            try {\n                securityManager.checkRead(\"sensitive.file\");\n            } catch (SecurityException e) {\n                System.out.println(\"Access denied\");\n            }\n        }\n\n        // Bytecode verification ensures code safety\n        // Class loader security ensures proper class loading\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#monitoring-and-troubleshooting","title":"Monitoring and Troubleshooting","text":"<p>Understanding how to monitor and troubleshoot the JVM is crucial: <pre><code>public class MonitoringExample {\n    public void demonstrateMonitoring() {\n        // Get memory usage\n        Runtime runtime = Runtime.getRuntime();\n        long totalMemory = runtime.totalMemory();\n        long freeMemory = runtime.freeMemory();\n        long usedMemory = totalMemory - freeMemory;\n\n        // Thread monitoring\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        int threadCount = threadMXBean.getThreadCount();\n\n        // Useful JVM flags for troubleshooting:\n        // -XX:+HeapDumpOnOutOfMemoryError\n        // -XX:+PrintGCDetails\n        // -XX:+PrintCompilation\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conclusion_10","title":"Conclusion","text":"<p>The JVM is a remarkable piece of software engineering that provides:</p> <ul> <li>Platform independence through bytecode interpretation</li> <li>Automatic memory management through garbage collection</li> <li>Performance optimization through JIT compilation</li> <li>Security through bytecode verification and the security manager</li> <li>Comprehensive monitoring and troubleshooting capabilities</li> </ul> <p>By understanding these concepts, developers can better utilize the JVM's capabilities and write more efficient Java applications. Remember that while the JVM handles many complex tasks automatically, understanding its inner workings helps us write better code and diagnose issues more effectively when they arise.</p>"},{"location":"1.Fundamentals/e_java/#understanding-java-garbage-collection-memory-management-made-simple","title":"Understanding Java Garbage Collection: Memory Management Made Simple","text":""},{"location":"1.Fundamentals/e_java/#introduction-why-garbage-collection-matters","title":"Introduction: Why Garbage Collection Matters","text":"<p>Imagine you're hosting a large party. As guests enjoy drinks and snacks, they leave empty cups and plates around. Without someone cleaning up, the space would quickly become unusable. Just as a party needs cleanup staff, Java programs need garbage collection to clean up unused objects and maintain healthy memory usage.</p> <p>Before Java, programmers had to manually manage memory\u2014equivalent to asking party guests to clean up after themselves. Some would forget, leading to memory leaks. Others might clean up too early, causing crashes. Java's garbage collection revolutionized programming by automating this process.</p>"},{"location":"1.Fundamentals/e_java/#understanding-memory-in-java","title":"Understanding Memory in Java","text":"<p>Let's start with how Java organizes memory: <pre><code>public class MemoryExample {\n    public void demonstrateMemoryAllocation() {\n        // Objects are stored in the heap\n        String partyGuest = new String(\"John\");  // Created in heap\n\n        // Local variables are stored in the stack\n        int partySize = 50;  // Created in stack\n\n        // When partyGuest goes out of scope or is set to null,\n        // it becomes eligible for garbage collection\n        partyGuest = null;\n    }\n}\n</code></pre> The JVM divides memory into different areas:</p>"},{"location":"1.Fundamentals/e_java/#the-heap","title":"The Heap","text":"<p>This is where all objects live. Think of it as the party venue in our analogy. It's divided into:</p> <ol> <li>Young Generation (The New Space) <pre><code>public class YoungGenerationExample {\n    public void demonstrateYoungGeneration() {\n        // Most new objects start here\n        for (int i = 0; i &lt; 1000; i++) {\n            // These objects are initially created in Eden space\n            Object temp = new Object();\n            // If they survive, they move to Survivor spaces\n        }\n    }\n}\n</code></pre></li> <li>Old Generation (The Tenured Space) <pre><code>public class OldGenerationExample {\n    // Long-lived objects end up here\n    private static final Map&lt;String, String&gt; CONFIGURATION = new HashMap&lt;&gt;();\n\n    static {\n        // This map will likely be promoted to old generation\n        // since it's meant to live for the entire program duration\n        CONFIGURATION.put(\"host\", \"localhost\");\n        CONFIGURATION.put(\"port\", \"8080\");\n    }\n}\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#how-garbage-collection-works","title":"How Garbage Collection Works","text":"<p>Garbage collection operates in several phases:</p>"},{"location":"1.Fundamentals/e_java/#1-mark-phase","title":"1. Mark Phase","text":"<p>The garbage collector identifies which objects are still in use: <pre><code>public class MarkPhaseExample {\n    public void demonstrateObjectReachability() {\n        Object object1 = new Object();  // Reachable\n        Object object2 = new Object();  // Reachable\n        object1 = null;  // Now object1 is unreachable\n\n        // At this point:\n        // - object2 is still reachable\n        // - the original object1 is unreachable and eligible for GC\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-sweep-phase","title":"2. Sweep Phase","text":"<p>The garbage collector reclaims memory from unreachable objects: <pre><code>public class SweepPhaseExample {\n    public void demonstrateMemoryReclamation() {\n        // Creating objects that will become garbage\n        for (int i = 0; i &lt; 1000; i++) {\n            byte[] data = new byte[1024];  // 1KB array\n            // data becomes eligible for GC after each loop iteration\n        }\n\n        // After this loop, many objects are eligible for GC\n        // The sweep phase will reclaim this memory\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#garbage-collection-strategies","title":"Garbage Collection Strategies","text":"<p>Java provides several garbage collection algorithms:</p>"},{"location":"1.Fundamentals/e_java/#1-serial-gc","title":"1. Serial GC","text":"<p>Best for simple applications with small data sets: <pre><code>public class SerialGCExample {\n    // To use Serial GC, run with:\n    // java -XX:+UseSerialGC YourClass\n\n    public void demonstrateSerialGC() {\n        // Suitable for simple applications\n        List&lt;String&gt; data = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 100; i++) {\n            data.add(\"Item \" + i);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-parallel-gc","title":"2. Parallel GC","text":"<p>Ideal for applications that can tolerate pauses but need maximum throughput: <pre><code>public class ParallelGCExample {\n    // To use Parallel GC, run with:\n    // java -XX:+UseParallelGC YourClass\n\n    public void demonstrateParallelGC() {\n        // Good for batch processing\n        Map&lt;Integer, String&gt; largeMap = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; 1000000; i++) {\n            largeMap.put(i, \"Value\" + i);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-g1-gc-garbage-first","title":"3. G1 GC (Garbage First)","text":"<p>The default since Java 9, designed for large heaps with more predictable pause times: <pre><code>public class G1GCExample {\n    // G1 is default, but can explicitly set with:\n    // java -XX:+UseG1GC YourClass\n\n    public void demonstrateG1GC() {\n        // Good for large applications with large heaps\n        Cache&lt;String, String&gt; cache = new ConcurrentCache&lt;&gt;();\n        for (int i = 0; i &lt; 1000000; i++) {\n            cache.put(\"Key\" + i, \"Value\" + i);\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-working-with-garbage-collection","title":"Best Practices for Working with Garbage Collection","text":""},{"location":"1.Fundamentals/e_java/#1-proper-resource-management","title":"1. Proper Resource Management","text":"<p>Always close resources explicitly rather than relying on garbage collection: <pre><code>public class ResourceManagement {\n    public void demonstrateProperResourceHandling() {\n        // Good: Using try-with-resources\n        try (FileInputStream fis = new FileInputStream(\"file.txt\")) {\n            // Use the resource\n        } catch (IOException e) {\n            // Handle exception\n        }\n\n        // Bad: Relying on GC to close resources\n        FileInputStream fis = new FileInputStream(\"file.txt\");\n        // Resource might not be closed promptly\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-avoid-memory-leaks","title":"2. Avoid Memory Leaks","text":"<p>Common patterns that can cause memory leaks: <pre><code>public class MemoryLeakExamples {\n    // Bad: Static collections that grow unbounded\n    private static final List&lt;Object&gt; staticCollection = new ArrayList&lt;&gt;();\n\n    public void demonstrateMemoryLeak() {\n        // This collection will never be garbage collected\n        staticCollection.add(new Object());\n\n        // Better: Use bounded collections or clear when done\n        Queue&lt;Object&gt; boundedQueue = new ArrayBlockingQueue&lt;&gt;(1000);\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-monitoring-and-tuning","title":"3. Monitoring and Tuning","text":"<p>Tools and techniques for monitoring garbage collection: <pre><code>public class GCMonitoring {\n    public static void main(String[] args) {\n        // Run with these flags for GC logging:\n        // -Xlog:gc*=debug:file=gc.log:time,uptime:filecount=5,filesize=10m\n\n        // Create some garbage\n        for (int i = 0; i &lt; 1000000; i++) {\n            Object obj = new Object();\n        }\n    }\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#conclusion_11","title":"Conclusion","text":"<p>Garbage collection in Java provides automated memory management that:</p> <ul> <li>Eliminates most manual memory management</li> <li>Prevents common memory-related bugs</li> <li>Improves development productivity</li> <li>Maintains application health</li> </ul> <p>Key takeaways:</p> <ol> <li>Understand how objects become eligible for garbage collection</li> <li>Choose the appropriate GC algorithm for your application</li> <li>Follow best practices to avoid memory leaks</li> <li>Monitor GC performance in production</li> <li>Don't rely on GC for resource management</li> </ol> <p>By understanding these concepts and following best practices, you can write more efficient and reliable Java applications that work harmoniously with the garbage collector.</p>"},{"location":"1.Fundamentals/e_java/#java-thread-constructors-and-lifecycle-management-a-developers-guide","title":"Java Thread Constructors and Lifecycle Management: A Developer's Guide","text":""},{"location":"1.Fundamentals/e_java/#introduction-to-java-thread-creation","title":"Introduction to Java Thread Creation","text":"<p>Understanding how to properly create and manage threads is fundamental to building robust concurrent applications in Java. Let's explore the various ways to instantiate threads and manage their lifecycle, starting with the foundational concepts and building up to more advanced usage patterns.</p>"},{"location":"1.Fundamentals/e_java/#thread-constructors-in-detail","title":"Thread Constructors in Detail","text":"<p>Java provides several constructors for creating threads, each serving different needs in application design. Let's examine each constructor and understand its specific use cases.</p>"},{"location":"1.Fundamentals/e_java/#the-default-constructor","title":"The Default Constructor","text":"<p><pre><code>Thread thread = new Thread();\n</code></pre> This simplest form creates a thread with a default name and no specific task. While it's available, you'll rarely use it in practice since a thread needs a task to be useful. Think of it like hiring an employee without giving them any job description - they're ready to work but don't know what to do.</p>"},{"location":"1.Fundamentals/e_java/#the-named-thread-constructor","title":"The Named Thread Constructor","text":"<p><pre><code>Thread thread = new Thread(\"CustomThreadName\");\n</code></pre> This constructor allows you to assign a meaningful name to your thread. This becomes invaluable when debugging multi-threaded applications - imagine trying to debug an application where every thread is named \"Thread-1\", \"Thread-2\" instead of descriptive names like \"DatabaseConnectionThread\" or \"FileProcessingThread\".</p>"},{"location":"1.Fundamentals/e_java/#the-runnable-constructor","title":"The Runnable Constructor","text":"<p><pre><code>Thread thread = new Thread(new MyRunnable());\n</code></pre> This is one of the most commonly used constructors. It accepts a Runnable object that defines the task the thread will execute. Think of Runnable as a job description - it tells the thread exactly what work needs to be done.</p>"},{"location":"1.Fundamentals/e_java/#the-named-runnable-constructor","title":"The Named Runnable Constructor","text":"<p><pre><code>Thread thread = new Thread(new MyRunnable(), \"DataProcessingThread\");\n</code></pre> This constructor combines the benefits of both named threads and Runnable tasks. It's particularly useful in production environments where both clear task definition and meaningful thread identification are important.</p>"},{"location":"1.Fundamentals/e_java/#understanding-thread-creation-approaches","title":"Understanding Thread Creation Approaches","text":""},{"location":"1.Fundamentals/e_java/#extending-thread-class","title":"Extending Thread Class","text":"<p><pre><code>public class DataProcessingThread extends Thread {\n    private final String dataSource;\n\n    public DataProcessingThread(String dataSource) {\n        // Meaningful name based on the data source\n        super(\"DataProcessor-\" + dataSource);\n        this.dataSource = dataSource;\n    }\n\n    @Override\n    public void run() {\n        // The thread's main logic goes here\n        System.out.println(\"Processing data from: \" + dataSource);\n        // ... actual data processing code\n    }\n}\n</code></pre> This approach is useful when:</p> <ul> <li>Your thread needs to maintain specific state</li> <li>You want to provide additional methods beyond run()</li> <li>You need to override other Thread class behaviors</li> </ul>"},{"location":"1.Fundamentals/e_java/#implementing-runnable-interface","title":"Implementing Runnable Interface","text":"<p><pre><code>public class DataProcessor implements Runnable {\n    private final String dataSource;\n    private final ProcessingStrategy strategy;\n\n    public DataProcessor(String dataSource, ProcessingStrategy strategy) {\n        this.dataSource = dataSource;\n        this.strategy = strategy;\n    }\n\n    @Override\n    public void run() {\n        // The task's main logic goes here\n        strategy.process(dataSource);\n    }\n}\n\n// Usage\nThread processingThread = new Thread(\n    new DataProcessor(\"customer_data.csv\", new BatchProcessingStrategy()),\n    \"CustomerDataProcessor\"\n);\n</code></pre> This approach is preferred when:</p> <ul> <li>You want to separate the task logic from thread management</li> <li>Your class needs to extend another class</li> <li>You want to promote code reusability</li> </ul>"},{"location":"1.Fundamentals/e_java/#thread-lifecycle-management","title":"Thread Lifecycle Management","text":"<p>Understanding thread lifecycle is crucial for proper application behavior. Here's a detailed look at each state:</p>"},{"location":"1.Fundamentals/e_java/#1-new-state","title":"1. New State","text":"<p>When a thread is created but not yet started: <pre><code>Thread thread = new Thread(() -&gt; System.out.println(\"Hello\")); // Thread is in NEW state\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#2-runnable-state","title":"2. Runnable State","text":"<p>When start() is called, the thread enters the runnable state: <pre><code>thread.start(); // Thread moves to RUNNABLE state\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#3-running-state","title":"3. Running State","text":"<p>The thread scheduler selects the thread for execution. No explicit code is needed - this is handled by the JVM.</p>"},{"location":"1.Fundamentals/e_java/#4-blockedwaiting-state","title":"4. Blocked/Waiting State","text":"<p>Threads can enter this state through various mechanisms: <pre><code>// Waiting for a specified time\nThread.sleep(1000); // Thread sleeps for 1 second\n\n// Waiting for another thread to complete\nanotherThread.join(); // Current thread waits for anotherThread to finish\n\n// Waiting for object lock\nsynchronized(object) {\n    object.wait(); // Thread waits for notification\n}\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#5-terminated-state","title":"5. Terminated State","text":"<p>When the thread completes its execution: <pre><code>// Thread naturally completes when run() finishes\n// Or can be interrupted\nthread.interrupt(); // Request thread termination\n</code></pre></p>"},{"location":"1.Fundamentals/e_java/#best-practices-for-thread-creation-and-management","title":"Best Practices for Thread Creation and Management","text":"<ol> <li>Use Meaningful Names: Always name your threads descriptively: <pre><code>Thread thread = new Thread(runnable, \"OrderProcessing-\" + orderId);\n</code></pre></li> <li>Handle Interruptions Properly: <pre><code>public void run() {\n    try {\n        while (!Thread.currentThread().isInterrupted()) {\n            // Do work\n        }\n    } catch (InterruptedException e) {\n        // Clean up resources\n        Thread.currentThread().interrupt(); // Restore interrupted status\n    }\n}\n</code></pre></li> <li>Use Thread Factories for Consistent Creation: <pre><code>ThreadFactory factory = new ThreadFactory() {\n    private final AtomicInteger count = new AtomicInteger(0);\n\n    @Override\n    public Thread newThread(Runnable r) {\n        Thread thread = new Thread(r);\n        thread.setName(\"Worker-\" + count.incrementAndGet());\n        thread.setPriority(Thread.NORM_PRIORITY);\n        thread.setUncaughtExceptionHandler((t, e) -&gt; \n            logger.error(\"Thread \" + t.getName() + \" failed\", e));\n        return thread;\n    }\n};\n</code></pre></li> <li>Consider Using ExecutorService: <pre><code>ExecutorService executor = Executors.newFixedThreadPool(\n    Runtime.getRuntime().availableProcessors(),\n    factory\n);\n</code></pre></li> </ol>"},{"location":"1.Fundamentals/e_java/#common-pitfalls-to-avoid_2","title":"Common Pitfalls to Avoid","text":"<ol> <li>Never call thread.run() directly - it executes in the current thread instead of starting a new one</li> <li>Avoid creating too many threads - use thread pools instead</li> <li>Don't ignore InterruptedException - either handle it or propagate it</li> <li>Never rely on thread priority for program correctness</li> <li>Avoid using deprecated methods like Thread.stop()</li> </ol> <p>Remember: Thread creation is relatively expensive. In production applications, you'll typically want to use thread pools via ExecutorService rather than creating threads directly. This guide covers direct thread creation primarily for understanding the fundamentals and for cases where fine-grained thread control is necessary.</p>"},{"location":"1.Fundamentals/e_java/#java-streams","title":"Java Streams","text":"<p>Java Streams provide a powerful way to process collections of data using a functional programming approach. Think of streams as a conveyor belt for your data - items enter at one end, undergo transformations as they move along, and emerge processed at the other end. Streams support operations like filtering, mapping, reducing, and collecting, all while handling the complexity of iteration for you. Most importantly, streams can process data either sequentially or in parallel with minimal code changes.</p> <p>For example, calculating the sum of all even numbers in a list: <pre><code>int sum = numbers.stream()\n    .filter(n -&gt; n % 2 == 0)\n    .mapToInt(Integer::intValue)\n    .sum();\n</code></pre> Java 8+ Streams Article Java 8 Streams Java 8+ Streams API Tutorial Video</p>"},{"location":"1.Fundamentals/e_java/#java-memory-management","title":"Java Memory Management","text":"<p>Java's memory management system is like a highly efficient librarian, automatically organizing and cleaning up objects in memory. The Java Virtual Machine (JVM) divides memory into different regions - primarily the heap for objects and the stack for method execution. The garbage collector automatically identifies and removes objects that are no longer needed, preventing memory leaks and reducing the burden on developers. This system uses sophisticated algorithms to determine when objects are no longer reachable and can be safely removed.</p> <p>Java Memory Management Article Java Memory Management Tutorial Java Memory Management Video</p>"},{"location":"1.Fundamentals/e_java/#java-collection-framework","title":"Java Collection Framework","text":"<p>The Java Collections Framework provides a unified architecture for storing and manipulating groups of objects. It's like a well-organized toolbox, offering different containers (List, Set, Map, Queue) for different needs. Each interface has multiple implementations optimized for different use cases - ArrayList for fast access, LinkedList for efficient insertions/deletions, HashMap for key-value lookups, and more. The framework also provides algorithms for sorting, searching, and manipulating data structures. <pre><code>// Different collections for different needs\nList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();  // Ordered, fast access\nSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();      // No duplicates\nMap&lt;String, User&gt; userMap = new HashMap&lt;&gt;(); // Key-value pairs\n</code></pre> Java Collections Java - Collections Framework</p>"},{"location":"1.Fundamentals/e_java/#java-serialization","title":"Java Serialization","text":"<p>Serialization is Java's way of converting objects into a format that can be easily saved or transmitted. Think of it as freezing an object's state so it can be thawed later, either in the same program or a different one. This is crucial for saving application state, sending objects over a network, or implementing caching systems. Java provides built-in serialization through the Serializable interface, though modern applications often use alternatives like JSON or Protocol Buffers for better control and cross-platform compatibility. <pre><code>class User implements Serializable {\n    private String name;\n    private transient String password; // Won't be serialized\n    // ... rest of the class\n}\n</code></pre> Serialization/Deserialization in Java Introduction to Java Serialization</p>"},{"location":"1.Fundamentals/e_java/#java-networking-and-sockets","title":"Java Networking and Sockets","text":"<p>Java's networking capabilities provide a robust foundation for building distributed applications. The networking API centers around sockets - endpoints for communication between machines. Java supports both TCP (reliable, connection-oriented) and UDP (faster, but unreliable) protocols. The API abstracts away many complex networking details, letting developers focus on application logic while still providing low-level control when needed. <pre><code>// Simple server example\ntry (ServerSocket server = new ServerSocket(8080)) {\n    Socket client = server.accept();\n    // Handle client connection\n}\n</code></pre> Sockets Java Networking Java Socket Programming Video</p>"},{"location":"2.Interviews/a_technical_interviews/","title":"\ud83d\ude80 The Ultimate Technical Interview Guide","text":""},{"location":"2.Interviews/a_technical_interviews/#data-structures-algorithms-and-patterns","title":"Data Structures, Algorithms, and Patterns","text":""},{"location":"2.Interviews/a_technical_interviews/#introduction","title":"Introduction","text":"<p>Success in technical interviews requires a strategic, data-driven approach to preparation. This comprehensive guide provides a structured roadmap for mastering the most frequently tested concepts and patterns in coding interviews, helping you optimize your preparation time for maximum impact.</p>"},{"location":"2.Interviews/a_technical_interviews/#getting-started","title":"Getting Started","text":"<p>Our preparation methodology focuses on high-return-on-investment (ROI) topics based on extensive analysis of interview patterns across major technology companies. By concentrating on the most commonly tested concepts, you can develop a strong foundation that translates directly to interview success.</p>"},{"location":"2.Interviews/a_technical_interviews/#overview","title":"Overview","text":"<p>Technical interviews consistently evaluate candidates' proficiency in core computer science fundamentals through coding challenges. Understanding the underlying patterns in these challenges allows you to develop reusable problem-solving strategies rather than memorizing individual solutions.</p>"},{"location":"2.Interviews/a_technical_interviews/#key-focus-areas","title":"Key Focus Areas","text":""},{"location":"2.Interviews/a_technical_interviews/#essential-patterns","title":"Essential Patterns","text":"<p>The data reveals that three fundamental patterns appear most frequently in coding interviews:</p> <p>Depth-First Search (DFS) serves as a versatile problem-solving approach, effectively addressing challenges involving trees, graphs, and combinatorial problems. Its widespread applicability makes it an essential technique to master.</p> <p>Breadth-First Search (BFS) consistently appears in problems requiring level-wise traversal or finding shortest paths in unweighted graphs. Understanding BFS implementation and its common variations provides significant advantages in interviews.</p> <p>Two-Pointer techniques frequently arise in array manipulation and string processing problems. Mastering this pattern enables efficient solutions to problems involving sliding windows, palindromes, and element matching.</p>"},{"location":"2.Interviews/a_technical_interviews/#foundational-data-structures","title":"Foundational Data Structures","text":"<p>Core data structures form the building blocks of efficient solutions:</p> <p>Arrays, Linked Lists, Hash Maps, Stacks, and Queues represent fundamental concepts that appear regularly in interviews. While these topics may seem basic, their mastery is crucial as they often combine with advanced patterns to solve complex problems.</p>"},{"location":"2.Interviews/a_technical_interviews/#advanced-topics","title":"Advanced Topics","text":"<p>Priority Queues and Heaps appear more frequently than commonly expected, particularly in problems involving streaming data or maintaining ordered elements. Understanding these data structures provides advantages in specific interview scenarios.</p> <p>Dynamic Programming and Greedy Algorithms, while important, require significant preparation time relative to their frequency in interviews. Focus on these areas after mastering the core patterns, unless interviewing with companies known to emphasize these topics.</p> <p></p>"},{"location":"2.Interviews/a_technical_interviews/#dijkstras-algorithm-for-solving-problems","title":"Dijkstra's Algorithm for Solving Problems","text":"<pre><code>flowchart TD\n    A{Is it a graph?} --&gt;|Yes| B{Is it a tree?}\n    B --&gt;|Yes| C@{ shape: rounded, label: \"DFS\" }\n    B --&gt;|No| D{Is the problem related to directed acyclic graphs?}\n    D --&gt;|Yes| E@{ shape: rounded, label: \"Topological Sort\" }\n    D --&gt;|No| F{Is the problem related to shortest paths?}\n    F --&gt;|Yes| G{Is the graph Weighted?}\n    G --&gt;|Yes| H@{ shape: rounded, label: \"Dijkstra's Algorithm\" }\n    G --&gt;|No| I@{ shape: rounded, label: \"BFS\" }\n    F --&gt;|No| J{Does the problem involve connectivity?}\n    J --&gt;|Yes| K@{ shape: rounded, label: \"Disjoint Set Union\" }\n    J --&gt;|No| L{Does the problem have small constraints?}\n    L --&gt;|Yes| M@{ shape: rounded, label: \"DFS/Backtracking\" }\n    L --&gt;|No| N@{ shape: rounded, label: \"BFS\" }\n    A --&gt;|No| O{Need to solve for kth smallest/largest?}\n    O --&gt;|Yes| P@{ shape: rounded, label: \"Heap/Sortings\" }\n    O --&gt;|No| Q{Involves Linked Lists?}\n    Q --&gt;|Yes| R@{ shape: rounded, label: \"Two Pointers\" }\n    Q --&gt;|No| S{Small constraint bounds?}\n    S --&gt;|Yes| T{Is brute force fast enough?}\n    T --&gt;|Yes| U@{ shape: rounded, label: \"Brute force/Backtracking\" }\n    T --&gt;|No| V@{ shape: rounded, label: \"Dynamic Programming\" }\n    S --&gt;|No| W{Deals with sums or additive}\n    W --&gt;|Yes| X@{ shape: rounded, label: \"Prefix Sums\" }\n    W --&gt;|No| Y{About subarrays or substrings?}\n    Y --&gt;|Yes| Z@{ shape: rounded, label: \"Sliding Window\" }\n    Y --&gt;|No| a1{Calculating max/min}\n    a1 --&gt;|Yes| b1{Monotonic condition?}\n    b1 --&gt;|Yes| c1@{ shape: rounded, label: \"Binary Search\" }\n    b1 --&gt;|No| d1{Can be split into sub-problems?}\n    d1 --&gt;|Yes| e1@{ shape: rounded, label: \"Dynamic Programming\" }\n    d1 --&gt;|No| f1{Greedily calculate answer?}\n    f1 --&gt;|Yes| g1@{ shape: rounded, label: \"Greedy Algorithms\" }\n    a1 --&gt;|No| h1{Asking for number of ways?}\n    h1 --&gt;|Yes| i1{Is brute force fast enough?}\n    i1 --&gt;|Yes| j1@{ shape: rounded, label: \"Brute Force/Backtracking\" }\n    i1 --&gt;|No| k1@{ shape: rounded, label: \"Dynamic Programming\" }\n    h1 --&gt;|No| l1{Multiple sequences?}\n    l1 --&gt;|Yes| m1{Monotonic conditions?}\n    m1 --&gt;|Yes| n1@{ shape: rounded, label: \"Two Pointers\" }\n    m1 --&gt;|No| o1{Can split into subproblems?}\n    o1 --&gt;|Yes| p1@{ shape: rounded, label: \"Dynamic Programming\" }\n    l1 --&gt;|No| q1@{ shape: rounded, label: \"Stack/Two Pointer\" }</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#data-structures","title":"Data Structures","text":""},{"location":"2.Interviews/a_technical_interviews/#stacks","title":"Stacks","text":"<p>A stack is one of the most fundamental data structures in computer science. It follows the Last-In-First-Out (LIFO) principle, meaning the last element added is the first one to be removed.</p>"},{"location":"2.Interviews/a_technical_interviews/#basic-operations","title":"Basic Operations","text":""},{"location":"2.Interviews/a_technical_interviews/#push","title":"Push","text":"<ul> <li>Adds an element to the top of the stack</li> <li>Think of it like placing a plate on top of a stack of plates stack.py<pre><code>def push(self, item):\n    if len(self.stack) &gt;= self.limit:\n        raise StackOverflowError\n    self.stack.append(item)\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#pop","title":"Pop","text":"<ul> <li>Removes and returns the top element from the stack</li> <li>Like taking the topmost plate off a stack of plates stack.py<pre><code>def pop(self):\n    if not self.stack:\n        raise StackUnderflowError\n    return self.stack.pop()\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#peek-or-top","title":"Peek (or Top)","text":"<ul> <li>Returns the top element without removing it</li> <li>Like looking at the top plate without taking it off stack.py<pre><code>def peek(self):\n    if not self.stack:\n        raise StackUnderflowError\n    return self.stack[-1]\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#common-properties","title":"Common Properties","text":""},{"location":"2.Interviews/a_technical_interviews/#empty-check","title":"Empty Check","text":"stack.py<pre><code>def is_empty(self):\n    return len(self.stack) == 0\n</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#full-check","title":"Full Check","text":"stack.py<pre><code>def is_full(self):\n    return len(self.stack) == self.limit\n</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Function call stack (managing program execution)</li> <li>Undo operations in text editors</li> <li>Browser history (back button functionality)</li> <li>Expression evaluation in calculators</li> <li>Backtracking algorithms</li> </ol>"},{"location":"2.Interviews/a_technical_interviews/#implementation-example","title":"Implementation Example","text":"stack.py<pre><code>class Stack:\n    def __init__(self, limit=10):\n        self.stack = []\n        self.limit = limit\n\n    def push(self, item):\n        if len(self.stack) &gt;= self.limit:\n            raise StackOverflowError\n        self.stack.append(item)\n\n    def pop(self):\n        if not self.stack:\n            raise StackUnderflowError\n        return self.stack.pop()\n\n    def peek(self):\n        if not self.stack:\n            raise StackUnderflowError\n        return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#queues","title":"Queues","text":"<p>A queue is a fundamental data structure that follows the First-In-First-Out (FIFO) principle, meaning the first element added is the first one to be removed. Think of it like a line of people waiting - the first person to join the line is the first to be served.</p>"},{"location":"2.Interviews/a_technical_interviews/#basic-operations_1","title":"Basic Operations","text":""},{"location":"2.Interviews/a_technical_interviews/#enqueue-put","title":"Enqueue (Put)","text":"<ul> <li>Adds an element to the back of the queue</li> <li>Like a person joining the end of a line queue.py<pre><code>def put(self, item):\n    self.queue.append(item)\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#dequeue-get","title":"Dequeue (Get)","text":"<ul> <li>Removes and returns the front element from the queue</li> <li>Like the first person in line being served and leaving queue.py<pre><code>def get(self):\n    if not self.queue:\n        raise IndexError(\"Queue is empty\")\n    return self.queue.pop(0)\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#peek-front","title":"Peek (Front)","text":"<ul> <li>Returns the front element without removing it</li> <li>Like checking who's first in line without serving them queue.py<pre><code>def get_front(self):\n    if not self.queue:\n        raise IndexError(\"Queue is empty\")\n    return self.queue[0]\n</code></pre></li> </ul>"},{"location":"2.Interviews/a_technical_interviews/#common-properties_1","title":"Common Properties","text":""},{"location":"2.Interviews/a_technical_interviews/#length-check","title":"Length Check","text":"queue.py<pre><code>def __len__(self):\n    return len(self.queue)\n</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#is-empty","title":"Is Empty","text":"queue.py<pre><code>def is_empty(self):\n    return len(self.queue) == 0\n</code></pre>"},{"location":"2.Interviews/a_technical_interviews/#implementation-example_1","title":"Implementation Example","text":"<p>Here's a simple implementation of a queue: queue.py<pre><code>class Queue:\n    def __init__(self):\n        self.queue = []\n\n    def put(self, item):\n        self.queue.append(item)\n\n    def get(self):\n        if not self.queue:\n            raise IndexError(\"Queue is empty\")\n        return self.queue.pop(0)\n\n    def get_front(self):\n        if not self.queue:\n            raise IndexError(\"Queue is empty\")\n        return self.queue[0]\n\n    def is_empty(self):\n        return len(self.queue) == 0\n</code></pre></p>"},{"location":"2.Interviews/a_technical_interviews/#common-use-cases_1","title":"Common Use Cases","text":"<ol> <li>Print job scheduling in printers</li> <li>Process scheduling in operating systems</li> <li>Breadth-first search in graphs</li> <li>Customer service systems</li> <li>Message buffers in communication systems</li> </ol>"},{"location":"2.Interviews/a_technical_interviews/#important-notes","title":"Important Notes","text":"<ol> <li>Unlike stacks, queues process elements in the order they were added</li> <li>The internal list implementation shown here is simple but not optimal for large queues (due to pop(0) being O(n))</li> <li>Python's  <code>collections.deque</code>  is more efficient for real-world applications</li> <li>Queues can have variations like priority queues or circular queues</li> </ol>"},{"location":"venv/lib/python3.9/site-packages/Markdown-3.7.dist-info/LICENSE/","title":"LICENSE","text":"<p>BSD 3-Clause License</p> <p>Copyright 2007, 2008 The Python Markdown Project (v. 1.7 and later) Copyright 2004, 2005, 2006 Yuri Takhteyev (v. 0.2-1.6b) Copyright 2004 Manfred Stienstra (the original version)</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"venv/lib/python3.9/site-packages/mkdocs_get_deps-0.2.0.dist-info/licenses/LICENSE/","title":"LICENSE","text":"<p>MIT License</p> <p>Copyright (c) 2023 Oleh Prypin oleh@pryp.in</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}