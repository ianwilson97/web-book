<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Data Structures - My Docs</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Data Structures";
        var mkdocs_page_input_path = "1.Fundamentals/b_data_structures.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> My Docs
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Fundamentals</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../a_object_oriented_programming/">Object Oriented Programming</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Data Structures</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">📘 Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#why-data-structures-matter">Why Data Structures Matter</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#guide-structure">Guide Structure</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#categories-of-data-structures">Categories of Data Structures</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#linear-data-structures">📚 Linear Data Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tree-based-structures">🌳 Tree-Based Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#advanced-tree-based-structures">🌲 Advanced Tree-Based Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#hash-based-structures">🎯 Hash-Based Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#graph-based-structures">🕸️ Graph-Based Structures</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#advanced-structures">📚 Advanced Structures</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#time-complexity-overview">Time Complexity Overview</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#performance-overview">📊 Performance Overview</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#references">References</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../c_algorithms/">Algorithms</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Interviews</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../2.Interviews/a_technical_interviews/">Technical Interviews</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">My Docs</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Fundamentals</li>
      <li class="breadcrumb-item active">Data Structures</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="data-structures">🔮 Data Structures<a class="headerlink" href="#data-structures" title="Permanent link">&para;</a></h1>
<p><img alt="Data Structures" src="https://i.postimg.cc/rsFzdHwb/temp-Image-.avif" /></p>
<h2 id="introduction">📘 Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Data structures are specialized formats for organizing, processing, retrieving, and storing data. Understanding data structures is fundamental to writing efficient and scalable code. This guide explores various data structures, their implementations, and practical applications in software development.</p>
<h3 id="why-data-structures-matter">Why Data Structures Matter<a class="headerlink" href="#why-data-structures-matter" title="Permanent link">&para;</a></h3>
<ul>
<li>🎯  <strong>Efficient Problem-Solving</strong>: Choosing the right data structure can dramatically improve program performance</li>
<li>💼  <strong>Career Development</strong>: Essential for technical interviews at top tech companies</li>
<li>🔧  <strong>Code Optimization</strong>: Enables writing more efficient and maintainable code</li>
<li>🌐  <strong>Real-World Applications</strong>: Critical for building scalable software systems</li>
<li>🏆  <strong>Competitive Edge</strong>: Fundamental for algorithmic problem-solving and competitions</li>
</ul>
<h2 id="guide-structure">Guide Structure<a class="headerlink" href="#guide-structure" title="Permanent link">&para;</a></h2>
<p>Each data structure section will cover:
- Core concepts and characteristics
- Implementation details
- Time and space complexities
- Common operations
- Best practices and use cases
- Code examples and tips</p>
<h2 id="categories-of-data-structures">Categories of Data Structures<a class="headerlink" href="#categories-of-data-structures" title="Permanent link">&para;</a></h2>
<h3 id="linear-data-structures">📚 Linear Data Structures<a class="headerlink" href="#linear-data-structures" title="Permanent link">&para;</a></h3>
<p>Structures where elements are stored sequentially:</p>
<ul>
<li><strong>Arrays &amp; ArrayLists</strong>:<ul>
<li>Direct access by index</li>
<li>Contiguous memory storage</li>
<li>Best for: Fixed-size collections with frequent access</li>
</ul>
</li>
<li><strong>Linked Lists</strong>:<ul>
<li>Dynamic size</li>
<li>Non-contiguous storage</li>
<li>Best for: Frequent insertions/deletions</li>
</ul>
</li>
<li><strong>Stacks</strong>:<ul>
<li>LIFO (Last-In-First-Out)</li>
<li>Best for: Function calls, undo operations</li>
</ul>
</li>
<li><strong>Queues</strong>:<ul>
<li>FIFO (First-In-First-Out)</li>
<li>Best for: Task scheduling, resource management</li>
</ul>
</li>
</ul>
<h3 id="tree-based-structures">🌳 Tree-Based Structures<a class="headerlink" href="#tree-based-structures" title="Permanent link">&para;</a></h3>
<p>Hierarchical structures with parent-child relationships:</p>
<ul>
<li><strong>Priority Queues</strong>:<ul>
<li>Efficient priority-based operations</li>
<li>Best for: Scheduling, event handling</li>
</ul>
</li>
<li><strong>Binary Trees</strong>:<ul>
<li>Two children per node maximum</li>
<li>Best for: Hierarchical data</li>
</ul>
</li>
<li><strong>Binary Search Trees</strong>:<ul>
<li>Ordered nodes</li>
<li>Best for: Fast search, insert, delete</li>
</ul>
</li>
</ul>
<h3 id="advanced-tree-based-structures">🌲 Advanced Tree-Based Structures<a class="headerlink" href="#advanced-tree-based-structures" title="Permanent link">&para;</a></h3>
<p>Specialized tree structures for specific use cases:</p>
<ul>
<li><strong>AVL Trees</strong>: Balanced binary search trees    </li>
<li><strong>Red-Black Trees</strong>: Balanced search with color properties</li>
<li><strong>2-3 Trees</strong>: Guaranteed balanced search trees</li>
<li><strong>B-Trees</strong>: Optimized for disk storage</li>
<li><strong>K-D Trees</strong>: Space partitioning structure</li>
<li><strong>M-Ary Trees</strong>: Nodes with multiple children</li>
</ul>
<h3 id="hash-based-structures">🎯 Hash-Based Structures<a class="headerlink" href="#hash-based-structures" title="Permanent link">&para;</a></h3>
<p>Structures using hash functions:</p>
<ul>
<li><strong>Hash Tables</strong>:<ul>
<li>Key-value storage</li>
<li>O(1) average access</li>
<li>Best for: Caching, dictionaries</li>
</ul>
</li>
</ul>
<h3 id="graph-based-structures">🕸️ Graph-Based Structures<a class="headerlink" href="#graph-based-structures" title="Permanent link">&para;</a></h3>
<p>Structures representing connections:</p>
<ul>
<li><strong>Directed Graphs</strong>: One-way connections</li>
<li><strong>Undirected Graphs</strong>: Two-way connections</li>
<li><strong>inaphs</strong> Coctions with costs</li>
<li><strong>Disjoint-Sets</strong>: Non-Overlapping group connections</li>
</ul>
<h3 id="advanced-structures">📚 Advanced Structures<a class="headerlink" href="#advanced-structures" title="Permanent link">&para;</a></h3>
<p>Specialized data structures:</p>
<ul>
<li><strong>Tries</strong>:<ul>
<li>Efficient string operations</li>
<li>Best for: Autocomplete, spell checkers</li>
</ul>
</li>
<li><strong>Skip Lists</strong>:<ul>
<li>Probabilistic alternative to balanced trees</li>
<li>Best for: Fast search with simple implementation</li>
</ul>
</li>
</ul>
<h2 id="time-complexity-overview">Time Complexity Overview<a class="headerlink" href="#time-complexity-overview" title="Permanent link">&para;</a></h2>
<h2 id="performance-overview">📊 Performance Overview<a class="headerlink" href="#performance-overview" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Access</th>
<th>Search</th>
<th>Insertion</th>
<th>Deletion</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>ArrayList</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)*</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>LinkedList</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Stack</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Queue</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Priority Queue</td>
<td>O(1)***</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Binary Tree</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Binary Search Tree</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(n)</td>
</tr>
<tr>
<td>AVL Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Red-Black Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>2-3 Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>B-Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>K-D Tree</td>
<td>O(n)</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(n)</td>
</tr>
<tr>
<td>Trie</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(n*m)</td>
</tr>
<tr>
<td>Skip List</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>Hash Table</td>
<td>O(1)**</td>
<td>O(1)**</td>
<td>O(1)**</td>
<td>O(1)*</td>
<td></td>
</tr>
</tbody>
</table>
<p>* Average case for balanced trees
*<em> Average case, assumes good hash function or balanced structure
*</em><em> For peek operation only
*</em>** Where m is the length of the string/pattern
† Amortized time complexity for dynamic resizing~~</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<p><a href="https://drive.google.com/file/d/1LaF74WE-jMvdlZ0FLwSWRxKVjO75iv8z/view?usp=share_link">Data Structures and Algorithms Notes</a></p>
<h1 id="linear-data-structuresine-data-structures">📚 LINEAR DATA STRUCTURESine Data Structures<a class="headerlink" href="#linear-data-structuresine-data-structures" title="Permanent link">&para;</a></h1>
<h1 id="arraylist">📚 ArrayList<a class="headerlink" href="#arraylist" title="Permanent link">&para;</a></h1>
<p><img alt="ArrayLists" src="https://i.postimg.cc/C10R05Tw/temp-Image-PLc-FLQ.avif" />
An ArrayList is a dynamic array implementation that automatically handles resizing as elements are added or removed. It provides fast random access and is one of the most used data structures in Java.</p>
<h2 id="core-characteristics">Core Characteristics<a class="headerlink" href="#core-characteristics" title="Permanent link">&para;</a></h2>
<ul>
<li>📈 Dynamic sizing</li>
<li>📊 Contiguous memory storage</li>
<li>🔍 Fast random access</li>
<li>📝 Mutable length</li>
</ul>
<h3 id="implementation-details">Implementation Details<a class="headerlink" href="#implementation-details" title="Permanent link">&para;</a></h3>
<h4 id="structure">Structure<a class="headerlink" href="#structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class ArrayList&lt;T&gt; {
    private T[] backingArray;    // Internal array to store elements
    private int size;            // Number of elements in the ArrayList
    public static final int INITIAL_CAPACITY = 9;
}</code></pre>
<h3 id="core-operations-time-complexities">🔧 Core Operations &amp; Time Complexities<a class="headerlink" href="#core-operations-time-complexities" title="Permanent link">&para;</a></h3>
<h4 id="adding-elements">Adding Elements<a class="headerlink" href="#adding-elements" title="Permanent link">&para;</a></h4>
<h5 id="addtobackt-data">addToBack(T data)<a class="headerlink" href="#addtobackt-data" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
    addHelper(size, data);
}</code></pre>
-   ⏱️ Time Complexity: Amortized O(1)
-   💭 Best for: Adding elements when order doesn't matter
-   ⚠️ Note: May trigger resizing of backing array</p>
<h5 id="addtofrontt-data">addToFront(T data)<a class="headerlink" href="#addtofrontt-data" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
    addHelper(0, data);
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   ⚠️ Warning: Requires shifting all elements
-   💭 Use Case: When elements must be added at the beginning</p>
<h4 id="internal-helper-method-adding">🛠️ Internal Helper Method (Adding)<a class="headerlink" href="#internal-helper-method-adding" title="Permanent link">&para;</a></h4>
<h5 id="addhelperint-index-t-data">addHelper(int index, T data)<a class="headerlink" href="#addhelperint-index-t-data" title="Permanent link">&para;</a></h5>
<pre class="highlight"><code class="language-java">@SuppressWarnings("unchecked")
private void addHelper(int index, T data) {
    // If array is full, create new array with double capacity
    if (size == backingArray.length) {
        T[] newArray = (T[]) new Object[backingArray.length * 2];
        int i;

        // Copy elements before index
        for (i = 0; i &lt; index; i++) {
            newArray[i] = backingArray[i];
        }
        // Insert new element
        newArray[i] = data;
        // Copy remaining elements
        for (; i &lt; size; i++) {
            newArray[i + 1] = backingArray[i];
        }

        backingArray = newArray;
    } else {
        // Shift elements to make room for new element
        for (int i = size; i &gt; index; --i) {
            backingArray[i] = backingArray[i - 1];
        }
        backingArray[index] = data;
    }
    size++;
}</code></pre>
<h4 id="removing-elements">Removing Elements<a class="headerlink" href="#removing-elements" title="Permanent link">&para;</a></h4>
<h5 id="removefromback">removeFromBack()<a class="headerlink" href="#removefromback" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromBack() {
    if (size == 0) {
        throw new java.util.NoSuchElementException("Cannot remove from an empty list");
    }
    return removeHelper(size - 1);
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💫 Most efficient removal operation
-   ⚠️ Checks for empty list</p>
<h5 id="removefromfront">removeFromFront()<a class="headerlink" href="#removefromfront" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromFront() {
    if (size == 0) {
        throw new java.util.NoSuchElementException("Cannot remove from an empty list");
    }
    return removeHelper(0);
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   ⚠️ Requires shifting all elements
-   💭 Use sparingly due to performance cost</p>
<h5 id="removeatindexint-index">removeAtIndex(int index)<a class="headerlink" href="#removeatindexint-index" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeAtIndex(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException("Index cannot be outside the "
            + "range [0, " + size + ")");
    }
    return removeHelper(index);
}</code></pre>
-   ⏱️ Time Complexity:
    -   Best Case (last element): O(1)
    -   Average/Worst Case: O(n)
-   🎯 Purpose: Removes and returns element at specified index
-   ⚠️ Validation: Checks for valid index range
-   💫 Process:
    1.  Validates index bounds
    2.  Calls removeHelper for actual removal
    3.  Returns removed element</p>
<h4 id="internal-helper-method-removing">🛠️ Internal Helper Method (Removing)<a class="headerlink" href="#internal-helper-method-removing" title="Permanent link">&para;</a></h4>
<h5 id="removehelperint-index">removeHelper(int index)<a class="headerlink" href="#removehelperint-index" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">private T removeHelper(int index) {
    T removed = backingArray[index];
    // Shift elements to fill the gap
    for (int i = index; i &lt; size - 1; i++) {
        backingArray[i] = backingArray[i + 1];
    }
    backingArray[--size] = null;  // Clear last element and decrease size
    return removed;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   🎯 Purpose: Internal method for handling element removal and shifting
-   💫 Key Operations:
    1.  Element removal at specified index
    2.  Left-shifting remaining elements
    3.  Cleanup and size management</p>
<h4 id="access-operations">Access Operations<a class="headerlink" href="#access-operations" title="Permanent link">&para;</a></h4>
<h5 id="getint-index">get(int index)<a class="headerlink" href="#getint-index" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException("Index cannot be outside the "
            + "range [0, " + size + ")");
    }
    return backingArray[index];
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   🎯 Direct index access
-   ⚠️ Bounds checking included</p>
<h2 id="performance-summary">📊 Performance Summary<a class="headerlink" href="#performance-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Back</td>
<td>O(1)*</td>
<td>*Amortized</td>
</tr>
<tr>
<td>Add to Front</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(1)</td>
<td>Most efficient removal</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Get/Set</td>
<td>O(1)</td>
<td>Direct access</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>Memory reset</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant tracking</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity - occasional resizing operations are averaged over many operations</p>
<h3 id="best-practices">💡 Best Practices<a class="headerlink" href="#best-practices" title="Permanent link">&para;</a></h3>
<h4 id="1-initialization">1. Initialization<a class="headerlink" href="#1-initialization" title="Permanent link">&para;</a></h4>
<ul>
<li>State with reasonable initial capacity</li>
<li>Consider expected size for optimal performance</li>
</ul>
<h4 id="2-usage-tips">2. Usage Tips<a class="headerlink" href="#2-usage-tips" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Prefer adding to back when possible
list.addToBack(element);  // O(1)

// Avoid frequent front operations
list.addToFront(element); // O(n) - expensive!</code></pre>
<h4 id="3-memory-management">3. Memory Management<a class="headerlink" href="#3-memory-management" title="Permanent link">&para;</a></h4>
<ul>
<li>Clear references when removing elements</li>
<li>Reset to initial capacity when clearing</li>
</ul>
<h3 id="common-use-cases">🎯 Common Use Cases<a class="headerlink" href="#common-use-cases" title="Permanent link">&para;</a></h3>
<ul>
<li>📝 Dynamic lists of elements</li>
<li>📊 Buffer implementation</li>
<li>🔄 Stack implementation</li>
<li>📚 Collection management</li>
</ul>
<h3 id="common-pitfalls">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls" title="Permanent link">&para;</a></h3>
<ol>
<li>Frequent front operations</li>
<li>Not considering capacity growth</li>
<li>Not handling null elements</li>
<li>Ignoring bounds checking</li>
</ol>
<h3 id="when-to-use-arraylist">🔍 When to Use ArrayList<a class="headerlink" href="#when-to-use-arraylist" title="Permanent link">&para;</a></h3>
<ul>
<li>Need dynamic sizing</li>
<li>Frequent random access</li>
<li>Mostly back-end operations</li>
<li>Memory locality is important</li>
</ul>
<h3 id="when-not-to-use-arraylist">🚫 When Not to Use ArrayList<a class="headerlink" href="#when-not-to-use-arraylist" title="Permanent link">&para;</a></h3>
<ul>
<li>Frequent insertions/deletions at front/middle</li>
<li>Fixed size is sufficient</li>
<li>Memory is extremely constrained</li>
<li>Need concurrent access</li>
</ul>
<h4 id="references_1">References<a class="headerlink" href="#references_1" title="Permanent link">&para;</a></h4>
<p>https://youtu.be/PEnFFiQe1pM?si=KfpsngEBI0gesUbC</p>
<h1 id="linked-lists">📚 Linked Lists<a class="headerlink" href="#linked-lists" title="Permanent link">&para;</a></h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/fLKGM96B/temp-Imageq-Jb-Lbh.avif" /></p>
<h2 id="singly-linked-list">🔗 Singly Linked List<a class="headerlink" href="#singly-linked-list" title="Permanent link">&para;</a></h2>
<p>A Singly Linked List is a fundamental data structure where elements are stored in nodes, each containing data and a reference to the next node in the sequence. Unlike arrays, linked lists don't require contiguous memory allocation, making them ideal for dynamic data management.</p>
<h3 id="core-characteristics_1">Core Characteristics<a class="headerlink" href="#core-characteristics_1" title="Permanent link">&para;</a></h3>
<ul>
<li>🔄 Dynamic sizing (no fixed capacity)</li>
<li>📝 Sequential access pattern</li>
<li>🧩 Node-based structure</li>
<li>🎯 Efficient insertions and deletions at known positions</li>
<li>🔍 Linear time search operations</li>
</ul>
<h3 id="implementation-details_1">Implementation Details<a class="headerlink" href="#implementation-details_1" title="Permanent link">&para;</a></h3>
<h4 id="structure_1">Structure<a class="headerlink" href="#structure_1" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class LinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;
    private int size;

    private static class Node&lt;T&gt; {
        private T data;
        private Node&lt;T&gt; next;

        public Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
}</code></pre>
<h3 id="core-operations-time-complexities_1">🔧 Core Operations &amp; Time Complexities<a class="headerlink" href="#core-operations-time-complexities_1" title="Permanent link">&para;</a></h3>
<h4 id="adding-elements_1">Adding Elements<a class="headerlink" href="#adding-elements_1" title="Permanent link">&para;</a></h4>
<h5 id="addtofrontt-data_1">addToFront(T data)<a class="headerlink" href="#addtofrontt-data_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    newNode.next = head;
    head = newNode;
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Stack-like operations
-   ⚠️ Edge Cases:
    -   Null data
    -   First element (empty list)</p>
<h5 id="addtobackt-data_1">addToBack(T data)<a class="headerlink" href="#addtobackt-data_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);

    if (head == null) {
        head = newNode;
    } else {
        Node&lt;T&gt; current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 Best for: Queue-like operations
-   ⚠️ Edge Cases:
    -   Null data
    -   Empty list
    -   Consider tracking tail pointer for O(1) operation</p>
<h5 id="addatindexint-index-t-data">addAtIndex(int index, T data)<a class="headerlink" href="#addatindexint-index-t-data" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addAtIndex(int index, T data) {
    if (index &lt; 0 || index &gt; size) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    if (index == 0) {
        addToFront(data);
        return;
    }

    Node&lt;T&gt; current = head;
    for (int i = 0; i &lt; index - 1; i++) {
        current = current.next;
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    newNode.next = current.next;
    current.next = newNode;
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 Best for: Ordered insertions
-   ⚠️ Edge Cases:
    -   Invalid index
    -   Null data
    -   Front insertion</p>
<h4 id="removing-elements_1">Removing Elements<a class="headerlink" href="#removing-elements_1" title="Permanent link">&para;</a></h4>
<h5 id="removefromfront_1">removeFromFront()<a class="headerlink" href="#removefromfront_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    T data = head.data;
    head = head.next;
    size--;
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Stack operations
-   ⚠️ Edge Cases:
    -   Empty list
    -   Single element</p>
<h5 id="removefromback_1">removeFromBack()<a class="headerlink" href="#removefromback_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    if (size == 1) {
        T data = head.data;
        head = null;
        size--;
        return data;
    }

    Node&lt;T&gt; current = head;
    while (current.next.next != null) {
        current = current.next;
    }

    T data = current.next.data;
    current.next = null;
    size--;
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 Best for: Queue operations
-   ⚠️ Edge Cases:
    -   Empty list
    -   Single element
    -   Consider tail pointer optimization</p>
<h4 id="access-operations_1">Access Operations<a class="headerlink" href="#access-operations_1" title="Permanent link">&para;</a></h4>
<h5 id="getint-index_1">get(int index)<a class="headerlink" href="#getint-index_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }

    Node&lt;T&gt; current = head;
    for (int i = 0; i &lt; index; i++) {
        current = current.next;
    }
    return current.data;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 Best for: Sequential access
-   ⚠️ Edge Cases:
    -   Invalid index
    -   Empty list</p>
<h2 id="performance-summary_1">📊 Performance Summary<a class="headerlink" href="#performance-summary_1" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Traversal to index</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Get</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_1">💡 Best Practices<a class="headerlink" href="#best-practices_1" title="Permanent link">&para;</a></h3>
<h4 id="1-null-handling">1. Null Handling<a class="headerlink" href="#1-null-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private void validateNotNull(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
}</code></pre>
<h4 id="2-index-validation">2. Index Validation<a class="headerlink" href="#2-index-validation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private void validateIndex(int index, boolean isAdd) {
    int maxIndex = isAdd ? size : size - 1;
    if (index &lt; 0 || index &gt; maxIndex) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }
}</code></pre>
<h4 id="3-memory-management_1">3. Memory Management<a class="headerlink" href="#3-memory-management_1" title="Permanent link">&para;</a></h4>
<ul>
<li>Clear references when removing nodes</li>
<li>Consider garbage collection implications</li>
<li>Track size for O(1) length checks</li>
</ul>
<h3 id="common-pitfalls_1">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_1" title="Permanent link">&para;</a></h3>
<h4 id="1-losing-references">1. Losing References<a class="headerlink" href="#1-losing-references" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Lost reference to rest of list
head = new Node&lt;&gt;(data);  // Overwrites head reference

// CORRECT - Maintain list structure
Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
newNode.next = head;
head = newNode;</code></pre>
<h4 id="2-not-handling-edge-cases">2. Not Handling Edge Cases<a class="headerlink" href="#2-not-handling-edge-cases" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Assumes non-empty list
head.next = newNode;

// CORRECT - Handle empty list
if (head == null) {
    head = newNode;
} else {
    head.next = newNode;
}</code></pre>
<h4 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">&para;</a></h4>
<p><a href="https://youtu.be/-Yn5DU0_-lw?si=uyhzn4hUV9ZGr4zj">Singly Linked List Video</a></p>
<h1 id="doubly-linked-list">🔗 Doubly Linked List<a class="headerlink" href="#doubly-linked-list" title="Permanent link">&para;</a></h1>
<p>A Doubly Linked List is a bidirectional linked data structure where each node contains data and references to both the next and previous nodes. This bidirectional linking enables efficient traversal in both directions and simplifies certain operations compared to singly linked lists.</p>
<h3 id="core-characteristics_2">Core Characteristics<a class="headerlink" href="#core-characteristics_2" title="Permanent link">&para;</a></h3>
<ul>
<li>🔄 Bi-directional traversal</li>
<li>📝 Dynamic sizing</li>
<li>🎯 O(1) operations at both ends</li>
<li>🔍 Efficient insertions and deletions</li>
<li>💾 Higher memory usage per node</li>
</ul>
<h3 id="implementation-details_2">Implementation Details<a class="headerlink" href="#implementation-details_2" title="Permanent link">&para;</a></h3>
<h4 id="structure_2">Structure<a class="headerlink" href="#structure_2" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class DoublyLinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;
    private Node&lt;T&gt; tail;
    private int size;

    private static class Node&lt;T&gt; {
        private T data;
        private Node&lt;T&gt; next;
        private Node&lt;T&gt; previous;

        Node(T data) {
            this.data = data;
            this.next = null;
            this.previous = null;
        }

        Node(T data, Node&lt;T&gt; previous, Node&lt;T&gt; next) {
            this.data = data;
            this.previous = previous;
            this.next = next;
        }
    }
}</code></pre>
<h3 id="core-operations-time-complexities_2">🔧 Core Operations &amp; Time Complexities<a class="headerlink" href="#core-operations-time-complexities_2" title="Permanent link">&para;</a></h3>
<h4 id="adding-elements_2">Adding Elements<a class="headerlink" href="#adding-elements_2" title="Permanent link">&para;</a></h4>
<h5 id="addtofrontt-data_2">addToFront(T data)<a class="headerlink" href="#addtofrontt-data_2" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    head = new Node&lt;&gt;(data, null, head);
    if (size == 0) {
        tail = head;  // First node is both head and tail
    } else {
        head.next.previous = head;  // Link old head back to new head
    }
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Stack-like operations, maintaining recent items
-   ⚠️ Edge Cases:
    -   Empty list
    -   Null data
    -   Maintaining tail reference</p>
<h5 id="addtobackt-data_2">addToBack(T data)<a class="headerlink" href="#addtobackt-data_2" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, tail, null);
    if (size == 0) {
        head = newNode;
    } else {
        tail.next = newNode;
    }
    tail = newNode;
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Queue-like operations
-   ⚠️ Edge Cases:
    -   Empty list
    -   Null data
    -   Maintaining head reference</p>
<h5 id="addatindexint-index-t-data_1">addAtIndex(int index, T data)<a class="headerlink" href="#addatindexint-index-t-data_1" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addAtIndex(int index, T data) {
    if (index &lt; 0 || index &gt; size) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    if (index == 0) {
        addToFront(data);
        return;
    }
    if (index == size) {
        addToBack(data);
        return;
    }

    // Choose optimal traversal direction
    Node&lt;T&gt; current;
    if (index &lt; size / 2) {
        // Start from head
        current = head;
        for (int i = 0; i &lt; index - 1; i++) {
            current = current.next;
        }
    } else {
        // Start from tail
        current = tail;
        for (int i = size - 1; i &gt; index; i--) {
            current = current.previous;
        }
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, current, current.next);
    current.next.previous = newNode;
    current.next = newNode;
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💡 Optimization: Chooses optimal traversal direction
-   ⚠️ Edge Cases:
    -   Index bounds
    -   Null data
    -   Front/back insertions</p>
<h4 id="remove-elements">Remove Elements<a class="headerlink" href="#remove-elements" title="Permanent link">&para;</a></h4>
<h5 id="removefromfront_2">removeFromFront()<a class="headerlink" href="#removefromfront_2" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    T data = head.data;
    head = head.next;
    size--;

    if (size == 0) {
        tail = null;
    } else {
        head.previous = null;
    }

    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Stack operations
-   ⚠️ Edge Cases:
    -   Empty list
    -   Single element
    -   Maintaining tail reference</p>
<h5 id="removefromback_2">removeFromBack()<a class="headerlink" href="#removefromback_2" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    T data = tail.data;
    tail = tail.previous;
    size--;

    if (size == 0) {
        head = null;
    } else {
        tail.next = null;
    }

    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 Best for: Queue operations
-   ⚠️ Edge Cases:
    -   Empty list
    -   Single element
    -   Maintaining head reference</p>
<h4 id="access-operations_2">Access Operations<a class="headerlink" href="#access-operations_2" title="Permanent link">&para;</a></h4>
<h5 id="getint-index_2">get(int index)<a class="headerlink" href="#getint-index_2" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
    }

    Node&lt;T&gt; current;
    if (index &lt; size / 2) {
        current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.next;
        }
    } else {
        current = tail;
        for (int i = size - 1; i &gt; index; i--) {
            current = current.previous;
        }
    }
    return current.data;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💡 Optimization: Bi-directional traversal
-   ⚠️ Edge Cases:
    -   Invalid index
    -   Empty list</p>
<h2 id="performance-summary_2">📊 Performance Summary<a class="headerlink" href="#performance-summary_2" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(1)</td>
<td>Constant time with tail</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Optimal traversal direction</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(1)</td>
<td>Constant time with tail</td>
</tr>
<tr>
<td>Get</td>
<td>O(n)</td>
<td>Optimal traversal direction</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_2">💡 Best Practices<a class="headerlink" href="#best-practices_2" title="Permanent link">&para;</a></h3>
<h4 id="1-bi-directional-link-maintenance">1. Bi-directional Link Maintenance<a class="headerlink" href="#1-bi-directional-link-maintenance" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always update both next and previous references
newNode.next = current.next;
newNode.previous = current;
current.next.previous = newNode;
current.next = newNode;</code></pre>
<h4 id="2-headtail-management">2. Head/Tail Management<a class="headerlink" href="#2-headtail-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// For single element
if (size == 1) {
    head = tail = null;
} else {
    // Update references appropriately
}</code></pre>
<h4 id="3-traversal-optimization">3. Traversal Optimization<a class="headerlink" href="#3-traversal-optimization" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Choose optimal direction based on index
if (index &lt; size / 2) {
    traverseFromHead();
} else {
    traverseFromTail();
}</code></pre>
<h3 id="common-pitfalls_2">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_2" title="Permanent link">&para;</a></h3>
<h4 id="1-incomplete-link-updates">1. Incomplete Link Updates<a class="headerlink" href="#1-incomplete-link-updates" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Only updating one direction
current.next = newNode;

// CORRECT - Update both directions
current.next = newNode;
newNode.previous = current;</code></pre>
<h4 id="2-memory-leaks">2. Memory Leaks<a class="headerlink" href="#2-memory-leaks" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Leaving dangling references
head = head.next;

// CORRECT - Clear all references
T data = head.data;
Node&lt;T&gt; newHead = head.next;
head.next = null;  // Clear reference
if (newHead != null) {
    newHead.previous = null;
}
head = newHead;</code></pre>
<h4 id="references_2">References<a class="headerlink" href="#references_2" title="Permanent link">&para;</a></h4>
<p><a href="https://youtu.be/m-8ZBO2ywaU?si=c7-K9iDSFlmzCuD0">Doubly Linked List Video</a></p>
<h1 id="circular-singly-linked-list">🔄 Circular Singly Linked List<a class="headerlink" href="#circular-singly-linked-list" title="Permanent link">&para;</a></h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/4Ns3vDv9/temp-Image-PUv-Kxt.avif" /></p>
<p>A Circular Singly Linked List is a variant of linked lists where the last node points back to the first node, creating a circle. This structure is particularly useful when I need continuous traversal or cyclic operations, like round-robin scheduling.</p>
<h3 id="core-characteristics_3">Core Characteristics<a class="headerlink" href="#core-characteristics_3" title="Permanent link">&para;</a></h3>
<ul>
<li>🔄 Last node connects to first node</li>
<li>📝 Sequential access pattern</li>
<li>🎯 No null references</li>
<li>🔍 Continuous traversal capability</li>
<li>💫 Efficient for cyclic operations</li>
</ul>
<h3 id="implementation-details_3">Implementation Details<a class="headerlink" href="#implementation-details_3" title="Permanent link">&para;</a></h3>
<h4 id="structure_3">Structure<a class="headerlink" href="#structure_3" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public class CircularLinkedList&lt;T&gt; {
    private Node&lt;T&gt; tail;  // Points to last node
    private int size;

    private static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
}</code></pre>
💭 Why track tail instead of head?</p>
<ul>
<li>O(1) insertions at both ends</li>
<li>Easy access to both first and last nodes</li>
<li>More efficient for common operations</li>
</ul>
<h3 id="core-operations">🔧 Core Operations<a class="headerlink" href="#core-operations" title="Permanent link">&para;</a></h3>
<h4 id="adding-elements_3">Adding Elements<a class="headerlink" href="#adding-elements_3" title="Permanent link">&para;</a></h4>
<h5 id="addingtofrontt-data">addingToFront(T data)<a class="headerlink" href="#addingtofrontt-data" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    if (isEmpty()) {
        newNode.next = newNode;  // Points to itself
        tail = newNode;
    } else {
        newNode.next = tail.next;  // Point to old first node
        tail.next = newNode;       // Update tail's next to new node
    }
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💡 Important: Maintain circular nature
-   ⚠️ Edge Cases: Empty list handling</p>
<h5 id="addtobackt-data_3">addToBack(T data)<a class="headerlink" href="#addtobackt-data_3" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    if (isEmpty()) {
        newNode.next = newNode;
    } else {
        newNode.next = tail.next;  // Point to first node
        tail.next = newNode;       // Update tail's next
    }
    tail = newNode;  // Update tail to new node
    size++;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💡 Key Point: Tail reference makes this efficient
-   ⚠️ Edge Cases: Empty list, single element</p>
<h4 id="removing-elements_2">Removing Elements<a class="headerlink" href="#removing-elements_2" title="Permanent link">&para;</a></h4>
<h5 id="removefromfront_3">removeFromFront()<a class="headerlink" href="#removefromfront_3" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    T data = tail.next.data;  // Get first node's data
    if (size == 1) {
        tail = null;
    } else {
        tail.next = tail.next.next;  // Skip first node
    }
    size--;
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💡 Key Point: Maintain circular structure
-   ⚠️ Edge Cases: Empty list, single element</p>
<h5 id="removefromback_3">removeFromBack()<a class="headerlink" href="#removefromback_3" title="Permanent link">&para;</a></h5>
<p><pre class="highlight"><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }

    T data = tail.data;
    if (size == 1) {
        tail = null;
    } else {
        Node&lt;T&gt; current = tail.next;
        while (current.next != tail) {
            current = current.next;
        }
        current.next = tail.next;
        tail = current;
    }
    size--;
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💡 Note: Requires traversal to find second-to-last node
-   ⚠️ Edge Cases: Empty list, single element</p>
<h4 id="search-operation">Search Operation<a class="headerlink" href="#search-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public boolean contains(T data) {
    if (isEmpty() || data == null) {
        return false;
    }

    Node&lt;T&gt; current = tail.next;  // Start at first node
    do {
        if (data.equals(current.data)) {
            return true;
        }
        current = current.next;
    } while (current != tail.next);

    return false;
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💡 Important: Use do-while for circular traversal
-   ⚠️ Handle: Null data, empty list</p>
<h2 id="performance-summary_3">📊 Performance Summary<a class="headerlink" href="#performance-summary_3" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time with tail reference</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(1)</td>
<td>Constant time with tail reference</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time operation</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(n)</td>
<td>Requires traversal</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_3">💡 Best Practices<a class="headerlink" href="#best-practices_3" title="Permanent link">&para;</a></h3>
<h4 id="1-circular-reference-maintenance">1. Circular Reference Maintenance<a class="headerlink" href="#1-circular-reference-maintenance" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always ensure last node points to first
tail.next = tail.next.next;  // When removing
newNode.next = tail.next;    // When adding</code></pre>
<h4 id="2-empty-list-handling">2. Empty List Handling<a class="headerlink" href="#2-empty-list-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">if (isEmpty()) {
    // New node points to itself
    newNode.next = newNode;
    tail = newNode;
}</code></pre>
<h4 id="3-single-element-handling">3. Single Element Handling<a class="headerlink" href="#3-single-element-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">if (size == 1) {
    tail = null;  // For removal
    // OR
    tail = newNode;  // For insertion
}</code></pre>
<h3 id="common-pitfalls_3">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_3" title="Permanent link">&para;</a></h3>
<h4 id="1-infinite-loops">1. Infinite Loops<a class="headerlink" href="#1-infinite-loops" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - May loop forever
while (current.next != null) {  // Never true in circular list
    current = current.next;
}

// CORRECT
do {
    current = current.next;
} while (current != tail.next);</code></pre>
<h4 id="2-lost-circular-reference">2. Lost Circular Reference<a class="headerlink" href="#2-lost-circular-reference" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Loses circular structure
tail.next = newNode;

// CORRECT - Maintains circular structure
newNode.next = tail.next;
tail.next = newNode;</code></pre>
<h4 id="reference_1">Reference<a class="headerlink" href="#reference_1" title="Permanent link">&para;</a></h4>
<p><a href="https://youtube.com/playlist?list=PLBlnK6fEyqRjW4jK-CbshJuX20nc_3IaN&amp;si=X7n0-QAF54ZSsf0_">Circular Linked List Playlist</a></p>
<h1 id="stack">📚 Stack<a class="headerlink" href="#stack" title="Permanent link">&para;</a></h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/02Pp6Hbt/temp-Image-Ic-V6uh.avif" /></p>
<h3 id="introduction_1">Introduction<a class="headerlink" href="#introduction_1" title="Permanent link">&para;</a></h3>
<p>A Stack is a linear data structure that follows the LIFO (Last In First Out) principle. Like a stack of plates, elements are added and removed from the same end, called the top of the stack. This fundamental data structure is ideal for scenarios where we need strict order control over our operations.</p>
<h3 id="core-characteristics_4">Core Characteristics<a class="headerlink" href="#core-characteristics_4" title="Permanent link">&para;</a></h3>
<ul>
<li>📥 LIFO (Last In, First Out) principle</li>
<li>🎯 Single point of access (top)</li>
<li>📏 Dynamic sizing through array resizing</li>
<li>🔄 Ordered operations</li>
<li>⚡ Constant time operations (amortized)</li>
</ul>
<h3 id="implementation-details_4">Implementation Details<a class="headerlink" href="#implementation-details_4" title="Permanent link">&para;</a></h3>
<h4 id="structure_4">Structure<a class="headerlink" href="#structure_4" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class Stack&lt;T&gt; {
    // Default capacity when no size is specified
    private static final int DEFAULT_CAPACITY = 10;

    // Internal array to store elements
    private T[] backingArray;

    // Keep track of the next available position
    private int size;

    // Constructor with default capacity
    @SuppressWarnings("unchecked")
    public Stack() {
        backingArray = (T[]) new Object[DEFAULT_CAPACITY];
        size = 0;
    }

    // Constructor with specified initial capacity
    @SuppressWarnings("unchecked")
    public Stack(int initialCapacity) {
        if (initialCapacity &lt; 0) {
            throw new IllegalArgumentException("Initial capacity cannot be negative");
        }
        backingArray = (T[]) new Object[initialCapacity];
        size = 0;
    }
}</code></pre>
<h3 id="core-operations_1">🔧 Core Operations<a class="headerlink" href="#core-operations_1" title="Permanent link">&para;</a></h3>
<h4 id="push-operation">Push Operation<a class="headerlink" href="#push-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public void push(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Cannot push null data");
    }

    // Check if we need to resize
    if (size == backingArray.length) {
        resize();
    }

    // Add element and increment size
    backingArray[size++] = data;
}

@SuppressWarnings("unchecked")
private void resize() {
    T[] newArray = (T[]) new Object[backingArray.length * 2];
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[i];
    }
    backingArray = newArray;
}  </code></pre>
   ⏱️ Time Complexity: O(1) amortized
-   💭 When to Use: Adding new elements to the stack
-   ⚠️ Key Points:
    -   Handles null check
    -   Automatic resizing
    -   Maintains LIFO order</p>
<h4 id="pop-operation">Pop Operation<a class="headerlink" href="#pop-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T pop() {
    if (isEmpty()) {
        throw new NoSuchElementException("Cannot pop from empty stack");
    }

    // Retrieve element and decrement size
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference for garbage collection
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Removing and retrieving the most recently added element
-   ⚠️ Key Points:
    -   Checks for empty stack
    -   Cleans up references
    -   Maintains LIFO order</p>
<h4 id="peek-operation">Peek Operation<a class="headerlink" href="#peek-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException("Cannot peek empty stack");
    }
    return backingArray[size - 1];
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Viewing top element without removal
-   ⚠️ Key Points:
    -   No modification to stack
    -   Preserves state
    -   Checks for empty stack</p>
<h4 id="utility-operations">Utility Operations<a class="headerlink" href="#utility-operations" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Check if stack is empty
public boolean isEmpty() {
    return size == 0;
}

// Get current number of elements
public int size() {
    return size;
}

// Clear all elements
@SuppressWarnings("unchecked")
public void clear() {
    backingArray = (T[]) new Object[DEFAULT_CAPACITY];
    size = 0;
}</code></pre>
<h3 id="performance-summary_4">📊 Performance Summary<a class="headerlink" href="#performance-summary_4" title="Permanent link">&para;</a></h3>
<h2 id="performance-summary_5">📊 Performance Summary<a class="headerlink" href="#performance-summary_5" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Push</td>
<td>O(1)*</td>
<td>Amortized for resizing</td>
</tr>
<tr>
<td>Pop</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity accounts for occasional resizing operations</p>
<h3 id="best-practices_4">💡 Best Practices<a class="headerlink" href="#best-practices_4" title="Permanent link">&para;</a></h3>
<h4 id="1-memory-management">1. Memory Management<a class="headerlink" href="#1-memory-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always clear references when removing elements
public T pop() {
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference
    return data;
}</code></pre>
<h4 id="2-capacity-handling">2. Capacity Handling<a class="headerlink" href="#2-capacity-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Consider shrinking array when usage is low
private void shrinkIfNeeded() {
    if (size &gt; 0 &amp;&amp; size &lt; backingArray.length / 4) {
        resize(backingArray.length / 2);
    }
}</code></pre>
<h4 id="3-null-checking">3. Null Checking<a class="headerlink" href="#3-null-checking" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always validate input
public void push(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
    // push implementation
}</code></pre>
<h3 id="common-pitfalls_4">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_4" title="Permanent link">&para;</a></h3>
<h4 id="1-memory-leaks">1. Memory Leaks<a class="headerlink" href="#1-memory-leaks" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Memory leak
public T pop() {
    return backingArray[--size];  // Reference still held
}

// CORRECT - Clear reference
public T pop() {
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference
    return data;
}</code></pre>
<h4 id="2-bound-checking">2. Bound Checking<a class="headerlink" href="#2-bound-checking" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - No empty check
public T peek() {
    return backingArray[size - 1];  // Possible IndexOutOfBoundsException
}

// CORRECT - With empty check
public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException("Stack is empty");
    }
    return backingArray[size - 1];
}</code></pre>
<h3 id="common-use-cases_1">🎯 Common Use Cases<a class="headerlink" href="#common-use-cases_1" title="Permanent link">&para;</a></h3>
<h4 id="1-function-call-stack">1. Function Call Stack<a class="headerlink" href="#1-function-call-stack" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">Stack&lt;FunctionCall&gt; callStack = new Stack&lt;&gt;();
callStack.push(new FunctionCall("main"));
callStack.push(new FunctionCall("helper"));
// Current function is helper
callStack.pop();  // Return to main</code></pre>
<h4 id="2-expression-evaluation">2. Expression Evaluation<a class="headerlink" href="#2-expression-evaluation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">Stack&lt;Character&gt; parentheses = new Stack&lt;&gt;();
for (char c : expression.toCharArray()) {
    if (c == '(') {
        parentheses.push(c);
    } else if (c == ')') {
        if (!parentheses.isEmpty()) {
            parentheses.pop();
        } else {
            // Unmatched closing parenthesis
        }
    }
}</code></pre>
<h4 id="3-undoredo-operations">3. Undo/Redo Operations<a class="headerlink" href="#3-undoredo-operations" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();
Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();

void executeCommand(Command cmd) {
    cmd.execute();
    undoStack.push(cmd);
    redoStack.clear();  // Clear redo history
}</code></pre>
<h3 id="references_3">References<a class="headerlink" href="#references_3" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/L3ud3rXpIxA?si=m0pon3ja-WW28DON">Stack Introduction</a>
<a href="https://youtu.be/RAMqDLI6_1c?si=OAPRPe-3-4nyqBCK">Stack Implementation</a></p>
<h1 id="queue">🎯 Queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h1>
<p><img alt="Queues" src="https://i.postimg.cc/CMfGSBqV/temp-Imagee-Hk-FO3.avif" /></p>
<h3 id="introduction_2">Introduction<a class="headerlink" href="#introduction_2" title="Permanent link">&para;</a></h3>
<p>A Queue is a linear data structure following the FIFO (First In, First Out) principle. Using a circular array implementation allows for efficient space usage and constant time operations by reusing array spaces that have been dequeued.</p>
<h3 id="core-characteristics_5">Core Characteristics<a class="headerlink" href="#core-characteristics_5" title="Permanent link">&para;</a></h3>
<ul>
<li>📥 FIFO (First In, First Out) ordering</li>
<li>🔄 Circular array implementation</li>
<li>📏 Dynamic sizing</li>
<li>⚡ Constant time operations (amortized)</li>
<li>🎯 Space efficient</li>
</ul>
<h3 id="implementation-details_5">Implementation Details<a class="headerlink" href="#implementation-details_5" title="Permanent link">&para;</a></h3>
<h3 id="structure_5">Structure<a class="headerlink" href="#structure_5" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-java">public class Queue&lt;T&gt; {
    private T[] backingArray;
    private int front;      // Index of the front element
    private int size;       // Number of elements in queue
    private static final int INITIAL_CAPACITY = 10;

    @SuppressWarnings("unchecked")
    public Queue() {
        backingArray = (T[]) new Object[INITIAL_CAPACITY];
        front = 0;
        size = 0;
    }
}</code></pre>
<h3 id="core-operations_2">🔧 Core Operations<a class="headerlink" href="#core-operations_2" title="Permanent link">&para;</a></h3>
<h4 id="enqueue-operation">Enqueue Operation<a class="headerlink" href="#enqueue-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public void enqueue(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Cannot enqueue null data");
    }

    // Check if we need to resize
    if (size == backingArray.length) {
        resize();
    }

    // Calculate rear index using modulo for circular behavior
    int rear = (front + size) % backingArray.length;
    backingArray[rear] = data;
    size++;
}

@SuppressWarnings("unchecked")
private void resize() {
    T[] newArray = (T[]) new Object[backingArray.length * 2];
    // Copy elements in order, starting from front
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[(front + i) % backingArray.length];
    }
    backingArray = newArray;
    front = 0;  // Reset front to beginning of new array
}</code></pre>
-   ⏱️ Time Complexity: O(1) amortized
-   💭 When to Use: Adding elements to queue
-   ⚠️ Key Points:
    -   Handles null check
    -   Circular indexing with modulo
    -   Resizes when full</p>
<h4 id="dequeue-operation">Dequeue Operation<a class="headerlink" href="#dequeue-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T dequeue() {
    if (isEmpty()) {
        throw new NoSuchElementException("Queue is empty");
    }

    T data = backingArray[front];
    backingArray[front] = null;  // Help GC
    front = (front + 1) % backingArray.length;
    size--;
    return data;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Removing elements from front
-   ⚠️ Key Points:
    -   Handles empty queue
    -   Maintains circular structure
    -   Cleans up references</p>
<h4 id="peek-operation_1">Peek Operation<a class="headerlink" href="#peek-operation_1" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException("Queue is empty");
    }
    return backingArray[front];
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Examining front element
-   ⚠️ Key Points:
    -   No modification to queue
    -   Front element access</p>
<h4 id="utility-operations_1">Utility Operations<a class="headerlink" href="#utility-operations_1" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public boolean isEmpty() {
    return size == 0;
}

public int size() {
    return size;
}

@SuppressWarnings("unchecked")
public void clear() {
    backingArray = (T[]) new Object[INITIAL_CAPACITY];
    front = 0;
    size = 0;
}</code></pre>
<h3 id="performance-summary_6">📊 Performance Summary<a class="headerlink" href="#performance-summary_6" title="Permanent link">&para;</a></h3>
<h2 id="performance-summary_7">📊 Performance Summary<a class="headerlink" href="#performance-summary_7" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enqueue</td>
<td>O(1)*</td>
<td>Amortized for resizing</td>
</tr>
<tr>
<td>Dequeue</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity accounts for occasional resizing operations</p>
<h3 id="best-practices_5">💡 Best Practices<a class="headerlink" href="#best-practices_5" title="Permanent link">&para;</a></h3>
<h4 id="1-circular-index-calculation">1. Circular Index Calculation<a class="headerlink" href="#1-circular-index-calculation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Calculate next index with modulo
private int getNextIndex(int currentIndex) {
    return (currentIndex + 1) % backingArray.length;
}

// Calculate rear index
private int getRearIndex() {
    return (front + size) % backingArray.length;
}</code></pre>
<h4 id="2-resizing-strategy">2. Resizing Strategy<a class="headerlink" href="#2-resizing-strategy" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private void resize() {
    // Double size for amortized O(1)
    T[] newArray = (T[]) new Object[backingArray.length * 2];

    // Copy in order from front to rear
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[(front + i) % backingArray.length];
    }
    front = 0;  // Reset front after resize
    backingArray = newArray;
}</code></pre>
<h4 id="3-memory-management_2">3. Memory Management<a class="headerlink" href="#3-memory-management_2" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public T dequeue() {
    T data = backingArray[front];
    backingArray[front] = null;  // Clear reference
    front = (front + 1) % backingArray.length;
    size--;
    return data;
}</code></pre>
<h3 id="common-pitfalls_5">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_5" title="Permanent link">&para;</a></h3>
<h4 id="1-incorrect-circular-indexing">1. Incorrect Circular Indexing<a class="headerlink" href="#1-incorrect-circular-indexing" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - May cause overflow
rear = rear + 1;
if (rear == backingArray.length) rear = 0;

// CORRECT - Use modulo
rear = (rear + 1) % backingArray.length;</code></pre>
<h4 id="2-resizing-issues">2. Resizing Issues<a class="headerlink" href="#2-resizing-issues" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Doesn't maintain order
System.arraycopy(backingArray, 0, newArray, 0, backingArray.length);

// CORRECT - Maintains order from front
for (int i = 0; i &lt; size; i++) {
    newArray[i] = backingArray[(front + i) % backingArray.length];
}</code></pre>
<h3 id="common-use-cases_2">🎯 Common Use Cases<a class="headerlink" href="#common-use-cases_2" title="Permanent link">&para;</a></h3>
<h4 id="1-task-scheduling">1. Task Scheduling<a class="headerlink" href="#1-task-scheduling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">Queue&lt;Task&gt; taskQueue = new Queue&lt;&gt;();
taskQueue.enqueue(new Task("Process payment"));
taskQueue.enqueue(new Task("Send email"));

while (!taskQueue.isEmpty()) {
    Task nextTask = taskQueue.dequeue();
    processTask(nextTask);
}</code></pre>
<h4 id="2-bfs-implementation">2. BFS Implementation<a class="headerlink" href="#2-bfs-implementation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new Queue&lt;&gt;();
    queue.enqueue(root);

    while (!queue.isEmpty()) {
        Node current = queue.dequeue();
        for (Node child : current.getChildren()) {
            queue.enqueue(child);
        }
    }
}</code></pre>
<h4 id="3-buffer-implementation">3. Buffer Implementation<a class="headerlink" href="#3-buffer-implementation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class Buffer&lt;T&gt; {
    private Queue&lt;T&gt; queue = new Queue&lt;&gt;();
    private final int capacity;

    public void write(T data) {
        if (queue.size() &lt; capacity) {
            queue.enqueue(data);
        }
    }

    public T read() {
        return queue.isEmpty() ? null : queue.dequeue();
    }
}</code></pre>
<h3 id="references_4">References<a class="headerlink" href="#references_4" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/KxzhEQ-zpDc?si=kiGsG9eco3fsXaHR">Queue Introduction</a>
<a href="https://youtu.be/EoisnPvUkOA?si=qoqVyM2dcjYFMrVa">Queue Implementation</a></p>
<h1 id="tree-based-structures_1">🌳 Tree-Based Structures<a class="headerlink" href="#tree-based-structures_1" title="Permanent link">&para;</a></h1>
<h1 id="priority-queue">📊 Priority Queue<a class="headerlink" href="#priority-queue" title="Permanent link">&para;</a></h1>
<p><img alt="Priority Queue" src="https://i.postimg.cc/7ZSt6tJw/temp-Imagez-FB1-Iv.avif" /></p>
<h3 id="introduction_3">Introduction<a class="headerlink" href="#introduction_3" title="Permanent link">&para;</a></h3>
<p>A Priority Queue is an advanced queue that orders elements by their priority rather than insertion order. It's commonly implemented using a heap data structure, typically a min-heap or max-heap. In this implementation, we'll focus on a min-heap based priority queue where lower values have higher priority.</p>
<h3 id="core-characteristics_6">Core Characteristics<a class="headerlink" href="#core-characteristics_6" title="Permanent link">&para;</a></h3>
<ul>
<li>📈 Priority-based ordering</li>
<li>🌳 Heap-based implementation</li>
<li>📏 Dynamic sizing</li>
<li>🔄 Self-balancing structure</li>
<li>⚡ Logarithmic time operations</li>
</ul>
<h3 id="implementation-details_6">Implementation Details<a class="headerlink" href="#implementation-details_6" title="Permanent link">&para;</a></h3>
<h4 id="structure_6">Structure<a class="headerlink" href="#structure_6" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class PriorityQueue&lt;T extends Comparable&lt;? super T&gt;&gt; {
    // Initial capacity of the priority queue
    private static final int INITIAL_CAPACITY = 13;

    // Backing array for the heap
    private T[] backingArray;

    // Number of elements in the queue
    private int size;

    @SuppressWarnings("unchecked")
    public PriorityQueue() {
        backingArray = (T[]) new Comparable[INITIAL_CAPACITY];
        size = 0;
    }
}</code></pre>
<h3 id="core-operations_3">🔧 Core Operations<a class="headerlink" href="#core-operations_3" title="Permanent link">&para;</a></h3>
<h4 id="add-operation">Add Operation<a class="headerlink" href="#add-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Cannot add null data");
    }

    // Resize if necessary
    if (size + 1 == backingArray.length) {
        resize();
    }

    // Add element to the end and restore heap property
    backingArray[++size] = data;
    upHeap(size);
}

private void upHeap(int index) {
    while (index &gt; 1 &amp;&amp; 
           backingArray[index].compareTo(backingArray[index / 2]) &lt; 0) {
        swap(backingArray, index, index / 2);
        index = index / 2;
    }
}</code></pre>
-   ⏱️ Time Complexity: O(log n)
-   💭 When to Use: Adding new elements with priority
-   ⚠️ Key Points:
    -   Maintains heap property
    -   Handles resizing
    -   Null checking</p>
<h4 id="remove-operation">Remove Operation<a class="headerlink" href="#remove-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T remove() {
    if (isEmpty()) {
        throw new NoSuchElementException("Queue is empty");
    }

    T removed = backingArray[1];
    backingArray[1] = backingArray[size];
    backingArray[size--] = null;

    if (!isEmpty()) {
        downHeap(1);
    }

    return removed;
}

private void downHeap(int index) {
    while (2 * index &lt;= size) {
        int j = 2 * index;
        if (j &lt; size &amp;&amp; backingArray[j].compareTo(backingArray[j + 1]) &gt; 0) {
            j++;
        }
        if (backingArray[index].compareTo(backingArray[j]) &lt;= 0) {
            break;
        }
        swap(backingArray, index, j);
        index = j;
    }
}</code></pre>
-   ⏱️ Time Complexity: O(log n)
-   💭 When to Use: Removing highest priority element
-   ⚠️ Key Points:
    -   Maintains heap order
    -   Handles empty case
    -   Cleans references</p>
<h4 id="peek-operation_2">Peek Operation<a class="headerlink" href="#peek-operation_2" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException("Queue is empty");
    }
    return backingArray[1];
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Viewing highest priority element
-   ⚠️ Key Points:
    -   No modification to structure
    -   Empty check</p>
<h3 id="performance-summary_8">📊 Performance Summary<a class="headerlink" href="#performance-summary_8" title="Permanent link">&para;</a></h3>
<h2 id="performance-summary_9">📊 Performance Summary<a class="headerlink" href="#performance-summary_9" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add/Offer</td>
<td>O(log n)</td>
<td>Requires upheap</td>
</tr>
<tr>
<td>Remove/Poll</td>
<td>O(log n)</td>
<td>Requires downheap</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
<tr>
<td>### 💡 Best Practices</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 1. Maintain Heap Property</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">private void swap(T[] arr, int i, int j) {
    T temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

private int parent(int index) {
    return index / 2;
}

private int leftChild(int index) {
    return 2 * index;
}

private int rightChild(int index) {
    return 2 * index + 1;
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 2. Efficient Resizing</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">@SuppressWarnings("unchecked")
private void resize() {
    T[] newArray = (T[]) new Comparable[backingArray.length * 2];
    for (int i = 1; i &lt;= size; i++) {
        newArray[i] = backingArray[i];
    }
    backingArray = newArray;
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 3. Handle Special Cases</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">public boolean isEmpty() {
    return size == 0;
}

@SuppressWarnings("unchecked")
public void clear() {
    backingArray = (T[]) new Comparable[INITIAL_CAPACITY];
    size = 0;
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>### ⚠️ Common Pitfalls</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 1. Index Management</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">// WRONG - Using 0-based indexing
private int parent(int i) {
    return (i - 1) / 2;
}

// CORRECT - Using 1-based indexing
private int parent(int i) {
    return i / 2;
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 2. Comparator Consistency</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">// WRONG - Inconsistent comparison
if (a.someValue() &lt; b.someValue()) {
    swap(a, b);
}

// CORRECT - Use compareTo
if (a.compareTo(b) &lt; 0) {
    swap(a, b);
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>### 🎯 Common Use Cases</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 1. Task Scheduling</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">class Task implements Comparable&lt;Task&gt; {
    private int priority;
    private String description;

    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
}

PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;();
taskQueue.add(new Task(1, "High Priority"));
taskQueue.add(new Task(3, "Low Priority"));</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 2. Dijkstra's Algorithm</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; 
    Integer.compare(a.distance, b.distance));
pq.add(source);
while (!pq.isEmpty()) {
    Node current = pq.remove();
    // Process node
}</code></pre></td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 3. Event Processing</td>
<td></td>
<td></td>
</tr>
<tr>
<td><pre class="highlight"><code class="language-java">class Event implements Comparable&lt;Event&gt; {
    private long timestamp;

    @Override
    public int compareTo(Event other) {
        return Long.compare(this.timestamp, other.timestamp);
    }
}

PriorityQueue&lt;Event&gt; events = new PriorityQueue&lt;&gt;();
events.add(new Event(System.currentTimeMillis()));</code></pre></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="references_5">References<a class="headerlink" href="#references_5" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/wptevk0bshY?si=620-DcPMa14F0lL5">Priority Queue Introduction</a>
<a href="https://youtu.be/HCEr35qpawQ?si=V1_BJIdDTXqDzI3z">Priority Queue Min Heaps and Max Heaps</a>
<a href="https://youtu.be/QOJ-CmQiXko?si=MJCRzTB1yDV0qfcF">Priority Queue Adding Elements</a>
<a href="https://youtu.be/eVq8CmoC1x8?si=S9Lrx5MllIeqzrT-">Priority Queue Removing Elements</a></p>
<h1 id="binary-tree">🌳 Binary Tree<a class="headerlink" href="#binary-tree" title="Permanent link">&para;</a></h1>
<p><img alt="Binary Tree Router" src="https://i.postimg.cc/52SBdTL6/temp-Image-B78xzp.avif" /></p>
<h3 id="introduction_4">Introduction<a class="headerlink" href="#introduction_4" title="Permanent link">&para;</a></h3>
<p>A Binary Tree is a hierarchical, non-linear data structure where each node has at most two children, referred to as left child and right child. Unlike arrays or linked lists that store data sequentially, Binary Trees allow for representing hierarchical relationships between elements.</p>
<h3 id="core-characteristics_7">Core Characteristics<a class="headerlink" href="#core-characteristics_7" title="Permanent link">&para;</a></h3>
<ul>
<li>🌿 Each node has at most two children</li>
<li>🔝 Single root node</li>
<li>📊 Hierarchical structure</li>
<li>🔄 Recursive nature</li>
<li>🎯 Multiple traversal options</li>
</ul>
<h3 id="implementation-details_7">Implementation Details<a class="headerlink" href="#implementation-details_7" title="Permanent link">&para;</a></h3>
<h4 id="structure_7">Structure<a class="headerlink" href="#structure_7" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class BinaryTree&lt;T&gt; {
    private Node&lt;T&gt; root;
    private int size;

    private static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; left;
        Node&lt;T&gt; right;

        Node(T data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    public BinaryTree() {
        root = null;
        size = 0;
    }
}</code></pre>
<h3 id="core-operations_4">🔧 Core Operations<a class="headerlink" href="#core-operations_4" title="Permanent link">&para;</a></h3>
<h4 id="traversal-operations">Traversal Operations<a class="headerlink" href="#traversal-operations" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">// InOrder Traversal (Left, Root, Right)
public void inOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        inOrderTraversal(node.left);
        process(node.data);
        inOrderTraversal(node.right);
    }
}

// PreOrder Traversal (Root, Left, Right)
public void preOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        process(node.data);
        preOrderTraversal(node.left);
        preOrderTraversal(node.right);
    }
}

// PostOrder Traversal (Left, Right, Root)
public void postOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        postOrderTraversal(node.left);
        postOrderTraversal(node.right);
        process(node.data);
    }
}

// Level Order Traversal (BFS)
public void levelOrderTraversal() {
    if (root == null) return;

    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node&lt;T&gt; current = queue.poll();
        process(current.data);

        if (current.left != null) queue.offer(current.left);
        if (current.right != null) queue.offer(current.right);
    }
}</code></pre>
-   ⏱️ Time Complexity: O(n) for all traversals
-   💭 When to Use: Different traversal orders for different needs
-   ⚠️ Key Points: Each traversal visits all nodes exactly once</p>
<h4 id="insertion-operation">Insertion Operation<a class="headerlink" href="#insertion-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public void insert(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    if (root == null) {
        root = new Node&lt;&gt;(data);
        size++;
        return;
    }

    // Level-order insertion
    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node&lt;T&gt; current = queue.poll();

        if (current.left == null) {
            current.left = new Node&lt;&gt;(data);
            size++;
            return;
        } else {
            queue.offer(current.left);
        }

        if (current.right == null) {
            current.right = new Node&lt;&gt;(data);
            size++;
            return;
        } else {
            queue.offer(current.right);
        }
    }
}</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 When to Use: Adding new nodes to the tree</li>
<li>⚠️ Key Points: Level-order insertion maintains tree balance</li>
</ul>
<h4 id="search-operation_1">Search Operation<a class="headerlink" href="#search-operation_1" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public boolean contains(T data) {
    return searchHelper(root, data);
}

private boolean searchHelper(Node&lt;T&gt; node, T data) {
    if (node == null) return false;

    if (node.data.equals(data)) return true;

    return searchHelper(node.left, data) || 
           searchHelper(node.right, data);
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 When to Use: Finding elements in the tree
-   ⚠️ Key Points: Must traverse potentially entire tree</p>
<h3 id="performance-summary_10">📊 Performance Summary<a class="headerlink" href="#performance-summary_10" title="Permanent link">&para;</a></h3>
<h2 id="performance-summary_11">📊 Performance Summary<a class="headerlink" href="#performance-summary_11" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insertion</td>
<td>O(n)</td>
<td>Level-order insertion</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>Worst case traversal</td>
</tr>
<tr>
<td>Deletion</td>
<td>O(n)</td>
<td>Find and reorganize</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>All traversal types</td>
</tr>
<tr>
<td>Height</td>
<td>O(n)</td>
<td>Must visit all nodes</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Maintained variable</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Check root null</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_6">💡 Best Practices<a class="headerlink" href="#best-practices_6" title="Permanent link">&para;</a></h3>
<h4 id="1-proper-node-handling">1. Proper Node Handling<a class="headerlink" href="#1-proper-node-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private void validate(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
}</code></pre>
<h4 id="2-traversal-selection">2. Traversal Selection<a class="headerlink" href="#2-traversal-selection" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Use appropriate traversal for the task
// InOrder: Sorted sequence in BST
// PreOrder: Copy/serialize tree
// PostOrder: Delete tree/calculate size
// LevelOrder: Level-based processing</code></pre>
<h4 id="3-memory-management_3">3. Memory Management<a class="headerlink" href="#3-memory-management_3" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public void clear() {
    root = null;  // Allow GC to clean up
    size = 0;
}</code></pre>
<h3 id="common-pitfalls_6">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_6" title="Permanent link">&para;</a></h3>
<h4 id="1-not-handling-null-cases">1. Not Handling Null Cases<a class="headerlink" href="#1-not-handling-null-cases" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG
public void process(Node&lt;T&gt; node) {
    process(node.left);  // NPE if node is null
}  

// CORRECT
public void process(Node&lt;T&gt; node) {
    if (node == null) return;
    process(node.left);
}</code></pre>
<h4 id="2-improper-traversal-choice">2. Improper Traversal Choice<a class="headerlink" href="#2-improper-traversal-choice" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Using inOrder for level-based processing
// CORRECT - Use levelOrder for level-based operations
public void printLevelByLevel() {
    levelOrderTraversal();
}</code></pre>
<h3 id="common-use-cases_3">🎯 Common Use Cases<a class="headerlink" href="#common-use-cases_3" title="Permanent link">&para;</a></h3>
<h4 id="1-file-system-representation">1. File System Representation<a class="headerlink" href="#1-file-system-representation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">class FileNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isDirectory;
    // File system specific operations
}</code></pre>
<h4 id="2-expression-trees">2. Expression Trees<a class="headerlink" href="#2-expression-trees" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">class ExpressionNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isOperator;
    public double evaluate() {
        // Evaluation logic
    }
}</code></pre>
<h4 id="3-decision-trees">3. Decision Trees<a class="headerlink" href="#3-decision-trees" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">class DecisionNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isLeaf;
    public T decide(Input input) {
        // Decision logic
    }
}</code></pre>
<h3 id="references_6">References<a class="headerlink" href="#references_6" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/H5JubkIy_p8?si=0SZXcikEuU6108b1">Binary Tree Data Structure</a></p>
<h1 id="binary-search-tree">🌳 Binary Search Tree<a class="headerlink" href="#binary-search-tree" title="Permanent link">&para;</a></h1>
<p><img alt="Binary Search Tree" src="https://i.postimg.cc/sDrLyFbr/temp-Image-Tazx-Mr.avif" /></p>
<h3 id="introduction_5">Introduction<a class="headerlink" href="#introduction_5" title="Permanent link">&para;</a></h3>
<p>A Binary Search Tree (BST) is a binary tree that maintains an ordering property: for each node, all elements in its left subtree are less than the node's value, and all elements in its right subtree are greater. This property makes BSTs efficient for searching, inserting, and deleting elements.</p>
<h3 id="core-characteristics_8">Core Characteristics<a class="headerlink" href="#core-characteristics_8" title="Permanent link">&para;</a></h3>
<ul>
<li>📊 Ordered structure</li>
<li>🔍 Efficient searching</li>
<li>🎯 Dynamic operations</li>
<li>🌿 Binary tree properties</li>
<li>⚖️ Balance affects performance</li>
</ul>
<h3 id="implementation-details_8">Implementation Details<a class="headerlink" href="#implementation-details_8" title="Permanent link">&para;</a></h3>
<h4 id="structure_8">Structure<a class="headerlink" href="#structure_8" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class BST&lt;T extends Comparable&lt;? super T&gt;&gt; {
    private BSTNode&lt;T&gt; root;
    private int size;

    private static class BSTNode&lt;T&gt; {
        T data;
        BSTNode&lt;T&gt; left;
        BSTNode&lt;T&gt; right;

        BSTNode(T data) {
            this.data = data;
            left = null;
            right = null;
        }
    }
}</code></pre>
<h3 id="core-operations_5">🔧 Core Operations<a class="headerlink" href="#core-operations_5" title="Permanent link">&para;</a></h3>
<h4 id="add-operation_1">Add Operation<a class="headerlink" href="#add-operation_1" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
    root = addHelper(data, root);
}

private BSTNode&lt;T&gt; addHelper(T data, BSTNode&lt;T&gt; node) {
    if (node == null) {
        size++;
        return new BSTNode&lt;&gt;(data);
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = addHelper(data, node.left);
    } else if (compare &gt; 0) {
        node.right = addHelper(data, node.right);
    }
    return node;
}</code></pre>
-   ⏱️ Time Complexity: O(log n) average, O(n) worst case
-   💭 When to Use: Inserting new elements while maintaining order
-   ⚠️ Key Points:
    -   Maintains BST property
    -   Handles duplicates
    -   Recursive implementation</p>
<h4 id="remove-operation_1">Remove Operation<a class="headerlink" href="#remove-operation_1" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T remove(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    BSTNode&lt;T&gt; dummy = new BSTNode&lt;&gt;(null);
    root = removeHelper(data, root, dummy);
    return dummy.data;
}

private BSTNode&lt;T&gt; removeHelper(T data, BSTNode&lt;T&gt; node, BSTNode&lt;T&gt; dummy) {
    if (node == null) {
        throw new NoSuchElementException("Data not found");
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = removeHelper(data, node.left, dummy);
    } else if (compare &gt; 0) {
        node.right = removeHelper(data, node.right, dummy);
    } else {
        dummy.data = node.data;
        size--;

        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        } else {
            BSTNode&lt;T&gt; successor = findSuccessor(node.right);
            node.data = successor.data;
            node.right = removeHelper(successor.data, node.right, dummy);
        }
    }
    return node;
}</code></pre>
-   ⏱️ Time Complexity: O(log n) average, O(n) worst case
-   💭 When to Use: Removing elements while maintaining order
-   ⚠️ Key Points:
    -   Three cases: leaf, one child, two children
    -   Uses successor for two-child case
    -   Maintains BST property</p>
<h4 id="search-operation_2">Search Operation<a class="headerlink" href="#search-operation_2" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public T get(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }

    BSTNode&lt;T&gt; node = getHelper(data, root);
    if (node == null) {
        throw new NoSuchElementException("Data not found");
    }
    return node.data;
}

private BSTNode&lt;T&gt; getHelper(T data, BSTNode&lt;T&gt; node) {
    if (node == null) {
        return null;
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        return getHelper(data, node.left);
    } else if (compare &gt; 0) {
        return getHelper(data, node.right);
    }
    return node;
}</code></pre>
-   ⏱️ Time Complexity: O(log n) average, O(n) worst case
-   💭 When to Use: Finding elements in the tree
-   ⚠️ Key Points:
    -   Uses comparisons for direction
    -   Returns stored data
    -   Handles not found case</p>
<h3 id="traversal-operations_1">Traversal Operations<a class="headerlink" href="#traversal-operations_1" title="Permanent link">&para;</a></h3>
<p><pre class="highlight"><code class="language-java">// In-order traversal (sorted order)
public List&lt;T&gt; inorder() {
    List&lt;T&gt; result = new ArrayList&lt;&gt;();
    inorderHelper(root, result);
    return result;
}

private void inorderHelper(BSTNode&lt;T&gt; node, List&lt;T&gt; result) {
    if (node != null) {
        inorderHelper(node.left, result);
        result.add(node.data);
        inorderHelper(node.right, result);
    }
}</code></pre>
-   ⏱️ Time Complexity: O(n)
-   💭 When to Use: Getting elements in sorted order
-   ⚠️ Key Points:
    -   In-order gives sorted sequence
    -   Pre-order for copying tree
    -   Post-order for deletion</p>
<h2 id="performance-summary_12">📊 Performance Summary<a class="headerlink" href="#performance-summary_12" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Remove</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Search</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Visits all nodes</td>
</tr>
<tr>
<td>Height</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Cached value</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Maintained count</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_7">💡 Best Practices<a class="headerlink" href="#best-practices_7" title="Permanent link">&para;</a></h3>
<h4 id="1-balance-maintenance">1. Balance Maintenance<a class="headerlink" href="#1-balance-maintenance" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-jav">// Consider using self-balancing variants for better performance guarantees
// AVL or Red-Black trees for automatic balancing</code></pre>
<h4 id="2-comparison-handling">2. Comparison Handling<a class="headerlink" href="#2-comparison-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Use compareTo consistently
int compare = data.compareTo(node.data);
if (compare &lt; 0) {
    // Go left
} else if (compare &gt; 0) {
    // Go right
}</code></pre>
<h4 id="3-null-handling">3. Null Handling<a class="headerlink" href="#3-null-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always validate input
if (data == null) {
    throw new IllegalArgumentException("Data cannot be null");
}</code></pre>
<h3 id="common-pitfalls_7">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_7" title="Permanent link">&para;</a></h3>
<h4 id="1-unbalanced-trees">1. Unbalanced Trees<a class="headerlink" href="#1-unbalanced-trees" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Adding sorted data creates linear structure
bst.add(1);
bst.add(2);
bst.add(3);  // Creates right-skewed tree

// BETTER - Balance the tree or use self-balancing variant</code></pre>
<h4 id="2-memory-management">2. Memory Management<a class="headerlink" href="#2-memory-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Memory leak in remove
node = null;  // Only removes reference

// CORRECT - Clean all references
node.left = null;
node.right = null;
node.data = null;
node = null;</code></pre>
<h3 id="common-use-cases_4">🎯 Common Use Cases<a class="headerlink" href="#common-use-cases_4" title="Permanent link">&para;</a></h3>
<h4 id="1-dictionary-implementation">1. Dictionary Implementation<a class="headerlink" href="#1-dictionary-implementation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">BST&lt;String&gt; dictionary = new BST&lt;&gt;();
dictionary.add("apple");
dictionary.add("banana");
// Fast lookups: O(log n) average</code></pre>
<h4 id="2-priority-management">2. Priority Management<a class="headerlink" href="#2-priority-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">BST&lt;Task&gt; tasks = new BST&lt;&gt;();
tasks.add(new Task(1, "High Priority"));
tasks.add(new Task(2, "Medium Priority"));
// Natural ordering of tasks</code></pre>
<h4 id="3-symbol-tables">3. Symbol Tables<a class="headerlink" href="#3-symbol-tables" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">BST&lt;Symbol&gt; symbolTable = new BST&lt;&gt;();
symbolTable.add(new Symbol("x", 10));
symbolTable.add(new Symbol("y", 20));
// Efficient symbol lookup</code></pre>
<h3 id="references_7">References<a class="headerlink" href="#references_7" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/pYT9F8_LFTM?si=llySEAWqBX3jJ_tN">Binary Search Trees</a>
<a href="https://youtu.be/JfSdGQdAzq8?si=EKKPhNxENwZlQWNB">Binary Search Tree Introduction</a>
<a href="https://youtu.be/LwpLXm3eb6A?si=xvpTFxTCcW1JY55R">Binary Search Tree Insertion</a>
<a href="https://youtu.be/8K7EO7s_iFE?si=cm7yYT1m76rhtzLn">Binary Search Tree Removal</a>
<a href="https://youtu.be/k7GkEbECZK0?si=ULXRc1mnU2cfijtM">Binary Search Tree Traversal</a></p>
<h1 id="advanced-tree-based-structures_1">🌲 Advanced Tree-Based Structures<a class="headerlink" href="#advanced-tree-based-structures_1" title="Permanent link">&para;</a></h1>
<h1 id="avl-trees">🌳 AVL Trees<a class="headerlink" href="#avl-trees" title="Permanent link">&para;</a></h1>
<p><img alt="AVL Tree" src="https://i.postimg.cc/ZKHM6RMf/temp-Image-Ie-Nfq-P.avif" /></p>
<p>An AVL Tree is a self-balancing bin tree where the heights of the left and right subtrees of any node differ by at most one. This balance ot ensures that the tree remains approximately balanced during insertion deletions, maintaining O(log n) time complexity for all operations.</p>
<h3 id="core-characteristics_9">Core Characteristics<a class="headerlink" href="#core-characteristics_9" title="Permanent link">&para;</a></h3>
<ul>
<li>🔄 Self-balancing mechanism</li>
<li>📏 Height tracking</li>
<li>⚖️ Balance factor management</li>
<li>🎯 BST properties maintained</li>
<li>🔍 Guaranteed O(log n) operations</li>
</ul>
<h3 id="implementation-details_9">Implementation Details<a class="headerlink" href="#implementation-details_9" title="Permanent link">&para;</a></h3>
<h4 id="structure_9">Structure<a class="headerlink" href="#structure_9" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class AVLTree&lt;T extends Comparable&lt;? super T&gt;&gt; {
     AVLNode&lt;T&gt; root;
    private int size;

    private static class AVLNode&lt;T&gt; {
     T data;
        AVLNode&lt;T&gt; left;
     AVLNode&lt;T&gt; right;
     int height;
     int balanceFactor;
            AVLNode(T data) {
            this.data = data;
            this.height = 0;
            this.balanceFactor = 0;
        }
    }
}</code></pre>
<h3 id="node-properties">Node Properties<a class="headerlink" href="#node-properties" title="Permanent link">&para;</a></h3>
<ol>
<li><code>data</code>: Stores the actual value/element</li>
<li><code>left</code>: Reference to left child n lement etil ri clrenco right child node</li>
<li><code>height</code>: Distance to the furthest leaf in its subtree</li>
<li><code>balanceFactor</code>: Difference between left and right subtree heights</li>
</ol>
<h3 id="core-operations_6">🔧 Core Operations<a class="headerlink" href="#core-operations_6" title="Permanent link">&para;</a></h3>
<p>Balance Helper Methods
<pre class="highlight"><code class="language-java">private int height(AVLNode&lt;T&gt; node) {
    return node == null ? -1 : node.height;
}

private void updateHeightAndBF(AVLNode&lt;T&gt; node) {
    int leftHeight = height(node.left);
    int rightHeight = height(node.right);
    node.height = Math.max(leftHeight, rightHeight) + 1;
    node.balanceFactor = leftHeight - rightHeight;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: After any structural changes
-   ⚠️ Key Points:
    -   Height of null node is -1
    -   Balance factor = leftHeight - rightHeight
    -   Must update after rotations</p>
<h4 id="rotation-operations">Rotation Operations<a class="headerlink" href="#rotation-operations" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">private AVLNode&lt;T&gt; rotateLeft(AVLNode&lt;T&gt; node) {
    AVLNode&lt;T&gt; newRoot = node.right;
    node.right = newRoot.left;
    newRoot.left = node;

    updateHeightAndBF(node);
    updateHeightAndBF(newRoot);
    return newRoot;
}

private AVLNode&lt;T&gt; rotateRight(AVLNode&lt;T&gt; node) {
    AVLNode&lt;T&gt; newRoot = node.left;
    node.left = newRoot.right;
    newRoot.right = node;

    updateHeightAndBF(node);
    updateHeightAndBF(newRoot);
    return newRoot;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: Rebalancing after insertions/deletions
-   ⚠️ Key Points:
    -   Update heights after rotation
    -   Maintain BST properties
    -   Return new root of subtree</p>
<h4 id="balance-operation">Balance Operation<a class="headerlink" href="#balance-operation" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">private AVLNode&lt;T&gt; balance(AVLNode&lt;T&gt; node) {
    updateHeightAndBF(node);

    if (node.balanceFactor &lt; -1) {  // Right heavy
        if (node.right.balanceFactor &gt; 0) {  // Right-Left case
            node.right = rotateRight(node.right);
        }
        return rotateLeft(node);
    } else if (node.balanceFactor &gt; 1) {  // Left heavy
        if (node.left.balanceFactor &lt; 0) {  // Left-Right case
            node.left = rotateLeft(node.left);
        }
        return rotateRight(node);
    }

    return node;
}</code></pre>
-   ⏱️ Time Complexity: O(1)
-   💭 When to Use: After modifications that might affect balance
-   ⚠️ Key Points:
    -   Handles all four rotation cases
    -   Updates height before checking balance
    -   Returns balanced subtree root</p>
<h4 id="add-operation_2">Add Operation<a class="headerlink" href="#add-operation_2" title="Permanent link">&para;</a></h4>
<p><pre class="highlight"><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Data cannot be null");
    }
    root = addHelper(data, root);
}

private AVLNode&lt;T&gt; addHelper(T data, AVLNode&lt;T&gt; node) {
    if (node == null) {
        size++;
        return new AVLNode&lt;&gt;(data);
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = addHelper(data, node.left);
    } else if (compare &gt; 0) {
        node.right = addHelper(data, node.right);
    }

    return balance(node);
}</code></pre>
-   ⏱️ Time Complexity: O(log n)
-   💭 When to Use: Adding new elements
-   ⚠️ Key Points:
    -   BST properties maintained
    -   Auto-balancing after insertion
    -   Uses pointer reinforcement</p>
<h3 id="performance-summary_13">📊 Performance Summary<a class="headerlink" href="#performance-summary_13" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Includes rebalancing</td>
</tr>
<tr>
<td>Remove</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Includes rebalancing</td>
</tr>
<tr>
<td>Search</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Same as BST</td>
</tr>
<tr>
<td>Rotation</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Height updates included</td>
</tr>
<tr>
<td>Balance</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Maximum two rotations</td>
</tr>
<tr>
<td>Height</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Cached in node</td>
</tr>
</tbody>
</table>
<h3 id="visualization-of-rotations">🎯 Visualization of Rotations<a class="headerlink" href="#visualization-of-rotations" title="Permanent link">&para;</a></h3>
<h4 id="left-rotation">Left Rotation<a class="headerlink" href="#left-rotation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>Before:       After:
  A            B
   \          / \
    B   =&gt;   A   C
     \
      C</code></pre>
<h4 id="right-rotation">Right Rotation<a class="headerlink" href="#right-rotation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>Before:       After:
    C          B
   /          / \
  B    =&gt;    A   C
 /
A</code></pre>
<h4 id="double-rotation-left-right">Double Rotation (Left-Right)<a class="headerlink" href="#double-rotation-left-right" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>Before:       Middle:        After:
  C            C              B
 /            /             /  \
A     =&gt;     B     =&gt;     A    C
 \          /
  B        A</code></pre>
<h4 id="double-rotation-right-left">Double Rotation (Right-Left)<a class="headerlink" href="#double-rotation-right-left" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code>Before:         Middle:         After:
    A             A               B
     \             \            /  \
      C     =&gt;      B    =&gt;    A    C
     /               \
    B                 C</code></pre>
<h3 id="best-practices_8">💡 Best Practices<a class="headerlink" href="#best-practices_8" title="Permanent link">&para;</a></h3>
<h4 id="1-height-management">1. Height Management<a class="headerlink" href="#1-height-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always update heights bottom-up
updateHeightAndBF(node);
if (node.parent != null) {
    updateHeightAndBF(node.parent);
}</code></pre>
<h4 id="2-balance-factor-checks">2. Balance Factor Checks<a class="headerlink" href="#2-balance-factor-checks" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Check both balance factor and height
if (Math.abs(node.balanceFactor) &gt; 1) {
    return balance(node);
}</code></pre>
<h4 id="3-rotation-selection">3. Rotation Selection<a class="headerlink" href="#3-rotation-selection" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Clear conditions for rotation type
if (node.balanceFactor &gt; 1) {  // Left heavy
    if (node.left.balanceFactor &lt; 0) {  // Left-Right case
        node.left = rotateLeft(node.left);
    }
    return rotateRight(node);
}</code></pre>
<h3 id="common-pitfalls_8">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_8" title="Permanent link">&para;</a></h3>
<h4 id="1-incorrect-height-updates">1. Incorrect Height Updates<a class="headerlink" href="#1-incorrect-height-updates" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Not updating ancestor heights
node = balance(node);

// CORRECT - Update all affected nodes
node = balance(node);
updateAncestorHeights(node);</code></pre>
<h4 id="2-balance-factor-calculation">2. Balance Factor Calculation<a class="headerlink" href="#2-balance-factor-calculation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG - Swapped height difference
balanceFactor = rightHeight - leftHeight;

// CORRECT
balanceFactor = leftHeight - rightHeight;</code></pre>
<h3 id="references_8">References<a class="headerlink" href="#references_8" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/zP2xbKerIds?si=OQI-Kxgsr9iQKsy-">AVL Trees Simply Explained</a>
<a href="https://youtu.be/qvZGUFHWChY?si=zfLMb0HG7IFSS5gC">Red-Black Trees in 4 min</a>
<a href="https://youtu.be/tPoG8XcnPO0?si=UFsoKQnf9dco_rsX">2-3 Trees</a>
<a href="https://youtu.be/BK5x7IUTIyU?si=8ityNI3gyNnkO68f">K-D Trees</a>
<a href="https://en.wikipedia.org/wiki/M-ary_tree">M-Ary Trees</a></p>
<h1 id="hash-based-structures_1">🎯 Hash-Based Structures<a class="headerlink" href="#hash-based-structures_1" title="Permanent link">&para;</a></h1>
<h1 id="hashmaps">#️⃣ HashMaps<a class="headerlink" href="#hashmaps" title="Permanent link">&para;</a></h1>
<p><img alt="HashMap" src="https://i.postimg.cc/YCcYzBTV/temp-Image-TBGZv5.avif" /></p>
<p>A HashMap is a data structure that implements the Map ADT, storing key-value pairs for O(1) average-case access time. This implementation uses separate chaining for collision resolution, where collisions are handled by maintaining linked lists at each array index.</p>
<h3 id="core-characteristics_10">Core Characteristics<a class="headerlink" href="#core-characteristics_10" title="Permanent link">&para;</a></h3>
<ul>
<li>🔑  <strong>Unique Key Mapping</strong><ul>
<li>Each key can map to only one value</li>
<li>Keys must be immutable</li>
<li>Values can be modified or duplicated</li>
<li>Perfect for one-to-one relationships</li>
</ul>
</li>
<li>⚡  <strong>Constant-Time Operations</strong><ul>
<li>O(1) average case for insertions</li>
<li>O(1) average case for retrievals</li>
<li>O(1) average case for deletions</li>
<li>Performance dependent on hash function quality</li>
</ul>
</li>
<li>🎯  <strong>Hash Distribution</strong><ul>
<li>Converts keys to array indices via hashing</li>
<li>Uses hashCode() method for initial hash</li>
<li>Compresses hash to fit array bounds</li>
<li>Aims for uniform distribution of keys</li>
</ul>
</li>
<li>⛓️  <strong>Collision Management</strong><ul>
<li>Handles key collisions using linked lists</li>
<li>Each array index can store multiple entries</li>
<li>Entries in same bucket form a chain</li>
<li>Search within chain is O(n) worst case</li>
</ul>
</li>
<li>⚖️  <strong>Load Factor Control</strong><ul>
<li>Maintains ratio of size to capacity</li>
<li>Typically keeps load factor below 0.67</li>
<li>Triggers resizing when threshold reached</li>
<li>Prevents performance degradation</li>
<li>Uses prime number capacities for better distribution</li>
</ul>
</li>
<li>🔄  <strong>Dynamic Resizing</strong><ul>
<li>Doubles capacity when load factor exceeded</li>
<li>Adds 1 to ensure prime capacity</li>
<li>Rehashes all existing entries</li>
<li>Maintains performance characteristics</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_10">Implementation Details<a class="headerlink" href="#implementation-details_10" title="Permanent link">&para;</a></h3>
<h4 id="node-structure">Node Structure<a class="headerlink" href="#node-structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private static class Node&lt;K, V&gt; {
    K key;
    V value;
    Node&lt;K, V&gt; next;

    Node(K key, V value) {
        this.key = key;
        this.value = value;
        this.next = null;
    }
}</code></pre>
<h3 id="basic-class-structure">Basic Class Structure<a class="headerlink" href="#basic-class-structure" title="Permanent link">&para;</a></h3>
<pre class="highlight"><code class="language-java">public class HashMap&lt;K, V&gt; {
    private Node&lt;K, V&gt;[] table;
    private int size;
    private static final int INITIAL_CAPACITY = 13;  // Prime number
    private static final double MAX_LOAD_FACTOR = 0.67;

    @SuppressWarnings("unchecked")
    public HashMap() {
        table = (Node&lt;K, V&gt;[]) new Node[INITIAL_CAPACITY];
        size = 0;
    }
}</code></pre>
<h3 id="core-operations_7">Core Operations<a class="headerlink" href="#core-operations_7" title="Permanent link">&para;</a></h3>
<h4 id="put-operation">Put Operation<a class="headerlink" href="#put-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public V put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException("Key cannot be null");
    }

    // Check if resize is needed
    if ((double) (size + 1) / table.length &gt; MAX_LOAD_FACTOR) {
        resize();
    }

    int index = getIndex(key);

    // Check if key already exists
    Node&lt;K, V&gt; current = table[index];
    while (current != null) {
        if (current.key.equals(key)) {
            V oldValue = current.value;
            current.value = value;
            return oldValue;
        }
        current = current.next;
    }

    // Add new node at the beginning of the chain
    Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);
    newNode.next = table[index];
    table[index] = newNode;
    size++;

    return null;
}

private int getIndex(K key) {
    return Math.abs(key.hashCode() % table.length);
}</code></pre>
<h4 id="get-operation">Get Operation<a class="headerlink" href="#get-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public V get(K key) {
    if (key == null) {
        throw new IllegalArgumentException("Key cannot be null");
    }

    int index = getIndex(key);
    Node&lt;K, V&gt; current = table[index];

    while (current != null) {
        if (current.key.equals(key)) {
            return current.value;
        }
        current = current.next;
    }

    return null;
}</code></pre>
<h4 id="remove-operation_2">Remove Operation<a class="headerlink" href="#remove-operation_2" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public V remove(K key) {
    if (key == null) {
        throw new IllegalArgumentException("Key cannot be null");
    }

    int index = getIndex(key);
    Node&lt;K, V&gt; current = table[index];
    Node&lt;K, V&gt; prev = null;

    while (current != null) {
        if (current.key.equals(key)) {
            if (prev == null) {
                table[index] = current.next;
            } else {
                prev.next = current.next;
            }
            size--;
            return current.value;
        }
        prev = current;
        current = current.next;
    }

    return null;
}</code></pre>
<h4 id="resize-operation">Resize Operation<a class="headerlink" href="#resize-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">@SuppressWarnings("unchecked")
private void resize() {
    int newCapacity = (2 * table.length) + 1;  // Prime number
    Node&lt;K, V&gt;[] oldTable = table;
    table = (Node&lt;K, V&gt;[]) new Node[newCapacity];
    size = 0;

    // Rehash all existing entries
    for (Node&lt;K, V&gt; head : oldTable) {
        Node&lt;K, V&gt; current = head;
        while (current != null) {
            put(current.key, current.value);
            current = current.next;
        }
    }
}</code></pre>
<h3 id="performance-characteristics">Performance Characteristics<a class="headerlink" href="#performance-characteristics" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Put</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Get</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Remove</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Space</td>
<td>O(n)</td>
<td>O(n)</td>
<td>n = number of key-value pairs</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_9">💡 Best Practices<a class="headerlink" href="#best-practices_9" title="Permanent link">&para;</a></h3>
<h4 id="1-load-factor-management">1. Load Factor Management<a class="headerlink" href="#1-load-factor-management" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private boolean needsResize() {
    return (double) size / table.length &gt; MAX_LOAD_FACTOR;
}</code></pre>
<h4 id="2-key-quality">2. Key Quality<a class="headerlink" href="#2-key-quality" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Override hashCode() in key objects
@Override
public int hashCode() {
    int hash = 17;
    hash = 31 * hash + field1.hashCode();
    hash = 31 * hash + field2.hashCode();
    return hash;
}</code></pre>
<h4 id="3-proper-equals-implementation">3. Proper Equals Implementation<a class="headerlink" href="#3-proper-equals-implementation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    MyKey other = (MyKey) obj;
    return field1.equals(other.field1) &amp;&amp; field2.equals(other.field2);
}</code></pre>
<h3 id="common-pitfalls_9">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_9" title="Permanent link">&para;</a></h3>
<h4 id="1-poor-hash-distribution">1. Poor Hash Distribution<a class="headerlink" href="#1-poor-hash-distribution" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: Poor hash function
public int hashCode() {
    return 1;  // All items hash to same bucket
}

// BETTER: Good distribution
public int hashCode() {
    return Objects.hash(field1, field2);
}</code></pre>
<h4 id="2-missing-null-checks">2. Missing Null Checks<a class="headerlink" href="#2-missing-null-checks" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: No null check
public V put(K key, V value) {
    int index = key.hashCode() % table.length;  // NullPointerException!

// CORRECT: With null check
public V put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException("Key cannot be null");
    }
    int index = getIndex(key);</code></pre>
<p>HashMaps provide efficient key-value storage with constant-time average case operations, making them ideal for lookup-intensive applications. The separate chaining implementation offers a good balance between simplicity and performance.</p>
<h3 id="references_9">References<a class="headerlink" href="#references_9" title="Permanent link">&para;</a></h3>
<p><a href="https://youtube.com/playlist?list=PLDV1Zeh2NRsDH5Wq-Vk5tDb8gH03cULZS&amp;si=gXITqecXbB73ARdC">HashTables with Collision Management</a></p>
<h1 id="graph-based-structures_1">🕸️ Graph-Based Structures<a class="headerlink" href="#graph-based-structures_1" title="Permanent link">&para;</a></h1>
<p><img alt="Directed Graph" src="https://i.postimg.cc/WbQbHMmY/temp-Imagen2z-WHZ.avif" />
A Graph is a data structure that models relationships between elements using vertices (nodes) and edges. This implementation represents a directed graph using vertex and edge sets along with an adjacency list representation for efficient neighbor access.</p>
<h3 id="core-characteristics_11">Core Characteristics<a class="headerlink" href="#core-characteristics_11" title="Permanent link">&para;</a></h3>
<ul>
<li>🔍  <strong>Vertex Management</strong><ul>
<li>Each vertex contains generic typed data</li>
<li>Vertices are unique based on data equality</li>
<li>Supports null-safe vertex operations</li>
<li>Maintains a vertex set for O(1) lookups</li>
</ul>
</li>
<li>🔗  <strong>Edge Properties</strong><ul>
<li>Directed edges from vertex u to v</li>
<li>Weighted connections</li>
<li>Maintains edge set for global access</li>
<li>Supports undirected graphs via bidirectional edges</li>
</ul>
</li>
<li>📊  <strong>Adjacency Structure</strong><ul>
<li>Maps vertices to neighbor lists</li>
<li>Includes edge weights in adjacency entries</li>
<li>Efficient neighbor access</li>
<li>Space-efficient for sparse graphs</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_11">Implementation Details<a class="headerlink" href="#implementation-details_11" title="Permanent link">&para;</a></h3>
<h4 id="vertex-class">Vertex Class<a class="headerlink" href="#vertex-class" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class Vertex&lt;T&gt; {
    private T data;

    public Vertex(T data) {
        if (data == null) {
            throw new IllegalArgumentException("Data cannot be null.");
        }
        this.data = data;
    }

    public T getData() {
        return data;
    }

    @Override
    public boolean equals(Object o) {
        if (o != null &amp;&amp; o instanceof Vertex) {
            return data.equals(((Vertex&lt;?&gt;) o).data);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return data.hashCode();
    }
}</code></pre>
<h4 id="edge-class">Edge Class<a class="headerlink" href="#edge-class" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class Edge&lt;T&gt; implements Comparable&lt;Edge&lt;? super T&gt;&gt; {
    private Vertex&lt;T&gt; u;  // Source vertex
    private Vertex&lt;T&gt; v;  // Destination vertex
    private int weight;   // Edge weight

    public Edge(Vertex&lt;T&gt; u, Vertex&lt;T&gt; v, int weight) {
        if (u == null || v == null) {
            throw new IllegalArgumentException("Arguments cannot be null.");
        }
        this.u = u;
        this.v = v;
        this.weight = weight;
    }

    public Vertex&lt;T&gt; getU() { return u; }
    public Vertex&lt;T&gt; getV() { return v; }
    public int getWeight() { return weight; }

    @Override
    public int compareTo(Edge&lt;? super T&gt; e) {
        return weight - e.getWeight();
    }
}</code></pre>
<h4 id="graph-structure">Graph Structure<a class="headerlink" href="#graph-structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class Graph&lt;T&gt; {
    private Set&lt;Vertex&lt;T&gt;&gt; vertices;
    private Set&lt;Edge&lt;T&gt;&gt; edges;
    private Map&lt;Vertex&lt;T&gt;, List&lt;VertexDistance&lt;T&gt;&gt;&gt; adjList;

    public Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {
        if (vertices == null || edges == null) {
            throw new IllegalArgumentException("Arguments cannot be null.");
        }

        this.vertices = new HashSet&lt;&gt;(vertices);
        this.edges = new HashSet&lt;&gt;(edges);
        this.adjList = new HashMap&lt;&gt;();

        // Initialize adjacency list
        for (Vertex&lt;T&gt; v : vertices) {
            adjList.put(v, new ArrayList&lt;&gt;());
        }

        // Populate adjacency list
        for (Edge&lt;T&gt; e : edges) {
            if (adjList.containsKey(e.getU())) {
                adjList.get(e.getU()).add(
                    new VertexDistance&lt;&gt;(e.getV(), e.getWeight())
                );
            } else {
                throw new IllegalArgumentException(
                    "Vertex set must contain all vertices of the graph.");
            }
        }
    }
}</code></pre>
<h4 id="vertex-distance-helper">Vertex Distance Helper<a class="headerlink" href="#vertex-distance-helper" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public final class VertexDistance&lt;T&gt; 
    implements Comparable&lt;VertexDistance&lt;? super T&gt;&gt; {

    private final Vertex&lt;T&gt; vertex;
    private final int distance;

    public VertexDistance(Vertex&lt;T&gt; vertex, int distance) {
        this.vertex = vertex;
        this.distance = distance;
    }

    @Override
    public int compareTo(VertexDistance&lt;? super T&gt; pair) {
        return this.distance - pair.getDistance();
    }
}</code></pre>
<h3 id="performance-characteristics_1">Performance Characteristics<a class="headerlink" href="#performance-characteristics_1" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add Vertex</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet insertion</td>
</tr>
<tr>
<td>Add Edge</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet &amp; ArrayList insertion</td>
</tr>
<tr>
<td>Find Vertex</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet lookup</td>
</tr>
<tr>
<td>Find Edge</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet lookup</td>
</tr>
<tr>
<td>Get Neighbors</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashMap &amp; ArrayList access</td>
</tr>
<tr>
<td>Space</td>
<td>O(V + E)</td>
<td>O(V + E)</td>
<td>V vertices + E edges</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_10">Best Practices<a class="headerlink" href="#best-practices_10" title="Permanent link">&para;</a></h3>
<h4 id="1-creating-undirected-edges">1. Creating Undirected Edges<a class="headerlink" href="#1-creating-undirected-edges" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Add both directions for undirected edges
vertices.add(vertexA);
vertices.add(vertexB);
edges.add(new Edge&lt;&gt;(vertexA, vertexB, weight));
edges.add(new Edge&lt;&gt;(vertexB, vertexA, weight));</code></pre>
<h4 id="2-vertex-creation">2. Vertex Creation<a class="headerlink" href="#2-vertex-creation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Ensure data validity
public static &lt;T&gt; Vertex&lt;T&gt; createVertex(T data) {
    if (data == null) {
        throw new IllegalArgumentException("Vertex data cannot be null");
    }
    return new Vertex&lt;&gt;(data);
}</code></pre>
<h4 id="4-edge-validation">4. Edge Validation<a class="headerlink" href="#4-edge-validation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private boolean isValidEdge(Edge&lt;T&gt; edge) {
    return vertices.contains(edge.getU()) 
        &amp;&amp; vertices.contains(edge.getV());
}</code></pre>
<h3 id="common-pitfalls_10">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_10" title="Permanent link">&para;</a></h3>
<h4 id="1-missing-graph-initialization">1. Missing Graph Initialization<a class="headerlink" href="#1-missing-graph-initialization" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: Uninitialized collections
public Graph() {
    // Missing initialization
}

// CORRECT: Properly initialized collections
public Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {
    this.vertices = new HashSet&lt;&gt;(vertices);
    this.edges = new HashSet&lt;&gt;(edges);
    this.adjList = new HashMap&lt;&gt;();
    // ... rest of initialization
}</code></pre>
<h4 id="2-improper-edge-direction-handling">2. Improper Edge Direction Handling<a class="headerlink" href="#2-improper-edge-direction-handling" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: Assuming bidirectional
adjList.get(edge.getV()).add(
    new VertexDistance&lt;&gt;(edge.getU(), edge.getWeight()));

// CORRECT: Respecting edge direction
adjList.get(edge.getU()).add(
    new VertexDistance&lt;&gt;(edge.getV(), edge.getWeight()));</code></pre>
<p>This implementation provides a robust foundation for directed graph operations while maintaining type safety and efficient operations through appropriate data structure choices.</p>
<h3 id="references_10">References<a class="headerlink" href="#references_10" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/gXgEDyodOJU?si=ED9c2gKgXgDcDJvW">Introduction to Graphs</a></p>
<h1 id="disjoint-sets-union-find">🌳 Disjoint-Sets: Union-Find<a class="headerlink" href="#disjoint-sets-union-find" title="Permanent link">&para;</a></h1>
<p><img alt="Disjoint-Sets" src="https://i.postimg.cc/y6yb5BFM/temp-Imagef5e-V06.avif" /></p>
<p>A Disjoint Set (Union-Find) is a data structure that keeps track of elements partitioned into non-overlapping sets. It provides near-constant time operations to check if two elements are in the same set and to unite two sets, making it essential for algorithms like Kruskal's MST.</p>
<h3 id="core-characteristics_12">Core Characteristics<a class="headerlink" href="#core-characteristics_12" title="Permanent link">&para;</a></h3>
<ul>
<li>🌳  <strong>Tree-Based Structure</strong><ul>
<li>Each set is represented as a tree</li>
<li>Elements point to their parent elements</li>
<li>Root element represents the set identifier</li>
<li>Path compression for efficiency</li>
</ul>
</li>
<li>🔍  <strong>Find Operation</strong><ul>
<li>Identifies the set an element belongs to</li>
<li>Implements path compression</li>
<li>Returns the root element</li>
<li>Amortized O(1) time complexity</li>
</ul>
</li>
<li>🤝  <strong>Union Operation</strong><ul>
<li>Merges two different sets</li>
<li>Uses union by rank</li>
<li>Maintains tree balance</li>
<li>Prevents deep hierarchies</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_12">Implementation Details<a class="headerlink" href="#implementation-details_12" title="Permanent link">&para;</a></h3>
<h4 id="structure_10">Structure<a class="headerlink" href="#structure_10" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">private static class DisjointSetNode&lt;T&gt; {
    private DisjointSetNode&lt;T&gt; parent;
    private T data;
    private int rank;

    public DisjointSetNode(T data) {
        this.parent = this;  // Node initially points to itself
        this.data = data;
        this.rank = 0;
    }
}</code></pre>
<h4 id="base-structure">Base Structure<a class="headerlink" href="#base-structure" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public class DisjointSet&lt;T&gt; {
    private Map&lt;T, DisjointSetNode&lt;T&gt;&gt; disjointSet;

    public DisjointSet() {
        disjointSet = new HashMap&lt;&gt;();
    }
}</code></pre>
<h3 id="core-operations_8">Core Operations<a class="headerlink" href="#core-operations_8" title="Permanent link">&para;</a></h3>
<h4 id="find-operation">Find Operation<a class="headerlink" href="#find-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public T find(T data) {
    if (!disjointSet.containsKey(data)) {
        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));
    }
    return find(disjointSet.get(data)).getData();
}

private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; curr) {
    DisjointSetNode&lt;T&gt; parent = curr.getParent();

    if (parent == curr) {
        return curr;  // Found root
    }

    // Path compression: Make all nodes point to root
    parent = find(curr.getParent());
    curr.setParent(parent);
    return parent;
}</code></pre>
<h3 id="performance-characteristics_2">📊 Performance Characteristics<a class="headerlink" href="#performance-characteristics_2" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Amortized Time</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Make Set</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Creates new set</td>
</tr>
<tr>
<td>Find</td>
<td>O(α(n))</td>
<td>O(log n)</td>
<td>With path compression</td>
</tr>
<tr>
<td>Union</td>
<td>O(α(n))</td>
<td>O(log n)</td>
<td>With union by rank</td>
</tr>
<tr>
<td>Space</td>
<td>O(n)</td>
<td>O(n)</td>
<td>n elements</td>
</tr>
</tbody>
</table>
<p>Note: α(n) is the inverse Ackermann function, which grows extremely slowly and is effectively constant for all practical values of n. </p>
<h3 id="best-practices_11">💡 Best Practices<a class="headerlink" href="#best-practices_11" title="Permanent link">&para;</a></h3>
<h4 id="1-path-compression">1. Path Compression<a class="headerlink" href="#1-path-compression" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always update parent pointers during find
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent())); // Compress path
    }
    return node.getParent();
}</code></pre>
<h4 id="2-union-by-rank">2. Union by Rank<a class="headerlink" href="#2-union-by-rank" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// Always consider ranks when unioning
if (firstParent.getRank() &lt; secondParent.getRank()) {
    firstParent.setParent(secondParent);
} else {
    secondParent.setParent(firstParent);
    if (firstParent.getRank() == secondParent.getRank()) {
        firstParent.setRank(firstParent.getRank() + 1);
    }
}</code></pre>
<h4 id="3-lazy-initialization">3. Lazy Initialization<a class="headerlink" href="#3-lazy-initialization" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">public T find(T data) {
    if (!disjointSet.containsKey(data)) {
        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));
    }
    // Continue with find operation
}</code></pre>
<h3 id="common-pitfalls_11">⚠️ Common Pitfalls<a class="headerlink" href="#common-pitfalls_11" title="Permanent link">&para;</a></h3>
<h4 id="1-missing-path-compression">1. Missing Path Compression<a class="headerlink" href="#1-missing-path-compression" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: No path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    while (node != node.getParent()) {
        node = node.getParent();
    }
    return node;
}

// CORRECT: With path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent()));
    }
    return node.getParent();
}</code></pre>
<h4 id="2-incorrect-union-operation">2. Incorrect Union Operation<a class="headerlink" href="#2-incorrect-union-operation" title="Permanent link">&para;</a></h4>
<pre class="highlight"><code class="language-java">// WRONG: No path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    while (node != node.getParent()) {
        node = node.getParent();
    }
    return node;
}

// CORRECT: With path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent()));
    }
    return node.getParent();
}</code></pre>
<p>This implementation provides an efficient foundation for set operations used in graph algorithms, particularly Kruskal's Minimum Spanning Tree algorithm, with optimizations for both time and space complexity.</p>
<h3 id="references_11">References<a class="headerlink" href="#references_11" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/ayW5B2W9hfo?si=-6kosBXm4AK0u9pC">Union Find Data Structure</a></p>
<h1 id="other-advanced-structures">📚 Other Advanced Structures<a class="headerlink" href="#other-advanced-structures" title="Permanent link">&para;</a></h1>
<h3 id="trie">🔎 Trie<a class="headerlink" href="#trie" title="Permanent link">&para;</a></h3>
<p><a href="https://youtube.com/playlist?list=PLEJXowNB4kPyi859E6qGUs7jlpQehJndl&amp;si=9xfexgOQ7DaSU_h_">Trie</a></p>
<h3 id="skip-lists">🔎 Skip Lists<a class="headerlink" href="#skip-lists" title="Permanent link">&para;</a></h3>
<p><a href="https://youtu.be/hqHwQUdTgLM?si=oaf0LW2DRyVO4lP5">Skip List Introduction</a>
<a href="https://youtu.be/1G8h3u6Thzs?si=ykbCCfLzIFW4oSa_">Skip Lists Insertion and Deletion</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../a_object_oriented_programming/" class="btn btn-neutral float-left" title="Object Oriented Programming"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../c_algorithms/" class="btn btn-neutral float-right" title="Algorithms">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../a_object_oriented_programming/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../c_algorithms/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
