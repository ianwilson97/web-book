<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>🔮 Data Structures - My Docs</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Introduction</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">1.Fundamentals</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../a.%20programming_principles/" class="dropdown-item">🔮 Programming Fundamentals</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">🔮 Data Structures</a>
</li>
                                    
<li>
    <a href="../c.%20algorithms/" class="dropdown-item">📘 Introduction to Algorithms</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">2.Interviews</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../2.Interviews/b.%20technical%20interviews/" class="dropdown-item">🚀 The Ultimate Python Technical Interview Guide</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../a.%20programming_principles/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../c.%20algorithms/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#data-structures" class="nav-link">🔮 Data Structures</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#introduction" class="nav-link">📘 Introduction</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#guide-structure" class="nav-link">Guide Structure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#categories-of-data-structures" class="nav-link">Categories of Data Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#time-complexity-overview" class="nav-link">Time Complexity Overview</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#performance-overview" class="nav-link">📊 Performance Overview</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#references" class="nav-link">References</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#linear-data-structuresine-data-structures" class="nav-link">📚 LINEAR DATA STRUCTURESine Data Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#arraylist" class="nav-link">📚 ArrayList</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-characteristics" class="nav-link">Core Characteristics</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#linked-lists" class="nav-link">📚 Linked Lists</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#singly-linked-list" class="nav-link">🔗 Singly Linked List</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_1" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#doubly-linked-list" class="nav-link">🔗 Doubly Linked List</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_2" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#circular-singly-linked-list" class="nav-link">🔄 Circular Singly Linked List</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_3" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#stack" class="nav-link">📚 Stack</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_5" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#queue" class="nav-link">🎯 Queue</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_7" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#tree-based-structures_1" class="nav-link">🌳 Tree-Based Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#priority-queue" class="nav-link">📊 Priority Queue</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_9" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#binary-tree" class="nav-link">🌳 Binary Tree</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_11" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#binary-search-tree" class="nav-link">🌳 Binary Search Tree</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#performance-summary_12" class="nav-link">📊 Performance Summary</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#advanced-tree-based-structures_1" class="nav-link">🌲 Advanced Tree-Based Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#avl-trees" class="nav-link">🌳 AVL Trees</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#hash-based-structures_1" class="nav-link">🎯 Hash-Based Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#hashmaps" class="nav-link">#️⃣ HashMaps</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#graph-based-structures_1" class="nav-link">🕸️ Graph-Based Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#disjoint-sets-union-find" class="nav-link">🌳 Disjoint-Sets: Union-Find</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#other-advanced-structures" class="nav-link">📚 Other Advanced Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="data-structures">🔮 Data Structures</h1>
<p><img alt="Data Structures" src="https://i.postimg.cc/rsFzdHwb/temp-Image-.avif" /></p>
<h2 id="introduction">📘 Introduction</h2>
<p>Data structures are specialized formats for organizing, processing, retrieving, and storing data. Understanding data structures is fundamental to writing efficient and scalable code. This guide explores various data structures, their implementations, and practical applications in software development.</p>
<h3 id="why-data-structures-matter">Why Data Structures Matter</h3>
<ul>
<li>🎯  <strong>Efficient Problem-Solving</strong>: Choosing the right data structure can dramatically improve program performance</li>
<li>💼  <strong>Career Development</strong>: Essential for technical interviews at top tech companies</li>
<li>🔧  <strong>Code Optimization</strong>: Enables writing more efficient and maintainable code</li>
<li>🌐  <strong>Real-World Applications</strong>: Critical for building scalable software systems</li>
<li>🏆  <strong>Competitive Edge</strong>: Fundamental for algorithmic problem-solving and competitions</li>
</ul>
<h2 id="guide-structure">Guide Structure</h2>
<p>Each data structure section will cover:
- Core concepts and characteristics
- Implementation details
- Time and space complexities
- Common operations
- Best practices and use cases
- Code examples and tips</p>
<h2 id="categories-of-data-structures">Categories of Data Structures</h2>
<h3 id="linear-data-structures">📚 Linear Data Structures</h3>
<p>Structures where elements are stored sequentially:</p>
<ul>
<li><strong>Arrays &amp; ArrayLists</strong>:<ul>
<li>Direct access by index</li>
<li>Contiguous memory storage</li>
<li>Best for: Fixed-size collections with frequent access</li>
</ul>
</li>
<li><strong>Linked Lists</strong>:<ul>
<li>Dynamic size</li>
<li>Non-contiguous storage</li>
<li>Best for: Frequent insertions/deletions</li>
</ul>
</li>
<li><strong>Stacks</strong>:<ul>
<li>LIFO (Last-In-First-Out)</li>
<li>Best for: Function calls, undo operations</li>
</ul>
</li>
<li><strong>Queues</strong>:<ul>
<li>FIFO (First-In-First-Out)</li>
<li>Best for: Task scheduling, resource management</li>
</ul>
</li>
</ul>
<h3 id="tree-based-structures">🌳 Tree-Based Structures</h3>
<p>Hierarchical structures with parent-child relationships:</p>
<ul>
<li><strong>Priority Queues</strong>:<ul>
<li>Efficient priority-based operations</li>
<li>Best for: Scheduling, event handling</li>
</ul>
</li>
<li><strong>Binary Trees</strong>:<ul>
<li>Two children per node maximum</li>
<li>Best for: Hierarchical data</li>
</ul>
</li>
<li><strong>Binary Search Trees</strong>:<ul>
<li>Ordered nodes</li>
<li>Best for: Fast search, insert, delete</li>
</ul>
</li>
</ul>
<h3 id="advanced-tree-based-structures">🌲 Advanced Tree-Based Structures</h3>
<p>Specialized tree structures for specific use cases:</p>
<ul>
<li><strong>AVL Trees</strong>: Balanced binary search trees    </li>
<li><strong>Red-Black Trees</strong>: Balanced search with color properties</li>
<li><strong>2-3 Trees</strong>: Guaranteed balanced search trees</li>
<li><strong>B-Trees</strong>: Optimized for disk storage</li>
<li><strong>K-D Trees</strong>: Space partitioning structure</li>
<li><strong>M-Ary Trees</strong>: Nodes with multiple children</li>
</ul>
<h3 id="hash-based-structures">🎯 Hash-Based Structures</h3>
<p>Structures using hash functions:</p>
<ul>
<li><strong>Hash Tables</strong>:<ul>
<li>Key-value storage</li>
<li>O(1) average access</li>
<li>Best for: Caching, dictionaries</li>
</ul>
</li>
</ul>
<h3 id="graph-based-structures">🕸️ Graph-Based Structures</h3>
<p>Structures representing connections:</p>
<ul>
<li><strong>Directed Graphs</strong>: One-way connections</li>
<li><strong>Undirected Graphs</strong>: Two-way connections</li>
<li><strong>inaphs</strong> Coctions with costs</li>
<li><strong>Disjoint-Sets</strong>: Non-Overlapping group connections</li>
</ul>
<h3 id="advanced-structures">📚 Advanced Structures</h3>
<p>Specialized data structures:</p>
<ul>
<li><strong>Tries</strong>:<ul>
<li>Efficient string operations</li>
<li>Best for: Autocomplete, spell checkers</li>
</ul>
</li>
<li><strong>Skip Lists</strong>:<ul>
<li>Probabilistic alternative to balanced trees</li>
<li>Best for: Fast search with simple implementation</li>
</ul>
</li>
</ul>
<h2 id="time-complexity-overview">Time Complexity Overview</h2>
<h2 id="performance-overview">📊 Performance Overview</h2>
<table>
<thead>
<tr>
<th>Data Structure</th>
<th>Access</th>
<th>Search</th>
<th>Insertion</th>
<th>Deletion</th>
<th>Space</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>ArrayList</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)*</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>LinkedList</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Stack</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Queue</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Priority Queue</td>
<td>O(1)***</td>
<td>O(n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Binary Tree</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Binary Search Tree</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(log n)*</td>
<td>O(n)</td>
</tr>
<tr>
<td>AVL Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Red-Black Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>2-3 Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>B-Tree</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>K-D Tree</td>
<td>O(n)</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(n)</td>
</tr>
<tr>
<td>Trie</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(m)****</td>
<td>O(n*m)</td>
</tr>
<tr>
<td>Skip List</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(log n)**</td>
<td>O(n log n)</td>
</tr>
<tr>
<td>Hash Table</td>
<td>O(1)**</td>
<td>O(1)**</td>
<td>O(1)**</td>
<td>O(1)*</td>
<td></td>
</tr>
</tbody>
</table>
<p>* Average case for balanced trees
*<em> Average case, assumes good hash function or balanced structure
*</em><em> For peek operation only
*</em>** Where m is the length of the string/pattern
† Amortized time complexity for dynamic resizing~~</p>
<h2 id="references">References</h2>
<p><a href="https://drive.google.com/file/d/1LaF74WE-jMvdlZ0FLwSWRxKVjO75iv8z/view?usp=share_link">Data Structures and Algorithms Notes</a></p>
<h1 id="linear-data-structuresine-data-structures">📚 LINEAR DATA STRUCTURESine Data Structures</h1>
<h1 id="arraylist">📚 ArrayList</h1>
<p><img alt="ArrayLists" src="https://i.postimg.cc/C10R05Tw/temp-Image-PLc-FLQ.avif" />
An ArrayList is a dynamic array implementation that automatically handles resizing as elements are added or removed. It provides fast random access and is one of the most used data structures in Java.</p>
<h2 id="core-characteristics">Core Characteristics</h2>
<ul>
<li>📈 Dynamic sizing</li>
<li>📊 Contiguous memory storage</li>
<li>🔍 Fast random access</li>
<li>📝 Mutable length</li>
</ul>
<h3 id="implementation-details">Implementation Details</h3>
<h4 id="structure">Structure</h4>
<pre><code class="language-java">public class ArrayList&lt;T&gt; {
    private T[] backingArray;    // Internal array to store elements
    private int size;            // Number of elements in the ArrayList
    public static final int INITIAL_CAPACITY = 9;
}
</code></pre>
<h3 id="core-operations-time-complexities">🔧 Core Operations &amp; Time Complexities</h3>
<h4 id="adding-elements">Adding Elements</h4>
<h5 id="addtobackt-data">addToBack(T data)</h5>
<pre><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
    addHelper(size, data);
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: Amortized O(1)</li>
<li>💭 Best for: Adding elements when order doesn't matter</li>
<li>⚠️ Note: May trigger resizing of backing array</li>
</ul>
<h5 id="addtofrontt-data">addToFront(T data)</h5>
<pre><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
    addHelper(0, data);
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>⚠️ Warning: Requires shifting all elements</li>
<li>💭 Use Case: When elements must be added at the beginning</li>
</ul>
<h4 id="internal-helper-method-adding">🛠️ Internal Helper Method (Adding)</h4>
<h5 id="addhelperint-index-t-data">addHelper(int index, T data)</h5>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)
private void addHelper(int index, T data) {
    // If array is full, create new array with double capacity
    if (size == backingArray.length) {
        T[] newArray = (T[]) new Object[backingArray.length * 2];
        int i;

        // Copy elements before index
        for (i = 0; i &lt; index; i++) {
            newArray[i] = backingArray[i];
        }
        // Insert new element
        newArray[i] = data;
        // Copy remaining elements
        for (; i &lt; size; i++) {
            newArray[i + 1] = backingArray[i];
        }

        backingArray = newArray;
    } else {
        // Shift elements to make room for new element
        for (int i = size; i &gt; index; --i) {
            backingArray[i] = backingArray[i - 1];
        }
        backingArray[index] = data;
    }
    size++;
}
````
#### Removing Elements
##### removeFromBack()
````java
public T removeFromBack() {
    if (size == 0) {
        throw new java.util.NoSuchElementException(&quot;Cannot remove from an empty list&quot;);
    }
    return removeHelper(size - 1);
}
````
-   ⏱️ Time Complexity: O(1)
-   💫 Most efficient removal operation
-   ⚠️ Checks for empty list
##### removeFromFront()
````java
public T removeFromFront() {
    if (size == 0) {
        throw new java.util.NoSuchElementException(&quot;Cannot remove from an empty list&quot;);
    }
    return removeHelper(0);
}
````
-   ⏱️ Time Complexity: O(n)
-   ⚠️ Requires shifting all elements
-   💭 Use sparingly due to performance cost

##### removeAtIndex(int index)
```java
public T removeAtIndex(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException(&quot;Index cannot be outside the &quot;
            + &quot;range [0, &quot; + size + &quot;)&quot;);
    }
    return removeHelper(index);
}
</code></pre>
<ul>
<li>⏱️ Time Complexity:<ul>
<li>Best Case (last element): O(1)</li>
<li>Average/Worst Case: O(n)</li>
</ul>
</li>
<li>🎯 Purpose: Removes and returns element at specified index</li>
<li>⚠️ Validation: Checks for valid index range</li>
<li>💫 Process:<ol>
<li>Validates index bounds</li>
<li>Calls removeHelper for actual removal</li>
<li>Returns removed element</li>
</ol>
</li>
</ul>
<h4 id="internal-helper-method-removing">🛠️ Internal Helper Method (Removing)</h4>
<h5 id="removehelperint-index">removeHelper(int index)</h5>
<pre><code class="language-java">private T removeHelper(int index) {
    T removed = backingArray[index];
    // Shift elements to fill the gap
    for (int i = index; i &lt; size - 1; i++) {
        backingArray[i] = backingArray[i + 1];
    }
    backingArray[--size] = null;  // Clear last element and decrease size
    return removed;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>🎯 Purpose: Internal method for handling element removal and shifting</li>
<li>💫 Key Operations:<ol>
<li>Element removal at specified index</li>
<li>Left-shifting remaining elements</li>
<li>Cleanup and size management</li>
</ol>
</li>
</ul>
<h4 id="access-operations">Access Operations</h4>
<h5 id="getint-index">get(int index)</h5>
<pre><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException(&quot;Index cannot be outside the &quot;
            + &quot;range [0, &quot; + size + &quot;)&quot;);
    }
    return backingArray[index];
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>🎯 Direct index access</li>
<li>⚠️ Bounds checking included</li>
</ul>
<h2 id="performance-summary">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Back</td>
<td>O(1)*</td>
<td>*Amortized</td>
</tr>
<tr>
<td>Add to Front</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(1)</td>
<td>Most efficient removal</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(n)</td>
<td>Requires shifting</td>
</tr>
<tr>
<td>Get/Set</td>
<td>O(1)</td>
<td>Direct access</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>Memory reset</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant tracking</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity - occasional resizing operations are averaged over many operations</p>
<h3 id="best-practices">💡 Best Practices</h3>
<h4 id="1-initialization">1. Initialization</h4>
<ul>
<li>State with reasonable initial capacity</li>
<li>Consider expected size for optimal performance</li>
</ul>
<h4 id="2-usage-tips">2. Usage Tips</h4>
<pre><code class="language-java">// Prefer adding to back when possible
list.addToBack(element);  // O(1)

// Avoid frequent front operations
list.addToFront(element); // O(n) - expensive!
</code></pre>
<h4 id="3-memory-management">3. Memory Management</h4>
<ul>
<li>Clear references when removing elements</li>
<li>Reset to initial capacity when clearing</li>
</ul>
<h3 id="common-use-cases">🎯 Common Use Cases</h3>
<ul>
<li>📝 Dynamic lists of elements</li>
<li>📊 Buffer implementation</li>
<li>🔄 Stack implementation</li>
<li>📚 Collection management</li>
</ul>
<h3 id="common-pitfalls">⚠️ Common Pitfalls</h3>
<ol>
<li>Frequent front operations</li>
<li>Not considering capacity growth</li>
<li>Not handling null elements</li>
<li>Ignoring bounds checking</li>
</ol>
<h3 id="when-to-use-arraylist">🔍 When to Use ArrayList</h3>
<ul>
<li>Need dynamic sizing</li>
<li>Frequent random access</li>
<li>Mostly back-end operations</li>
<li>Memory locality is important</li>
</ul>
<h3 id="when-not-to-use-arraylist">🚫 When Not to Use ArrayList</h3>
<ul>
<li>Frequent insertions/deletions at front/middle</li>
<li>Fixed size is sufficient</li>
<li>Memory is extremely constrained</li>
<li>Need concurrent access</li>
</ul>
<h4 id="references_1">References</h4>
<p>https://youtu.be/PEnFFiQe1pM?si=KfpsngEBI0gesUbC</p>
<h1 id="linked-lists">📚 Linked Lists</h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/fLKGM96B/temp-Imageq-Jb-Lbh.avif" /></p>
<h2 id="singly-linked-list">🔗 Singly Linked List</h2>
<p>A Singly Linked List is a fundamental data structure where elements are stored in nodes, each containing data and a reference to the next node in the sequence. Unlike arrays, linked lists don't require contiguous memory allocation, making them ideal for dynamic data management.</p>
<h3 id="core-characteristics_1">Core Characteristics</h3>
<ul>
<li>🔄 Dynamic sizing (no fixed capacity)</li>
<li>📝 Sequential access pattern</li>
<li>🧩 Node-based structure</li>
<li>🎯 Efficient insertions and deletions at known positions</li>
<li>🔍 Linear time search operations</li>
</ul>
<h3 id="implementation-details_1">Implementation Details</h3>
<h4 id="structure_1">Structure</h4>
<pre><code class="language-java">public class LinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;
    private int size;

    private static class Node&lt;T&gt; {
        private T data;
        private Node&lt;T&gt; next;

        public Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
}
</code></pre>
<h3 id="core-operations-time-complexities_1">🔧 Core Operations &amp; Time Complexities</h3>
<h4 id="adding-elements_1">Adding Elements</h4>
<h5 id="addtofrontt-data_1">addToFront(T data)</h5>
<pre><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    newNode.next = head;
    head = newNode;
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Stack-like operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Null data</li>
<li>First element (empty list)</li>
</ul>
</li>
</ul>
<h5 id="addtobackt-data_1">addToBack(T data)</h5>
<pre><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);

    if (head == null) {
        head = newNode;
    } else {
        Node&lt;T&gt; current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 Best for: Queue-like operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Null data</li>
<li>Empty list</li>
<li>Consider tracking tail pointer for O(1) operation</li>
</ul>
</li>
</ul>
<h5 id="addatindexint-index-t-data">addAtIndex(int index, T data)</h5>
<pre><code class="language-java">public void addAtIndex(int index, T data) {
    if (index &lt; 0 || index &gt; size) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
    }
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    if (index == 0) {
        addToFront(data);
        return;
    }

    Node&lt;T&gt; current = head;
    for (int i = 0; i &lt; index - 1; i++) {
        current = current.next;
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    newNode.next = current.next;
    current.next = newNode;
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 Best for: Ordered insertions</li>
<li>⚠️ Edge Cases:<ul>
<li>Invalid index</li>
<li>Null data</li>
<li>Front insertion</li>
</ul>
</li>
</ul>
<h4 id="removing-elements">Removing Elements</h4>
<h5 id="removefromfront">removeFromFront()</h5>
<pre><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    T data = head.data;
    head = head.next;
    size--;
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Stack operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Single element</li>
</ul>
</li>
</ul>
<h5 id="removefromback">removeFromBack()</h5>
<pre><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    if (size == 1) {
        T data = head.data;
        head = null;
        size--;
        return data;
    }

    Node&lt;T&gt; current = head;
    while (current.next.next != null) {
        current = current.next;
    }

    T data = current.next.data;
    current.next = null;
    size--;
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 Best for: Queue operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Single element</li>
<li>Consider tail pointer optimization</li>
</ul>
</li>
</ul>
<h4 id="access-operations_1">Access Operations</h4>
<h5 id="getint-index_1">get(int index)</h5>
<pre><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
    }

    Node&lt;T&gt; current = head;
    for (int i = 0; i &lt; index; i++) {
        current = current.next;
    }
    return current.data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 Best for: Sequential access</li>
<li>⚠️ Edge Cases:<ul>
<li>Invalid index</li>
<li>Empty list</li>
</ul>
</li>
</ul>
<h2 id="performance-summary_1">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Traversal to index</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Get</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_1">💡 Best Practices</h3>
<h4 id="1-null-handling">1. Null Handling</h4>
<pre><code class="language-java">private void validateNotNull(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
}
</code></pre>
<h4 id="2-index-validation">2. Index Validation</h4>
<pre><code class="language-java">private void validateIndex(int index, boolean isAdd) {
    int maxIndex = isAdd ? size : size - 1;
    if (index &lt; 0 || index &gt; maxIndex) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
    }
}
</code></pre>
<h4 id="3-memory-management_1">3. Memory Management</h4>
<ul>
<li>Clear references when removing nodes</li>
<li>Consider garbage collection implications</li>
<li>Track size for O(1) length checks</li>
</ul>
<h3 id="common-pitfalls_1">⚠️ Common Pitfalls</h3>
<h4 id="1-losing-references">1. Losing References</h4>
<pre><code class="language-java">// WRONG - Lost reference to rest of list
head = new Node&lt;&gt;(data);  // Overwrites head reference

// CORRECT - Maintain list structure
Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
newNode.next = head;
head = newNode;
</code></pre>
<h4 id="2-not-handling-edge-cases">2. Not Handling Edge Cases</h4>
<pre><code class="language-java">// WRONG - Assumes non-empty list
head.next = newNode;

// CORRECT - Handle empty list
if (head == null) {
    head = newNode;
} else {
    head.next = newNode;
}
</code></pre>
<h4 id="reference">Reference</h4>
<p><a href="https://youtu.be/-Yn5DU0_-lw?si=uyhzn4hUV9ZGr4zj">Singly Linked List Video</a></p>
<h1 id="doubly-linked-list">🔗 Doubly Linked List</h1>
<p>A Doubly Linked List is a bidirectional linked data structure where each node contains data and references to both the next and previous nodes. This bidirectional linking enables efficient traversal in both directions and simplifies certain operations compared to singly linked lists.</p>
<h3 id="core-characteristics_2">Core Characteristics</h3>
<ul>
<li>🔄 Bi-directional traversal</li>
<li>📝 Dynamic sizing</li>
<li>🎯 O(1) operations at both ends</li>
<li>🔍 Efficient insertions and deletions</li>
<li>💾 Higher memory usage per node</li>
</ul>
<h3 id="implementation-details_2">Implementation Details</h3>
<h4 id="structure_2">Structure</h4>
<pre><code class="language-java">public class DoublyLinkedList&lt;T&gt; {
    private Node&lt;T&gt; head;
    private Node&lt;T&gt; tail;
    private int size;

    private static class Node&lt;T&gt; {
        private T data;
        private Node&lt;T&gt; next;
        private Node&lt;T&gt; previous;

        Node(T data) {
            this.data = data;
            this.next = null;
            this.previous = null;
        }

        Node(T data, Node&lt;T&gt; previous, Node&lt;T&gt; next) {
            this.data = data;
            this.previous = previous;
            this.next = next;
        }
    }
}
</code></pre>
<h3 id="core-operations-time-complexities_2">🔧 Core Operations &amp; Time Complexities</h3>
<h4 id="adding-elements_2">Adding Elements</h4>
<h5 id="addtofrontt-data_2">addToFront(T data)</h5>
<pre><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    head = new Node&lt;&gt;(data, null, head);
    if (size == 0) {
        tail = head;  // First node is both head and tail
    } else {
        head.next.previous = head;  // Link old head back to new head
    }
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Stack-like operations, maintaining recent items</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Null data</li>
<li>Maintaining tail reference</li>
</ul>
</li>
</ul>
<h5 id="addtobackt-data_2">addToBack(T data)</h5>
<pre><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, tail, null);
    if (size == 0) {
        head = newNode;
    } else {
        tail.next = newNode;
    }
    tail = newNode;
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Queue-like operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Null data</li>
<li>Maintaining head reference</li>
</ul>
</li>
</ul>
<h5 id="addatindexint-index-t-data_1">addAtIndex(int index, T data)</h5>
<pre><code class="language-java">public void addAtIndex(int index, T data) {
    if (index &lt; 0 || index &gt; size) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
    }
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    if (index == 0) {
        addToFront(data);
        return;
    }
    if (index == size) {
        addToBack(data);
        return;
    }

    // Choose optimal traversal direction
    Node&lt;T&gt; current;
    if (index &lt; size / 2) {
        // Start from head
        current = head;
        for (int i = 0; i &lt; index - 1; i++) {
            current = current.next;
        }
    } else {
        // Start from tail
        current = tail;
        for (int i = size - 1; i &gt; index; i--) {
            current = current.previous;
        }
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data, current, current.next);
    current.next.previous = newNode;
    current.next = newNode;
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💡 Optimization: Chooses optimal traversal direction</li>
<li>⚠️ Edge Cases:<ul>
<li>Index bounds</li>
<li>Null data</li>
<li>Front/back insertions</li>
</ul>
</li>
</ul>
<h4 id="remove-elements">Remove Elements</h4>
<h5 id="removefromfront_1">removeFromFront()</h5>
<pre><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    T data = head.data;
    head = head.next;
    size--;

    if (size == 0) {
        tail = null;
    } else {
        head.previous = null;
    }

    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Stack operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Single element</li>
<li>Maintaining tail reference</li>
</ul>
</li>
</ul>
<h5 id="removefromback_1">removeFromBack()</h5>
<pre><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    T data = tail.data;
    tail = tail.previous;
    size--;

    if (size == 0) {
        head = null;
    } else {
        tail.next = null;
    }

    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 Best for: Queue operations</li>
<li>⚠️ Edge Cases:<ul>
<li>Empty list</li>
<li>Single element</li>
<li>Maintaining head reference</li>
</ul>
</li>
</ul>
<h4 id="access-operations_2">Access Operations</h4>
<h5 id="getint-index_2">get(int index)</h5>
<pre><code class="language-java">public T get(int index) {
    if (index &lt; 0 || index &gt;= size) {
        throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
    }

    Node&lt;T&gt; current;
    if (index &lt; size / 2) {
        current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.next;
        }
    } else {
        current = tail;
        for (int i = size - 1; i &gt; index; i--) {
            current = current.previous;
        }
    }
    return current.data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💡 Optimization: Bi-directional traversal</li>
<li>⚠️ Edge Cases:<ul>
<li>Invalid index</li>
<li>Empty list</li>
</ul>
</li>
</ul>
<h2 id="performance-summary_2">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(1)</td>
<td>Constant time with tail</td>
</tr>
<tr>
<td>Add at Index</td>
<td>O(n)</td>
<td>Optimal traversal direction</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(1)</td>
<td>Constant time with tail</td>
</tr>
<tr>
<td>Get</td>
<td>O(n)</td>
<td>Optimal traversal direction</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_2">💡 Best Practices</h3>
<h4 id="1-bi-directional-link-maintenance">1. Bi-directional Link Maintenance</h4>
<pre><code class="language-java">// Always update both next and previous references
newNode.next = current.next;
newNode.previous = current;
current.next.previous = newNode;
current.next = newNode;
</code></pre>
<h4 id="2-headtail-management">2. Head/Tail Management</h4>
<pre><code class="language-java">// For single element
if (size == 1) {
    head = tail = null;
} else {
    // Update references appropriately
}
</code></pre>
<h4 id="3-traversal-optimization">3. Traversal Optimization</h4>
<pre><code class="language-java">// Choose optimal direction based on index
if (index &lt; size / 2) {
    traverseFromHead();
} else {
    traverseFromTail();
}
</code></pre>
<h3 id="common-pitfalls_2">⚠️ Common Pitfalls</h3>
<h4 id="1-incomplete-link-updates">1. Incomplete Link Updates</h4>
<pre><code class="language-java">// WRONG - Only updating one direction
current.next = newNode;

// CORRECT - Update both directions
current.next = newNode;
newNode.previous = current;
</code></pre>
<h4 id="2-memory-leaks">2. Memory Leaks</h4>
<pre><code class="language-java">// WRONG - Leaving dangling references
head = head.next;

// CORRECT - Clear all references
T data = head.data;
Node&lt;T&gt; newHead = head.next;
head.next = null;  // Clear reference
if (newHead != null) {
    newHead.previous = null;
}
head = newHead;
</code></pre>
<h4 id="references_2">References</h4>
<p><a href="https://youtu.be/m-8ZBO2ywaU?si=c7-K9iDSFlmzCuD0">Doubly Linked List Video</a></p>
<h1 id="circular-singly-linked-list">🔄 Circular Singly Linked List</h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/4Ns3vDv9/temp-Image-PUv-Kxt.avif" /></p>
<p>A Circular Singly Linked List is a variant of linked lists where the last node points back to the first node, creating a circle. This structure is particularly useful when I need continuous traversal or cyclic operations, like round-robin scheduling.</p>
<h3 id="core-characteristics_3">Core Characteristics</h3>
<ul>
<li>🔄 Last node connects to first node</li>
<li>📝 Sequential access pattern</li>
<li>🎯 No null references</li>
<li>🔍 Continuous traversal capability</li>
<li>💫 Efficient for cyclic operations</li>
</ul>
<h3 id="implementation-details_3">Implementation Details</h3>
<h4 id="structure_3">Structure</h4>
<pre><code class="language-java">public class CircularLinkedList&lt;T&gt; {
    private Node&lt;T&gt; tail;  // Points to last node
    private int size;

    private static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; next;

        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
}
</code></pre>
<p>💭 Why track tail instead of head?</p>
<ul>
<li>O(1) insertions at both ends</li>
<li>Easy access to both first and last nodes</li>
<li>More efficient for common operations</li>
</ul>
<h3 id="core-operations">🔧 Core Operations</h3>
<h4 id="adding-elements_3">Adding Elements</h4>
<h5 id="addingtofrontt-data">addingToFront(T data)</h5>
<pre><code class="language-java">public void addToFront(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    if (isEmpty()) {
        newNode.next = newNode;  // Points to itself
        tail = newNode;
    } else {
        newNode.next = tail.next;  // Point to old first node
        tail.next = newNode;       // Update tail's next to new node
    }
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💡 Important: Maintain circular nature</li>
<li>⚠️ Edge Cases: Empty list handling</li>
</ul>
<h5 id="addtobackt-data_3">addToBack(T data)</h5>
<pre><code class="language-java">public void addToBack(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    Node&lt;T&gt; newNode = new Node&lt;&gt;(data);
    if (isEmpty()) {
        newNode.next = newNode;
    } else {
        newNode.next = tail.next;  // Point to first node
        tail.next = newNode;       // Update tail's next
    }
    tail = newNode;  // Update tail to new node
    size++;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💡 Key Point: Tail reference makes this efficient</li>
<li>⚠️ Edge Cases: Empty list, single element</li>
</ul>
<h4 id="removing-elements_1">Removing Elements</h4>
<h5 id="removefromfront_2">removeFromFront()</h5>
<pre><code class="language-java">public T removeFromFront() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    T data = tail.next.data;  // Get first node's data
    if (size == 1) {
        tail = null;
    } else {
        tail.next = tail.next.next;  // Skip first node
    }
    size--;
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💡 Key Point: Maintain circular structure</li>
<li>⚠️ Edge Cases: Empty list, single element</li>
</ul>
<h5 id="removefromback_2">removeFromBack()</h5>
<pre><code class="language-java">public T removeFromBack() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;List is empty&quot;);
    }

    T data = tail.data;
    if (size == 1) {
        tail = null;
    } else {
        Node&lt;T&gt; current = tail.next;
        while (current.next != tail) {
            current = current.next;
        }
        current.next = tail.next;
        tail = current;
    }
    size--;
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💡 Note: Requires traversal to find second-to-last node</li>
<li>⚠️ Edge Cases: Empty list, single element</li>
</ul>
<h4 id="search-operation">Search Operation</h4>
<pre><code class="language-java">public boolean contains(T data) {
    if (isEmpty() || data == null) {
        return false;
    }

    Node&lt;T&gt; current = tail.next;  // Start at first node
    do {
        if (data.equals(current.data)) {
            return true;
        }
        current = current.next;
    } while (current != tail.next);

    return false;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💡 Important: Use do-while for circular traversal</li>
<li>⚠️ Handle: Null data, empty list</li>
</ul>
<h2 id="performance-summary_3">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add to Front</td>
<td>O(1)</td>
<td>Constant time with tail reference</td>
</tr>
<tr>
<td>Add to Back</td>
<td>O(1)</td>
<td>Constant time with tail reference</td>
</tr>
<tr>
<td>Remove from Front</td>
<td>O(1)</td>
<td>Constant time operation</td>
</tr>
<tr>
<td>Remove from Back</td>
<td>O(n)</td>
<td>Requires traversal</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>Linear traversal</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Tracked variable</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_3">💡 Best Practices</h3>
<h4 id="1-circular-reference-maintenance">1. Circular Reference Maintenance</h4>
<pre><code class="language-java">// Always ensure last node points to first
tail.next = tail.next.next;  // When removing
newNode.next = tail.next;    // When adding
</code></pre>
<h4 id="2-empty-list-handling">2. Empty List Handling</h4>
<pre><code class="language-java">if (isEmpty()) {
    // New node points to itself
    newNode.next = newNode;
    tail = newNode;
}
</code></pre>
<h4 id="3-single-element-handling">3. Single Element Handling</h4>
<pre><code class="language-java">if (size == 1) {
    tail = null;  // For removal
    // OR
    tail = newNode;  // For insertion
}
</code></pre>
<h3 id="common-pitfalls_3">⚠️ Common Pitfalls</h3>
<h4 id="1-infinite-loops">1. Infinite Loops</h4>
<pre><code class="language-java">// WRONG - May loop forever
while (current.next != null) {  // Never true in circular list
    current = current.next;
}

// CORRECT
do {
    current = current.next;
} while (current != tail.next);
</code></pre>
<h4 id="2-lost-circular-reference">2. Lost Circular Reference</h4>
<pre><code class="language-java">// WRONG - Loses circular structure
tail.next = newNode;

// CORRECT - Maintains circular structure
newNode.next = tail.next;
tail.next = newNode;
</code></pre>
<h4 id="reference_1">Reference</h4>
<p><a href="https://youtube.com/playlist?list=PLBlnK6fEyqRjW4jK-CbshJuX20nc_3IaN&amp;si=X7n0-QAF54ZSsf0_">Circular Linked List Playlist</a></p>
<h1 id="stack">📚 Stack</h1>
<p><img alt="enter image description here" src="https://i.postimg.cc/02Pp6Hbt/temp-Image-Ic-V6uh.avif" /></p>
<h3 id="introduction_1">Introduction</h3>
<p>A Stack is a linear data structure that follows the LIFO (Last In First Out) principle. Like a stack of plates, elements are added and removed from the same end, called the top of the stack. This fundamental data structure is ideal for scenarios where we need strict order control over our operations.</p>
<h3 id="core-characteristics_4">Core Characteristics</h3>
<ul>
<li>📥 LIFO (Last In, First Out) principle</li>
<li>🎯 Single point of access (top)</li>
<li>📏 Dynamic sizing through array resizing</li>
<li>🔄 Ordered operations</li>
<li>⚡ Constant time operations (amortized)</li>
</ul>
<h3 id="implementation-details_4">Implementation Details</h3>
<h4 id="structure_4">Structure</h4>
<pre><code class="language-java">public class Stack&lt;T&gt; {
    // Default capacity when no size is specified
    private static final int DEFAULT_CAPACITY = 10;

    // Internal array to store elements
    private T[] backingArray;

    // Keep track of the next available position
    private int size;

    // Constructor with default capacity
    @SuppressWarnings(&quot;unchecked&quot;)
    public Stack() {
        backingArray = (T[]) new Object[DEFAULT_CAPACITY];
        size = 0;
    }

    // Constructor with specified initial capacity
    @SuppressWarnings(&quot;unchecked&quot;)
    public Stack(int initialCapacity) {
        if (initialCapacity &lt; 0) {
            throw new IllegalArgumentException(&quot;Initial capacity cannot be negative&quot;);
        }
        backingArray = (T[]) new Object[initialCapacity];
        size = 0;
    }
}
</code></pre>
<h3 id="core-operations_1">🔧 Core Operations</h3>
<h4 id="push-operation">Push Operation</h4>
<pre><code class="language-java">public void push(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Cannot push null data&quot;);
    }

    // Check if we need to resize
    if (size == backingArray.length) {
        resize();
    }

    // Add element and increment size
    backingArray[size++] = data;
}

@SuppressWarnings(&quot;unchecked&quot;)
private void resize() {
    T[] newArray = (T[]) new Object[backingArray.length * 2];
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[i];
    }
    backingArray = newArray;
}  
</code></pre>
<p>⏱️ Time Complexity: O(1) amortized
-   💭 When to Use: Adding new elements to the stack
-   ⚠️ Key Points:
    -   Handles null check
    -   Automatic resizing
    -   Maintains LIFO order</p>
<h4 id="pop-operation">Pop Operation</h4>
<pre><code class="language-java">public T pop() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Cannot pop from empty stack&quot;);
    }

    // Retrieve element and decrement size
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference for garbage collection
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Removing and retrieving the most recently added element</li>
<li>⚠️ Key Points:<ul>
<li>Checks for empty stack</li>
<li>Cleans up references</li>
<li>Maintains LIFO order</li>
</ul>
</li>
</ul>
<h4 id="peek-operation">Peek Operation</h4>
<pre><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Cannot peek empty stack&quot;);
    }
    return backingArray[size - 1];
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Viewing top element without removal</li>
<li>⚠️ Key Points:<ul>
<li>No modification to stack</li>
<li>Preserves state</li>
<li>Checks for empty stack</li>
</ul>
</li>
</ul>
<h4 id="utility-operations">Utility Operations</h4>
<pre><code class="language-java">// Check if stack is empty
public boolean isEmpty() {
    return size == 0;
}

// Get current number of elements
public int size() {
    return size;
}

// Clear all elements
@SuppressWarnings(&quot;unchecked&quot;)
public void clear() {
    backingArray = (T[]) new Object[DEFAULT_CAPACITY];
    size = 0;
}
</code></pre>
<h3 id="performance-summary_4">📊 Performance Summary</h3>
<h2 id="performance-summary_5">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Push</td>
<td>O(1)*</td>
<td>Amortized for resizing</td>
</tr>
<tr>
<td>Pop</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity accounts for occasional resizing operations</p>
<h3 id="best-practices_4">💡 Best Practices</h3>
<h4 id="1-memory-management">1. Memory Management</h4>
<pre><code class="language-java">// Always clear references when removing elements
public T pop() {
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference
    return data;
}
</code></pre>
<h4 id="2-capacity-handling">2. Capacity Handling</h4>
<pre><code class="language-java">// Consider shrinking array when usage is low
private void shrinkIfNeeded() {
    if (size &gt; 0 &amp;&amp; size &lt; backingArray.length / 4) {
        resize(backingArray.length / 2);
    }
}
</code></pre>
<h4 id="3-null-checking">3. Null Checking</h4>
<pre><code class="language-java">// Always validate input
public void push(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
    // push implementation
}
</code></pre>
<h3 id="common-pitfalls_4">⚠️ Common Pitfalls</h3>
<h4 id="1-memory-leaks">1. Memory Leaks</h4>
<pre><code class="language-java">// WRONG - Memory leak
public T pop() {
    return backingArray[--size];  // Reference still held
}

// CORRECT - Clear reference
public T pop() {
    T data = backingArray[--size];
    backingArray[size] = null;  // Clear reference
    return data;
}
</code></pre>
<h4 id="2-bound-checking">2. Bound Checking</h4>
<pre><code class="language-java">// WRONG - No empty check
public T peek() {
    return backingArray[size - 1];  // Possible IndexOutOfBoundsException
}

// CORRECT - With empty check
public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Stack is empty&quot;);
    }
    return backingArray[size - 1];
}
</code></pre>
<h3 id="common-use-cases_1">🎯 Common Use Cases</h3>
<h4 id="1-function-call-stack">1. Function Call Stack</h4>
<pre><code class="language-java">Stack&lt;FunctionCall&gt; callStack = new Stack&lt;&gt;();
callStack.push(new FunctionCall(&quot;main&quot;));
callStack.push(new FunctionCall(&quot;helper&quot;));
// Current function is helper
callStack.pop();  // Return to main
</code></pre>
<h4 id="2-expression-evaluation">2. Expression Evaluation</h4>
<pre><code class="language-java">Stack&lt;Character&gt; parentheses = new Stack&lt;&gt;();
for (char c : expression.toCharArray()) {
    if (c == '(') {
        parentheses.push(c);
    } else if (c == ')') {
        if (!parentheses.isEmpty()) {
            parentheses.pop();
        } else {
            // Unmatched closing parenthesis
        }
    }
}
</code></pre>
<h4 id="3-undoredo-operations">3. Undo/Redo Operations</h4>
<pre><code class="language-java">Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();
Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();

void executeCommand(Command cmd) {
    cmd.execute();
    undoStack.push(cmd);
    redoStack.clear();  // Clear redo history
}
</code></pre>
<h3 id="references_3">References</h3>
<p><a href="https://youtu.be/L3ud3rXpIxA?si=m0pon3ja-WW28DON">Stack Introduction</a>
<a href="https://youtu.be/RAMqDLI6_1c?si=OAPRPe-3-4nyqBCK">Stack Implementation</a></p>
<h1 id="queue">🎯 Queue</h1>
<p><img alt="Queues" src="https://i.postimg.cc/CMfGSBqV/temp-Imagee-Hk-FO3.avif" /></p>
<h3 id="introduction_2">Introduction</h3>
<p>A Queue is a linear data structure following the FIFO (First In, First Out) principle. Using a circular array implementation allows for efficient space usage and constant time operations by reusing array spaces that have been dequeued.</p>
<h3 id="core-characteristics_5">Core Characteristics</h3>
<ul>
<li>📥 FIFO (First In, First Out) ordering</li>
<li>🔄 Circular array implementation</li>
<li>📏 Dynamic sizing</li>
<li>⚡ Constant time operations (amortized)</li>
<li>🎯 Space efficient</li>
</ul>
<h3 id="implementation-details_5">Implementation Details</h3>
<h3 id="structure_5">Structure</h3>
<pre><code class="language-java">public class Queue&lt;T&gt; {
    private T[] backingArray;
    private int front;      // Index of the front element
    private int size;       // Number of elements in queue
    private static final int INITIAL_CAPACITY = 10;

    @SuppressWarnings(&quot;unchecked&quot;)
    public Queue() {
        backingArray = (T[]) new Object[INITIAL_CAPACITY];
        front = 0;
        size = 0;
    }
}
</code></pre>
<h3 id="core-operations_2">🔧 Core Operations</h3>
<h4 id="enqueue-operation">Enqueue Operation</h4>
<pre><code class="language-java">public void enqueue(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Cannot enqueue null data&quot;);
    }

    // Check if we need to resize
    if (size == backingArray.length) {
        resize();
    }

    // Calculate rear index using modulo for circular behavior
    int rear = (front + size) % backingArray.length;
    backingArray[rear] = data;
    size++;
}

@SuppressWarnings(&quot;unchecked&quot;)
private void resize() {
    T[] newArray = (T[]) new Object[backingArray.length * 2];
    // Copy elements in order, starting from front
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[(front + i) % backingArray.length];
    }
    backingArray = newArray;
    front = 0;  // Reset front to beginning of new array
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1) amortized</li>
<li>💭 When to Use: Adding elements to queue</li>
<li>⚠️ Key Points:<ul>
<li>Handles null check</li>
<li>Circular indexing with modulo</li>
<li>Resizes when full</li>
</ul>
</li>
</ul>
<h4 id="dequeue-operation">Dequeue Operation</h4>
<pre><code class="language-java">public T dequeue() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Queue is empty&quot;);
    }

    T data = backingArray[front];
    backingArray[front] = null;  // Help GC
    front = (front + 1) % backingArray.length;
    size--;
    return data;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Removing elements from front</li>
<li>⚠️ Key Points:<ul>
<li>Handles empty queue</li>
<li>Maintains circular structure</li>
<li>Cleans up references</li>
</ul>
</li>
</ul>
<h4 id="peek-operation_1">Peek Operation</h4>
<pre><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Queue is empty&quot;);
    }
    return backingArray[front];
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Examining front element</li>
<li>⚠️ Key Points:<ul>
<li>No modification to queue</li>
<li>Front element access</li>
</ul>
</li>
</ul>
<h4 id="utility-operations_1">Utility Operations</h4>
<pre><code class="language-java">public boolean isEmpty() {
    return size == 0;
}

public int size() {
    return size;
}

@SuppressWarnings(&quot;unchecked&quot;)
public void clear() {
    backingArray = (T[]) new Object[INITIAL_CAPACITY];
    front = 0;
    size = 0;
}
</code></pre>
<h3 id="performance-summary_6">📊 Performance Summary</h3>
<h2 id="performance-summary_7">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Enqueue</td>
<td>O(1)*</td>
<td>Amortized for resizing</td>
</tr>
<tr>
<td>Dequeue</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
</tbody>
</table>
<p>* Amortized time complexity accounts for occasional resizing operations</p>
<h3 id="best-practices_5">💡 Best Practices</h3>
<h4 id="1-circular-index-calculation">1. Circular Index Calculation</h4>
<pre><code class="language-java">// Calculate next index with modulo
private int getNextIndex(int currentIndex) {
    return (currentIndex + 1) % backingArray.length;
}

// Calculate rear index
private int getRearIndex() {
    return (front + size) % backingArray.length;
}
</code></pre>
<h4 id="2-resizing-strategy">2. Resizing Strategy</h4>
<pre><code class="language-java">private void resize() {
    // Double size for amortized O(1)
    T[] newArray = (T[]) new Object[backingArray.length * 2];

    // Copy in order from front to rear
    for (int i = 0; i &lt; size; i++) {
        newArray[i] = backingArray[(front + i) % backingArray.length];
    }
    front = 0;  // Reset front after resize
    backingArray = newArray;
}
</code></pre>
<h4 id="3-memory-management_2">3. Memory Management</h4>
<pre><code class="language-java">public T dequeue() {
    T data = backingArray[front];
    backingArray[front] = null;  // Clear reference
    front = (front + 1) % backingArray.length;
    size--;
    return data;
}
</code></pre>
<h3 id="common-pitfalls_5">⚠️ Common Pitfalls</h3>
<h4 id="1-incorrect-circular-indexing">1. Incorrect Circular Indexing</h4>
<pre><code class="language-java">// WRONG - May cause overflow
rear = rear + 1;
if (rear == backingArray.length) rear = 0;

// CORRECT - Use modulo
rear = (rear + 1) % backingArray.length;
</code></pre>
<h4 id="2-resizing-issues">2. Resizing Issues</h4>
<pre><code class="language-java">// WRONG - Doesn't maintain order
System.arraycopy(backingArray, 0, newArray, 0, backingArray.length);

// CORRECT - Maintains order from front
for (int i = 0; i &lt; size; i++) {
    newArray[i] = backingArray[(front + i) % backingArray.length];
}
</code></pre>
<h3 id="common-use-cases_2">🎯 Common Use Cases</h3>
<h4 id="1-task-scheduling">1. Task Scheduling</h4>
<pre><code class="language-java">Queue&lt;Task&gt; taskQueue = new Queue&lt;&gt;();
taskQueue.enqueue(new Task(&quot;Process payment&quot;));
taskQueue.enqueue(new Task(&quot;Send email&quot;));

while (!taskQueue.isEmpty()) {
    Task nextTask = taskQueue.dequeue();
    processTask(nextTask);
}
</code></pre>
<h4 id="2-bfs-implementation">2. BFS Implementation</h4>
<pre><code class="language-java">public void bfs(Node root) {
    Queue&lt;Node&gt; queue = new Queue&lt;&gt;();
    queue.enqueue(root);

    while (!queue.isEmpty()) {
        Node current = queue.dequeue();
        for (Node child : current.getChildren()) {
            queue.enqueue(child);
        }
    }
}
</code></pre>
<h4 id="3-buffer-implementation">3. Buffer Implementation</h4>
<pre><code class="language-java">public class Buffer&lt;T&gt; {
    private Queue&lt;T&gt; queue = new Queue&lt;&gt;();
    private final int capacity;

    public void write(T data) {
        if (queue.size() &lt; capacity) {
            queue.enqueue(data);
        }
    }

    public T read() {
        return queue.isEmpty() ? null : queue.dequeue();
    }
}
</code></pre>
<h3 id="references_4">References</h3>
<p><a href="https://youtu.be/KxzhEQ-zpDc?si=kiGsG9eco3fsXaHR">Queue Introduction</a>
<a href="https://youtu.be/EoisnPvUkOA?si=qoqVyM2dcjYFMrVa">Queue Implementation</a></p>
<h1 id="tree-based-structures_1">🌳 Tree-Based Structures</h1>
<h1 id="priority-queue">📊 Priority Queue</h1>
<p><img alt="Priority Queue" src="https://i.postimg.cc/7ZSt6tJw/temp-Imagez-FB1-Iv.avif" /></p>
<h3 id="introduction_3">Introduction</h3>
<p>A Priority Queue is an advanced queue that orders elements by their priority rather than insertion order. It's commonly implemented using a heap data structure, typically a min-heap or max-heap. In this implementation, we'll focus on a min-heap based priority queue where lower values have higher priority.</p>
<h3 id="core-characteristics_6">Core Characteristics</h3>
<ul>
<li>📈 Priority-based ordering</li>
<li>🌳 Heap-based implementation</li>
<li>📏 Dynamic sizing</li>
<li>🔄 Self-balancing structure</li>
<li>⚡ Logarithmic time operations</li>
</ul>
<h3 id="implementation-details_6">Implementation Details</h3>
<h4 id="structure_6">Structure</h4>
<pre><code class="language-java">public class PriorityQueue&lt;T extends Comparable&lt;? super T&gt;&gt; {
    // Initial capacity of the priority queue
    private static final int INITIAL_CAPACITY = 13;

    // Backing array for the heap
    private T[] backingArray;

    // Number of elements in the queue
    private int size;

    @SuppressWarnings(&quot;unchecked&quot;)
    public PriorityQueue() {
        backingArray = (T[]) new Comparable[INITIAL_CAPACITY];
        size = 0;
    }
}
</code></pre>
<h3 id="core-operations_3">🔧 Core Operations</h3>
<h4 id="add-operation">Add Operation</h4>
<pre><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Cannot add null data&quot;);
    }

    // Resize if necessary
    if (size + 1 == backingArray.length) {
        resize();
    }

    // Add element to the end and restore heap property
    backingArray[++size] = data;
    upHeap(size);
}

private void upHeap(int index) {
    while (index &gt; 1 &amp;&amp; 
           backingArray[index].compareTo(backingArray[index / 2]) &lt; 0) {
        swap(backingArray, index, index / 2);
        index = index / 2;
    }
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n)</li>
<li>💭 When to Use: Adding new elements with priority</li>
<li>⚠️ Key Points:<ul>
<li>Maintains heap property</li>
<li>Handles resizing</li>
<li>Null checking</li>
</ul>
</li>
</ul>
<h4 id="remove-operation">Remove Operation</h4>
<pre><code class="language-java">public T remove() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Queue is empty&quot;);
    }

    T removed = backingArray[1];
    backingArray[1] = backingArray[size];
    backingArray[size--] = null;

    if (!isEmpty()) {
        downHeap(1);
    }

    return removed;
}

private void downHeap(int index) {
    while (2 * index &lt;= size) {
        int j = 2 * index;
        if (j &lt; size &amp;&amp; backingArray[j].compareTo(backingArray[j + 1]) &gt; 0) {
            j++;
        }
        if (backingArray[index].compareTo(backingArray[j]) &lt;= 0) {
            break;
        }
        swap(backingArray, index, j);
        index = j;
    }
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n)</li>
<li>💭 When to Use: Removing highest priority element</li>
<li>⚠️ Key Points:<ul>
<li>Maintains heap order</li>
<li>Handles empty case</li>
<li>Cleans references</li>
</ul>
</li>
</ul>
<h4 id="peek-operation_2">Peek Operation</h4>
<pre><code class="language-java">public T peek() {
    if (isEmpty()) {
        throw new NoSuchElementException(&quot;Queue is empty&quot;);
    }
    return backingArray[1];
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Viewing highest priority element</li>
<li>⚠️ Key Points:<ul>
<li>No modification to structure</li>
<li>Empty check</li>
</ul>
</li>
</ul>
<h3 id="performance-summary_8">📊 Performance Summary</h3>
<h2 id="performance-summary_9">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add/Offer</td>
<td>O(log n)</td>
<td>Requires upheap</td>
</tr>
<tr>
<td>Remove/Poll</td>
<td>O(log n)</td>
<td>Requires downheap</td>
</tr>
<tr>
<td>Peek</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Constant time</td>
</tr>
<tr>
<td>Clear</td>
<td>O(1)</td>
<td>New array allocation</td>
</tr>
<tr>
<td>### 💡 Best Practices</td>
<td></td>
<td></td>
</tr>
<tr>
<td>#### 1. Maintain Heap Property</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-java">private void swap(T[] arr, int i, int j) {
    T temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

private int parent(int index) {
    return index / 2;
}

private int leftChild(int index) {
    return 2 * index;
}

private int rightChild(int index) {
    return 2 * index + 1;
}
</code></pre>
<h4 id="2-efficient-resizing">2. Efficient Resizing</h4>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)
private void resize() {
    T[] newArray = (T[]) new Comparable[backingArray.length * 2];
    for (int i = 1; i &lt;= size; i++) {
        newArray[i] = backingArray[i];
    }
    backingArray = newArray;
}
</code></pre>
<h4 id="3-handle-special-cases">3. Handle Special Cases</h4>
<pre><code class="language-java">public boolean isEmpty() {
    return size == 0;
}

@SuppressWarnings(&quot;unchecked&quot;)
public void clear() {
    backingArray = (T[]) new Comparable[INITIAL_CAPACITY];
    size = 0;
}
</code></pre>
<h3 id="common-pitfalls_6">⚠️ Common Pitfalls</h3>
<h4 id="1-index-management">1. Index Management</h4>
<pre><code class="language-java">// WRONG - Using 0-based indexing
private int parent(int i) {
    return (i - 1) / 2;
}

// CORRECT - Using 1-based indexing
private int parent(int i) {
    return i / 2;
}
</code></pre>
<h4 id="2-comparator-consistency">2. Comparator Consistency</h4>
<pre><code class="language-java">// WRONG - Inconsistent comparison
if (a.someValue() &lt; b.someValue()) {
    swap(a, b);
}

// CORRECT - Use compareTo
if (a.compareTo(b) &lt; 0) {
    swap(a, b);
}
</code></pre>
<h3 id="common-use-cases_3">🎯 Common Use Cases</h3>
<h4 id="1-task-scheduling_1">1. Task Scheduling</h4>
<pre><code class="language-java">class Task implements Comparable&lt;Task&gt; {
    private int priority;
    private String description;

    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
}

PriorityQueue&lt;Task&gt; taskQueue = new PriorityQueue&lt;&gt;();
taskQueue.add(new Task(1, &quot;High Priority&quot;));
taskQueue.add(new Task(3, &quot;Low Priority&quot;));
</code></pre>
<h4 id="2-dijkstras-algorithm">2. Dijkstra's Algorithm</h4>
<pre><code class="language-java">PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; 
    Integer.compare(a.distance, b.distance));
pq.add(source);
while (!pq.isEmpty()) {
    Node current = pq.remove();
    // Process node
}
</code></pre>
<h4 id="3-event-processing">3. Event Processing</h4>
<pre><code class="language-java">class Event implements Comparable&lt;Event&gt; {
    private long timestamp;

    @Override
    public int compareTo(Event other) {
        return Long.compare(this.timestamp, other.timestamp);
    }
}

PriorityQueue&lt;Event&gt; events = new PriorityQueue&lt;&gt;();
events.add(new Event(System.currentTimeMillis()));
</code></pre>
<h3 id="references_5">References</h3>
<p><a href="https://youtu.be/wptevk0bshY?si=620-DcPMa14F0lL5">Priority Queue Introduction</a>
<a href="https://youtu.be/HCEr35qpawQ?si=V1_BJIdDTXqDzI3z">Priority Queue Min Heaps and Max Heaps</a>
<a href="https://youtu.be/QOJ-CmQiXko?si=MJCRzTB1yDV0qfcF">Priority Queue Adding Elements</a>
<a href="https://youtu.be/eVq8CmoC1x8?si=S9Lrx5MllIeqzrT-">Priority Queue Removing Elements</a></p>
<h1 id="binary-tree">🌳 Binary Tree</h1>
<p><img alt="Binary Tree Router" src="https://i.postimg.cc/52SBdTL6/temp-Image-B78xzp.avif" /></p>
<h3 id="introduction_4">Introduction</h3>
<p>A Binary Tree is a hierarchical, non-linear data structure where each node has at most two children, referred to as left child and right child. Unlike arrays or linked lists that store data sequentially, Binary Trees allow for representing hierarchical relationships between elements.</p>
<h3 id="core-characteristics_7">Core Characteristics</h3>
<ul>
<li>🌿 Each node has at most two children</li>
<li>🔝 Single root node</li>
<li>📊 Hierarchical structure</li>
<li>🔄 Recursive nature</li>
<li>🎯 Multiple traversal options</li>
</ul>
<h3 id="implementation-details_7">Implementation Details</h3>
<h4 id="structure_7">Structure</h4>
<pre><code class="language-java">public class BinaryTree&lt;T&gt; {
    private Node&lt;T&gt; root;
    private int size;

    private static class Node&lt;T&gt; {
        T data;
        Node&lt;T&gt; left;
        Node&lt;T&gt; right;

        Node(T data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }

    public BinaryTree() {
        root = null;
        size = 0;
    }
}
</code></pre>
<h3 id="core-operations_4">🔧 Core Operations</h3>
<h4 id="traversal-operations">Traversal Operations</h4>
<pre><code class="language-java">// InOrder Traversal (Left, Root, Right)
public void inOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        inOrderTraversal(node.left);
        process(node.data);
        inOrderTraversal(node.right);
    }
}

// PreOrder Traversal (Root, Left, Right)
public void preOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        process(node.data);
        preOrderTraversal(node.left);
        preOrderTraversal(node.right);
    }
}

// PostOrder Traversal (Left, Right, Root)
public void postOrderTraversal(Node&lt;T&gt; node) {
    if (node != null) {
        postOrderTraversal(node.left);
        postOrderTraversal(node.right);
        process(node.data);
    }
}

// Level Order Traversal (BFS)
public void levelOrderTraversal() {
    if (root == null) return;

    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node&lt;T&gt; current = queue.poll();
        process(current.data);

        if (current.left != null) queue.offer(current.left);
        if (current.right != null) queue.offer(current.right);
    }
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n) for all traversals</li>
<li>💭 When to Use: Different traversal orders for different needs</li>
<li>⚠️ Key Points: Each traversal visits all nodes exactly once</li>
</ul>
<h4 id="insertion-operation">Insertion Operation</h4>
<pre><code class="language-java">public void insert(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    if (root == null) {
        root = new Node&lt;&gt;(data);
        size++;
        return;
    }

    // Level-order insertion
    Queue&lt;Node&lt;T&gt;&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node&lt;T&gt; current = queue.poll();

        if (current.left == null) {
            current.left = new Node&lt;&gt;(data);
            size++;
            return;
        } else {
            queue.offer(current.left);
        }

        if (current.right == null) {
            current.right = new Node&lt;&gt;(data);
            size++;
            return;
        } else {
            queue.offer(current.right);
        }
    }
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 When to Use: Adding new nodes to the tree</li>
<li>⚠️ Key Points: Level-order insertion maintains tree balance</li>
</ul>
<h4 id="search-operation_1">Search Operation</h4>
<pre><code class="language-java">public boolean contains(T data) {
    return searchHelper(root, data);
}

private boolean searchHelper(Node&lt;T&gt; node, T data) {
    if (node == null) return false;

    if (node.data.equals(data)) return true;

    return searchHelper(node.left, data) || 
           searchHelper(node.right, data);
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 When to Use: Finding elements in the tree</li>
<li>⚠️ Key Points: Must traverse potentially entire tree</li>
</ul>
<h3 id="performance-summary_10">📊 Performance Summary</h3>
<h2 id="performance-summary_11">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insertion</td>
<td>O(n)</td>
<td>Level-order insertion</td>
</tr>
<tr>
<td>Search</td>
<td>O(n)</td>
<td>Worst case traversal</td>
</tr>
<tr>
<td>Deletion</td>
<td>O(n)</td>
<td>Find and reorganize</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>All traversal types</td>
</tr>
<tr>
<td>Height</td>
<td>O(n)</td>
<td>Must visit all nodes</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>Maintained variable</td>
</tr>
<tr>
<td>isEmpty</td>
<td>O(1)</td>
<td>Check root null</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_6">💡 Best Practices</h3>
<h4 id="1-proper-node-handling">1. Proper Node Handling</h4>
<pre><code class="language-java">private void validate(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
}
</code></pre>
<h4 id="2-traversal-selection">2. Traversal Selection</h4>
<pre><code class="language-java">// Use appropriate traversal for the task
// InOrder: Sorted sequence in BST
// PreOrder: Copy/serialize tree
// PostOrder: Delete tree/calculate size
// LevelOrder: Level-based processing
</code></pre>
<h4 id="3-memory-management_3">3. Memory Management</h4>
<pre><code class="language-java">public void clear() {
    root = null;  // Allow GC to clean up
    size = 0;
}
</code></pre>
<h3 id="common-pitfalls_7">⚠️ Common Pitfalls</h3>
<h4 id="1-not-handling-null-cases">1. Not Handling Null Cases</h4>
<pre><code class="language-java">// WRONG
public void process(Node&lt;T&gt; node) {
    process(node.left);  // NPE if node is null
}  

// CORRECT
public void process(Node&lt;T&gt; node) {
    if (node == null) return;
    process(node.left);
}
</code></pre>
<h4 id="2-improper-traversal-choice">2. Improper Traversal Choice</h4>
<pre><code class="language-java">// WRONG - Using inOrder for level-based processing
// CORRECT - Use levelOrder for level-based operations
public void printLevelByLevel() {
    levelOrderTraversal();
}
</code></pre>
<h3 id="common-use-cases_4">🎯 Common Use Cases</h3>
<h4 id="1-file-system-representation">1. File System Representation</h4>
<pre><code class="language-java">class FileNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isDirectory;
    // File system specific operations
}
</code></pre>
<h4 id="2-expression-trees">2. Expression Trees</h4>
<pre><code class="language-java">class ExpressionNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isOperator;
    public double evaluate() {
        // Evaluation logic
    }
}
</code></pre>
<h4 id="3-decision-trees">3. Decision Trees</h4>
<pre><code class="language-java">class DecisionNode&lt;T&gt; extends Node&lt;T&gt; {
    boolean isLeaf;
    public T decide(Input input) {
        // Decision logic
    }
}
</code></pre>
<h3 id="references_6">References</h3>
<p><a href="https://youtu.be/H5JubkIy_p8?si=0SZXcikEuU6108b1">Binary Tree Data Structure</a></p>
<h1 id="binary-search-tree">🌳 Binary Search Tree</h1>
<p><img alt="Binary Search Tree" src="https://i.postimg.cc/sDrLyFbr/temp-Image-Tazx-Mr.avif" /></p>
<h3 id="introduction_5">Introduction</h3>
<p>A Binary Search Tree (BST) is a binary tree that maintains an ordering property: for each node, all elements in its left subtree are less than the node's value, and all elements in its right subtree are greater. This property makes BSTs efficient for searching, inserting, and deleting elements.</p>
<h3 id="core-characteristics_8">Core Characteristics</h3>
<ul>
<li>📊 Ordered structure</li>
<li>🔍 Efficient searching</li>
<li>🎯 Dynamic operations</li>
<li>🌿 Binary tree properties</li>
<li>⚖️ Balance affects performance</li>
</ul>
<h3 id="implementation-details_8">Implementation Details</h3>
<h4 id="structure_8">Structure</h4>
<pre><code class="language-java">public class BST&lt;T extends Comparable&lt;? super T&gt;&gt; {
    private BSTNode&lt;T&gt; root;
    private int size;

    private static class BSTNode&lt;T&gt; {
        T data;
        BSTNode&lt;T&gt; left;
        BSTNode&lt;T&gt; right;

        BSTNode(T data) {
            this.data = data;
            left = null;
            right = null;
        }
    }
}
</code></pre>
<h3 id="core-operations_5">🔧 Core Operations</h3>
<h4 id="add-operation_1">Add Operation</h4>
<pre><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
    root = addHelper(data, root);
}

private BSTNode&lt;T&gt; addHelper(T data, BSTNode&lt;T&gt; node) {
    if (node == null) {
        size++;
        return new BSTNode&lt;&gt;(data);
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = addHelper(data, node.left);
    } else if (compare &gt; 0) {
        node.right = addHelper(data, node.right);
    }
    return node;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n) average, O(n) worst case</li>
<li>💭 When to Use: Inserting new elements while maintaining order</li>
<li>⚠️ Key Points:<ul>
<li>Maintains BST property</li>
<li>Handles duplicates</li>
<li>Recursive implementation</li>
</ul>
</li>
</ul>
<h4 id="remove-operation_1">Remove Operation</h4>
<pre><code class="language-java">public T remove(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    BSTNode&lt;T&gt; dummy = new BSTNode&lt;&gt;(null);
    root = removeHelper(data, root, dummy);
    return dummy.data;
}

private BSTNode&lt;T&gt; removeHelper(T data, BSTNode&lt;T&gt; node, BSTNode&lt;T&gt; dummy) {
    if (node == null) {
        throw new NoSuchElementException(&quot;Data not found&quot;);
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = removeHelper(data, node.left, dummy);
    } else if (compare &gt; 0) {
        node.right = removeHelper(data, node.right, dummy);
    } else {
        dummy.data = node.data;
        size--;

        if (node.left == null) {
            return node.right;
        } else if (node.right == null) {
            return node.left;
        } else {
            BSTNode&lt;T&gt; successor = findSuccessor(node.right);
            node.data = successor.data;
            node.right = removeHelper(successor.data, node.right, dummy);
        }
    }
    return node;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n) average, O(n) worst case</li>
<li>💭 When to Use: Removing elements while maintaining order</li>
<li>⚠️ Key Points:<ul>
<li>Three cases: leaf, one child, two children</li>
<li>Uses successor for two-child case</li>
<li>Maintains BST property</li>
</ul>
</li>
</ul>
<h4 id="search-operation_2">Search Operation</h4>
<pre><code class="language-java">public T get(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }

    BSTNode&lt;T&gt; node = getHelper(data, root);
    if (node == null) {
        throw new NoSuchElementException(&quot;Data not found&quot;);
    }
    return node.data;
}

private BSTNode&lt;T&gt; getHelper(T data, BSTNode&lt;T&gt; node) {
    if (node == null) {
        return null;
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        return getHelper(data, node.left);
    } else if (compare &gt; 0) {
        return getHelper(data, node.right);
    }
    return node;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n) average, O(n) worst case</li>
<li>💭 When to Use: Finding elements in the tree</li>
<li>⚠️ Key Points:<ul>
<li>Uses comparisons for direction</li>
<li>Returns stored data</li>
<li>Handles not found case</li>
</ul>
</li>
</ul>
<h3 id="traversal-operations_1">Traversal Operations</h3>
<pre><code class="language-java">// In-order traversal (sorted order)
public List&lt;T&gt; inorder() {
    List&lt;T&gt; result = new ArrayList&lt;&gt;();
    inorderHelper(root, result);
    return result;
}

private void inorderHelper(BSTNode&lt;T&gt; node, List&lt;T&gt; result) {
    if (node != null) {
        inorderHelper(node.left, result);
        result.add(node.data);
        inorderHelper(node.right, result);
    }
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(n)</li>
<li>💭 When to Use: Getting elements in sorted order</li>
<li>⚠️ Key Points:<ul>
<li>In-order gives sorted sequence</li>
<li>Pre-order for copying tree</li>
<li>Post-order for deletion</li>
</ul>
</li>
</ul>
<h2 id="performance-summary_12">📊 Performance Summary</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Remove</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Search</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>Unbalanced case</td>
</tr>
<tr>
<td>Traversal</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Visits all nodes</td>
</tr>
<tr>
<td>Height</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Cached value</td>
</tr>
<tr>
<td>Size</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Maintained count</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_7">💡 Best Practices</h3>
<h4 id="1-balance-maintenance">1. Balance Maintenance</h4>
<pre><code class="language-jav">// Consider using self-balancing variants for better performance guarantees
// AVL or Red-Black trees for automatic balancing
</code></pre>
<h4 id="2-comparison-handling">2. Comparison Handling</h4>
<pre><code class="language-java">// Use compareTo consistently
int compare = data.compareTo(node.data);
if (compare &lt; 0) {
    // Go left
} else if (compare &gt; 0) {
    // Go right
}
</code></pre>
<h4 id="3-null-handling">3. Null Handling</h4>
<pre><code class="language-java">// Always validate input
if (data == null) {
    throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
}
</code></pre>
<h3 id="common-pitfalls_8">⚠️ Common Pitfalls</h3>
<h4 id="1-unbalanced-trees">1. Unbalanced Trees</h4>
<pre><code class="language-java">// WRONG - Adding sorted data creates linear structure
bst.add(1);
bst.add(2);
bst.add(3);  // Creates right-skewed tree

// BETTER - Balance the tree or use self-balancing variant
</code></pre>
<h4 id="2-memory-management">2. Memory Management</h4>
<pre><code class="language-java">// WRONG - Memory leak in remove
node = null;  // Only removes reference

// CORRECT - Clean all references
node.left = null;
node.right = null;
node.data = null;
node = null;
</code></pre>
<h3 id="common-use-cases_5">🎯 Common Use Cases</h3>
<h4 id="1-dictionary-implementation">1. Dictionary Implementation</h4>
<pre><code class="language-java">BST&lt;String&gt; dictionary = new BST&lt;&gt;();
dictionary.add(&quot;apple&quot;);
dictionary.add(&quot;banana&quot;);
// Fast lookups: O(log n) average
</code></pre>
<h4 id="2-priority-management">2. Priority Management</h4>
<pre><code class="language-java">BST&lt;Task&gt; tasks = new BST&lt;&gt;();
tasks.add(new Task(1, &quot;High Priority&quot;));
tasks.add(new Task(2, &quot;Medium Priority&quot;));
// Natural ordering of tasks
</code></pre>
<h4 id="3-symbol-tables">3. Symbol Tables</h4>
<pre><code class="language-java">BST&lt;Symbol&gt; symbolTable = new BST&lt;&gt;();
symbolTable.add(new Symbol(&quot;x&quot;, 10));
symbolTable.add(new Symbol(&quot;y&quot;, 20));
// Efficient symbol lookup
</code></pre>
<h3 id="references_7">References</h3>
<p><a href="https://youtu.be/pYT9F8_LFTM?si=llySEAWqBX3jJ_tN">Binary Search Trees</a>
<a href="https://youtu.be/JfSdGQdAzq8?si=EKKPhNxENwZlQWNB">Binary Search Tree Introduction</a>
<a href="https://youtu.be/LwpLXm3eb6A?si=xvpTFxTCcW1JY55R">Binary Search Tree Insertion</a>
<a href="https://youtu.be/8K7EO7s_iFE?si=cm7yYT1m76rhtzLn">Binary Search Tree Removal</a>
<a href="https://youtu.be/k7GkEbECZK0?si=ULXRc1mnU2cfijtM">Binary Search Tree Traversal</a></p>
<h1 id="advanced-tree-based-structures_1">🌲 Advanced Tree-Based Structures</h1>
<h1 id="avl-trees">🌳 AVL Trees</h1>
<p><img alt="AVL Tree" src="https://i.postimg.cc/ZKHM6RMf/temp-Image-Ie-Nfq-P.avif" /></p>
<p>An AVL Tree is a self-balancing bin tree where the heights of the left and right subtrees of any node differ by at most one. This balance ot ensures that the tree remains approximately balanced during insertion deletions, maintaining O(log n) time complexity for all operations.</p>
<h3 id="core-characteristics_9">Core Characteristics</h3>
<ul>
<li>🔄 Self-balancing mechanism</li>
<li>📏 Height tracking</li>
<li>⚖️ Balance factor management</li>
<li>🎯 BST properties maintained</li>
<li>🔍 Guaranteed O(log n) operations</li>
</ul>
<h3 id="implementation-details_9">Implementation Details</h3>
<h4 id="structure_9">Structure</h4>
<pre><code class="language-java">public class AVLTree&lt;T extends Comparable&lt;? super T&gt;&gt; {
     AVLNode&lt;T&gt; root;
    private int size;

    private static class AVLNode&lt;T&gt; {
     T data;
        AVLNode&lt;T&gt; left;
     AVLNode&lt;T&gt; right;
     int height;
     int balanceFactor;
            AVLNode(T data) {
            this.data = data;
            this.height = 0;
            this.balanceFactor = 0;
        }
    }
}
</code></pre>
<h3 id="node-properties">Node Properties</h3>
<ol>
<li><code>data</code>: Stores the actual value/element</li>
<li><code>left</code>: Reference to left child n lement etil ri clrenco right child node</li>
<li><code>height</code>: Distance to the furthest leaf in its subtree</li>
<li><code>balanceFactor</code>: Difference between left and right subtree heights</li>
</ol>
<h3 id="core-operations_6">🔧 Core Operations</h3>
<p>Balance Helper Methods</p>
<pre><code class="language-java">private int height(AVLNode&lt;T&gt; node) {
    return node == null ? -1 : node.height;
}

private void updateHeightAndBF(AVLNode&lt;T&gt; node) {
    int leftHeight = height(node.left);
    int rightHeight = height(node.right);
    node.height = Math.max(leftHeight, rightHeight) + 1;
    node.balanceFactor = leftHeight - rightHeight;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: After any structural changes</li>
<li>⚠️ Key Points:<ul>
<li>Height of null node is -1</li>
<li>Balance factor = leftHeight - rightHeight</li>
<li>Must update after rotations</li>
</ul>
</li>
</ul>
<h4 id="rotation-operations">Rotation Operations</h4>
<pre><code class="language-java">private AVLNode&lt;T&gt; rotateLeft(AVLNode&lt;T&gt; node) {
    AVLNode&lt;T&gt; newRoot = node.right;
    node.right = newRoot.left;
    newRoot.left = node;

    updateHeightAndBF(node);
    updateHeightAndBF(newRoot);
    return newRoot;
}

private AVLNode&lt;T&gt; rotateRight(AVLNode&lt;T&gt; node) {
    AVLNode&lt;T&gt; newRoot = node.left;
    node.left = newRoot.right;
    newRoot.right = node;

    updateHeightAndBF(node);
    updateHeightAndBF(newRoot);
    return newRoot;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: Rebalancing after insertions/deletions</li>
<li>⚠️ Key Points:<ul>
<li>Update heights after rotation</li>
<li>Maintain BST properties</li>
<li>Return new root of subtree</li>
</ul>
</li>
</ul>
<h4 id="balance-operation">Balance Operation</h4>
<pre><code class="language-java">private AVLNode&lt;T&gt; balance(AVLNode&lt;T&gt; node) {
    updateHeightAndBF(node);

    if (node.balanceFactor &lt; -1) {  // Right heavy
        if (node.right.balanceFactor &gt; 0) {  // Right-Left case
            node.right = rotateRight(node.right);
        }
        return rotateLeft(node);
    } else if (node.balanceFactor &gt; 1) {  // Left heavy
        if (node.left.balanceFactor &lt; 0) {  // Left-Right case
            node.left = rotateLeft(node.left);
        }
        return rotateRight(node);
    }

    return node;
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(1)</li>
<li>💭 When to Use: After modifications that might affect balance</li>
<li>⚠️ Key Points:<ul>
<li>Handles all four rotation cases</li>
<li>Updates height before checking balance</li>
<li>Returns balanced subtree root</li>
</ul>
</li>
</ul>
<h4 id="add-operation_2">Add Operation</h4>
<pre><code class="language-java">public void add(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Data cannot be null&quot;);
    }
    root = addHelper(data, root);
}

private AVLNode&lt;T&gt; addHelper(T data, AVLNode&lt;T&gt; node) {
    if (node == null) {
        size++;
        return new AVLNode&lt;&gt;(data);
    }

    int compare = data.compareTo(node.data);
    if (compare &lt; 0) {
        node.left = addHelper(data, node.left);
    } else if (compare &gt; 0) {
        node.right = addHelper(data, node.right);
    }

    return balance(node);
}
</code></pre>
<ul>
<li>⏱️ Time Complexity: O(log n)</li>
<li>💭 When to Use: Adding new elements</li>
<li>⚠️ Key Points:<ul>
<li>BST properties maintained</li>
<li>Auto-balancing after insertion</li>
<li>Uses pointer reinforcement</li>
</ul>
</li>
</ul>
<h3 id="performance-summary_13">📊 Performance Summary</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Includes rebalancing</td>
</tr>
<tr>
<td>Remove</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Includes rebalancing</td>
</tr>
<tr>
<td>Search</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>Same as BST</td>
</tr>
<tr>
<td>Rotation</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Height updates included</td>
</tr>
<tr>
<td>Balance</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Maximum two rotations</td>
</tr>
<tr>
<td>Height</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Cached in node</td>
</tr>
</tbody>
</table>
<h3 id="visualization-of-rotations">🎯 Visualization of Rotations</h3>
<h4 id="left-rotation">Left Rotation</h4>
<pre><code>Before:       After:
  A            B
   \          / \
    B   =&gt;   A   C
     \
      C
</code></pre>
<h4 id="right-rotation">Right Rotation</h4>
<pre><code>Before:       After:
    C          B
   /          / \
  B    =&gt;    A   C
 /
A
</code></pre>
<h4 id="double-rotation-left-right">Double Rotation (Left-Right)</h4>
<pre><code>Before:       Middle:        After:
  C            C              B
 /            /             /  \
A     =&gt;     B     =&gt;     A    C
 \          /
  B        A
</code></pre>
<h4 id="double-rotation-right-left">Double Rotation (Right-Left)</h4>
<pre><code>Before:         Middle:         After:
    A             A               B
     \             \            /  \
      C     =&gt;      B    =&gt;    A    C
     /               \
    B                 C
</code></pre>
<h3 id="best-practices_8">💡 Best Practices</h3>
<h4 id="1-height-management">1. Height Management</h4>
<pre><code class="language-java">// Always update heights bottom-up
updateHeightAndBF(node);
if (node.parent != null) {
    updateHeightAndBF(node.parent);
}
</code></pre>
<h4 id="2-balance-factor-checks">2. Balance Factor Checks</h4>
<pre><code class="language-java">// Check both balance factor and height
if (Math.abs(node.balanceFactor) &gt; 1) {
    return balance(node);
}
</code></pre>
<h4 id="3-rotation-selection">3. Rotation Selection</h4>
<pre><code class="language-java">// Clear conditions for rotation type
if (node.balanceFactor &gt; 1) {  // Left heavy
    if (node.left.balanceFactor &lt; 0) {  // Left-Right case
        node.left = rotateLeft(node.left);
    }
    return rotateRight(node);
}
</code></pre>
<h3 id="common-pitfalls_9">⚠️ Common Pitfalls</h3>
<h4 id="1-incorrect-height-updates">1. Incorrect Height Updates</h4>
<pre><code class="language-java">// WRONG - Not updating ancestor heights
node = balance(node);

// CORRECT - Update all affected nodes
node = balance(node);
updateAncestorHeights(node);
</code></pre>
<h4 id="2-balance-factor-calculation">2. Balance Factor Calculation</h4>
<pre><code class="language-java">// WRONG - Swapped height difference
balanceFactor = rightHeight - leftHeight;

// CORRECT
balanceFactor = leftHeight - rightHeight;
</code></pre>
<h3 id="references_8">References</h3>
<p><a href="https://youtu.be/zP2xbKerIds?si=OQI-Kxgsr9iQKsy-">AVL Trees Simply Explained</a>
<a href="https://youtu.be/qvZGUFHWChY?si=zfLMb0HG7IFSS5gC">Red-Black Trees in 4 min</a>
<a href="https://youtu.be/tPoG8XcnPO0?si=UFsoKQnf9dco_rsX">2-3 Trees</a>
<a href="https://youtu.be/BK5x7IUTIyU?si=8ityNI3gyNnkO68f">K-D Trees</a>
<a href="https://en.wikipedia.org/wiki/M-ary_tree">M-Ary Trees</a></p>
<h1 id="hash-based-structures_1">🎯 Hash-Based Structures</h1>
<h1 id="hashmaps">#️⃣ HashMaps</h1>
<p><img alt="HashMap" src="https://i.postimg.cc/YCcYzBTV/temp-Image-TBGZv5.avif" /></p>
<p>A HashMap is a data structure that implements the Map ADT, storing key-value pairs for O(1) average-case access time. This implementation uses separate chaining for collision resolution, where collisions are handled by maintaining linked lists at each array index.</p>
<h3 id="core-characteristics_10">Core Characteristics</h3>
<ul>
<li>🔑  <strong>Unique Key Mapping</strong><ul>
<li>Each key can map to only one value</li>
<li>Keys must be immutable</li>
<li>Values can be modified or duplicated</li>
<li>Perfect for one-to-one relationships</li>
</ul>
</li>
<li>⚡  <strong>Constant-Time Operations</strong><ul>
<li>O(1) average case for insertions</li>
<li>O(1) average case for retrievals</li>
<li>O(1) average case for deletions</li>
<li>Performance dependent on hash function quality</li>
</ul>
</li>
<li>🎯  <strong>Hash Distribution</strong><ul>
<li>Converts keys to array indices via hashing</li>
<li>Uses hashCode() method for initial hash</li>
<li>Compresses hash to fit array bounds</li>
<li>Aims for uniform distribution of keys</li>
</ul>
</li>
<li>⛓️  <strong>Collision Management</strong><ul>
<li>Handles key collisions using linked lists</li>
<li>Each array index can store multiple entries</li>
<li>Entries in same bucket form a chain</li>
<li>Search within chain is O(n) worst case</li>
</ul>
</li>
<li>⚖️  <strong>Load Factor Control</strong><ul>
<li>Maintains ratio of size to capacity</li>
<li>Typically keeps load factor below 0.67</li>
<li>Triggers resizing when threshold reached</li>
<li>Prevents performance degradation</li>
<li>Uses prime number capacities for better distribution</li>
</ul>
</li>
<li>🔄  <strong>Dynamic Resizing</strong><ul>
<li>Doubles capacity when load factor exceeded</li>
<li>Adds 1 to ensure prime capacity</li>
<li>Rehashes all existing entries</li>
<li>Maintains performance characteristics</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_10">Implementation Details</h3>
<h4 id="node-structure">Node Structure</h4>
<pre><code class="language-java">private static class Node&lt;K, V&gt; {
    K key;
    V value;
    Node&lt;K, V&gt; next;

    Node(K key, V value) {
        this.key = key;
        this.value = value;
        this.next = null;
    }
}
</code></pre>
<h3 id="basic-class-structure">Basic Class Structure</h3>
<pre><code class="language-java">public class HashMap&lt;K, V&gt; {
    private Node&lt;K, V&gt;[] table;
    private int size;
    private static final int INITIAL_CAPACITY = 13;  // Prime number
    private static final double MAX_LOAD_FACTOR = 0.67;

    @SuppressWarnings(&quot;unchecked&quot;)
    public HashMap() {
        table = (Node&lt;K, V&gt;[]) new Node[INITIAL_CAPACITY];
        size = 0;
    }
}
</code></pre>
<h3 id="core-operations_7">Core Operations</h3>
<h4 id="put-operation">Put Operation</h4>
<pre><code class="language-java">public V put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);
    }

    // Check if resize is needed
    if ((double) (size + 1) / table.length &gt; MAX_LOAD_FACTOR) {
        resize();
    }

    int index = getIndex(key);

    // Check if key already exists
    Node&lt;K, V&gt; current = table[index];
    while (current != null) {
        if (current.key.equals(key)) {
            V oldValue = current.value;
            current.value = value;
            return oldValue;
        }
        current = current.next;
    }

    // Add new node at the beginning of the chain
    Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value);
    newNode.next = table[index];
    table[index] = newNode;
    size++;

    return null;
}

private int getIndex(K key) {
    return Math.abs(key.hashCode() % table.length);
}
</code></pre>
<h4 id="get-operation">Get Operation</h4>
<pre><code class="language-java">public V get(K key) {
    if (key == null) {
        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);
    }

    int index = getIndex(key);
    Node&lt;K, V&gt; current = table[index];

    while (current != null) {
        if (current.key.equals(key)) {
            return current.value;
        }
        current = current.next;
    }

    return null;
}
</code></pre>
<h4 id="remove-operation_2">Remove Operation</h4>
<pre><code class="language-java">public V remove(K key) {
    if (key == null) {
        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);
    }

    int index = getIndex(key);
    Node&lt;K, V&gt; current = table[index];
    Node&lt;K, V&gt; prev = null;

    while (current != null) {
        if (current.key.equals(key)) {
            if (prev == null) {
                table[index] = current.next;
            } else {
                prev.next = current.next;
            }
            size--;
            return current.value;
        }
        prev = current;
        current = current.next;
    }

    return null;
}
</code></pre>
<h4 id="resize-operation">Resize Operation</h4>
<pre><code class="language-java">@SuppressWarnings(&quot;unchecked&quot;)
private void resize() {
    int newCapacity = (2 * table.length) + 1;  // Prime number
    Node&lt;K, V&gt;[] oldTable = table;
    table = (Node&lt;K, V&gt;[]) new Node[newCapacity];
    size = 0;

    // Rehash all existing entries
    for (Node&lt;K, V&gt; head : oldTable) {
        Node&lt;K, V&gt; current = head;
        while (current != null) {
            put(current.key, current.value);
            current = current.next;
        }
    }
}
</code></pre>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Put</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Get</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Remove</td>
<td>O(1)</td>
<td>O(n)</td>
<td>When chain degrades to linked list</td>
</tr>
<tr>
<td>Space</td>
<td>O(n)</td>
<td>O(n)</td>
<td>n = number of key-value pairs</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_9">💡 Best Practices</h3>
<h4 id="1-load-factor-management">1. Load Factor Management</h4>
<pre><code class="language-java">private boolean needsResize() {
    return (double) size / table.length &gt; MAX_LOAD_FACTOR;
}
</code></pre>
<h4 id="2-key-quality">2. Key Quality</h4>
<pre><code class="language-java">// Override hashCode() in key objects
@Override
public int hashCode() {
    int hash = 17;
    hash = 31 * hash + field1.hashCode();
    hash = 31 * hash + field2.hashCode();
    return hash;
}
</code></pre>
<h4 id="3-proper-equals-implementation">3. Proper Equals Implementation</h4>
<pre><code class="language-java">@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    MyKey other = (MyKey) obj;
    return field1.equals(other.field1) &amp;&amp; field2.equals(other.field2);
}
</code></pre>
<h3 id="common-pitfalls_10">⚠️ Common Pitfalls</h3>
<h4 id="1-poor-hash-distribution">1. Poor Hash Distribution</h4>
<pre><code class="language-java">// WRONG: Poor hash function
public int hashCode() {
    return 1;  // All items hash to same bucket
}

// BETTER: Good distribution
public int hashCode() {
    return Objects.hash(field1, field2);
}
</code></pre>
<h4 id="2-missing-null-checks">2. Missing Null Checks</h4>
<pre><code class="language-java">// WRONG: No null check
public V put(K key, V value) {
    int index = key.hashCode() % table.length;  // NullPointerException!

// CORRECT: With null check
public V put(K key, V value) {
    if (key == null) {
        throw new IllegalArgumentException(&quot;Key cannot be null&quot;);
    }
    int index = getIndex(key);
</code></pre>
<p>HashMaps provide efficient key-value storage with constant-time average case operations, making them ideal for lookup-intensive applications. The separate chaining implementation offers a good balance between simplicity and performance.</p>
<h3 id="references_9">References</h3>
<p><a href="https://youtube.com/playlist?list=PLDV1Zeh2NRsDH5Wq-Vk5tDb8gH03cULZS&amp;si=gXITqecXbB73ARdC">HashTables with Collision Management</a></p>
<h1 id="graph-based-structures_1">🕸️ Graph-Based Structures</h1>
<p><img alt="Directed Graph" src="https://i.postimg.cc/WbQbHMmY/temp-Imagen2z-WHZ.avif" />
A Graph is a data structure that models relationships between elements using vertices (nodes) and edges. This implementation represents a directed graph using vertex and edge sets along with an adjacency list representation for efficient neighbor access.</p>
<h3 id="core-characteristics_11">Core Characteristics</h3>
<ul>
<li>🔍  <strong>Vertex Management</strong><ul>
<li>Each vertex contains generic typed data</li>
<li>Vertices are unique based on data equality</li>
<li>Supports null-safe vertex operations</li>
<li>Maintains a vertex set for O(1) lookups</li>
</ul>
</li>
<li>🔗  <strong>Edge Properties</strong><ul>
<li>Directed edges from vertex u to v</li>
<li>Weighted connections</li>
<li>Maintains edge set for global access</li>
<li>Supports undirected graphs via bidirectional edges</li>
</ul>
</li>
<li>📊  <strong>Adjacency Structure</strong><ul>
<li>Maps vertices to neighbor lists</li>
<li>Includes edge weights in adjacency entries</li>
<li>Efficient neighbor access</li>
<li>Space-efficient for sparse graphs</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_11">Implementation Details</h3>
<h4 id="vertex-class">Vertex Class</h4>
<pre><code class="language-java">public class Vertex&lt;T&gt; {
    private T data;

    public Vertex(T data) {
        if (data == null) {
            throw new IllegalArgumentException(&quot;Data cannot be null.&quot;);
        }
        this.data = data;
    }

    public T getData() {
        return data;
    }

    @Override
    public boolean equals(Object o) {
        if (o != null &amp;&amp; o instanceof Vertex) {
            return data.equals(((Vertex&lt;?&gt;) o).data);
        }
        return false;
    }

    @Override
    public int hashCode() {
        return data.hashCode();
    }
}
</code></pre>
<h4 id="edge-class">Edge Class</h4>
<pre><code class="language-java">public class Edge&lt;T&gt; implements Comparable&lt;Edge&lt;? super T&gt;&gt; {
    private Vertex&lt;T&gt; u;  // Source vertex
    private Vertex&lt;T&gt; v;  // Destination vertex
    private int weight;   // Edge weight

    public Edge(Vertex&lt;T&gt; u, Vertex&lt;T&gt; v, int weight) {
        if (u == null || v == null) {
            throw new IllegalArgumentException(&quot;Arguments cannot be null.&quot;);
        }
        this.u = u;
        this.v = v;
        this.weight = weight;
    }

    public Vertex&lt;T&gt; getU() { return u; }
    public Vertex&lt;T&gt; getV() { return v; }
    public int getWeight() { return weight; }

    @Override
    public int compareTo(Edge&lt;? super T&gt; e) {
        return weight - e.getWeight();
    }
}
</code></pre>
<h4 id="graph-structure">Graph Structure</h4>
<pre><code class="language-java">public class Graph&lt;T&gt; {
    private Set&lt;Vertex&lt;T&gt;&gt; vertices;
    private Set&lt;Edge&lt;T&gt;&gt; edges;
    private Map&lt;Vertex&lt;T&gt;, List&lt;VertexDistance&lt;T&gt;&gt;&gt; adjList;

    public Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {
        if (vertices == null || edges == null) {
            throw new IllegalArgumentException(&quot;Arguments cannot be null.&quot;);
        }

        this.vertices = new HashSet&lt;&gt;(vertices);
        this.edges = new HashSet&lt;&gt;(edges);
        this.adjList = new HashMap&lt;&gt;();

        // Initialize adjacency list
        for (Vertex&lt;T&gt; v : vertices) {
            adjList.put(v, new ArrayList&lt;&gt;());
        }

        // Populate adjacency list
        for (Edge&lt;T&gt; e : edges) {
            if (adjList.containsKey(e.getU())) {
                adjList.get(e.getU()).add(
                    new VertexDistance&lt;&gt;(e.getV(), e.getWeight())
                );
            } else {
                throw new IllegalArgumentException(
                    &quot;Vertex set must contain all vertices of the graph.&quot;);
            }
        }
    }
}
</code></pre>
<h4 id="vertex-distance-helper">Vertex Distance Helper</h4>
<pre><code class="language-java">public final class VertexDistance&lt;T&gt; 
    implements Comparable&lt;VertexDistance&lt;? super T&gt;&gt; {

    private final Vertex&lt;T&gt; vertex;
    private final int distance;

    public VertexDistance(Vertex&lt;T&gt; vertex, int distance) {
        this.vertex = vertex;
        this.distance = distance;
    }

    @Override
    public int compareTo(VertexDistance&lt;? super T&gt; pair) {
        return this.distance - pair.getDistance();
    }
}
</code></pre>
<h3 id="performance-characteristics_1">Performance Characteristics</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Add Vertex</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet insertion</td>
</tr>
<tr>
<td>Add Edge</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet &amp; ArrayList insertion</td>
</tr>
<tr>
<td>Find Vertex</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet lookup</td>
</tr>
<tr>
<td>Find Edge</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashSet lookup</td>
</tr>
<tr>
<td>Get Neighbors</td>
<td>O(1)</td>
<td>O(1)</td>
<td>HashMap &amp; ArrayList access</td>
</tr>
<tr>
<td>Space</td>
<td>O(V + E)</td>
<td>O(V + E)</td>
<td>V vertices + E edges</td>
</tr>
</tbody>
</table>
<h3 id="best-practices_10">Best Practices</h3>
<h4 id="1-creating-undirected-edges">1. Creating Undirected Edges</h4>
<pre><code class="language-java">// Add both directions for undirected edges
vertices.add(vertexA);
vertices.add(vertexB);
edges.add(new Edge&lt;&gt;(vertexA, vertexB, weight));
edges.add(new Edge&lt;&gt;(vertexB, vertexA, weight));
</code></pre>
<h4 id="2-vertex-creation">2. Vertex Creation</h4>
<pre><code class="language-java">// Ensure data validity
public static &lt;T&gt; Vertex&lt;T&gt; createVertex(T data) {
    if (data == null) {
        throw new IllegalArgumentException(&quot;Vertex data cannot be null&quot;);
    }
    return new Vertex&lt;&gt;(data);
}
</code></pre>
<h4 id="4-edge-validation">4. Edge Validation</h4>
<pre><code class="language-java">private boolean isValidEdge(Edge&lt;T&gt; edge) {
    return vertices.contains(edge.getU()) 
        &amp;&amp; vertices.contains(edge.getV());
}
</code></pre>
<h3 id="common-pitfalls_11">⚠️ Common Pitfalls</h3>
<h4 id="1-missing-graph-initialization">1. Missing Graph Initialization</h4>
<pre><code class="language-java">// WRONG: Uninitialized collections
public Graph() {
    // Missing initialization
}

// CORRECT: Properly initialized collections
public Graph(Set&lt;Vertex&lt;T&gt;&gt; vertices, Set&lt;Edge&lt;T&gt;&gt; edges) {
    this.vertices = new HashSet&lt;&gt;(vertices);
    this.edges = new HashSet&lt;&gt;(edges);
    this.adjList = new HashMap&lt;&gt;();
    // ... rest of initialization
}
</code></pre>
<h4 id="2-improper-edge-direction-handling">2. Improper Edge Direction Handling</h4>
<pre><code class="language-java">// WRONG: Assuming bidirectional
adjList.get(edge.getV()).add(
    new VertexDistance&lt;&gt;(edge.getU(), edge.getWeight()));

// CORRECT: Respecting edge direction
adjList.get(edge.getU()).add(
    new VertexDistance&lt;&gt;(edge.getV(), edge.getWeight()));
</code></pre>
<p>This implementation provides a robust foundation for directed graph operations while maintaining type safety and efficient operations through appropriate data structure choices.</p>
<h3 id="references_10">References</h3>
<p><a href="https://youtu.be/gXgEDyodOJU?si=ED9c2gKgXgDcDJvW">Introduction to Graphs</a></p>
<h1 id="disjoint-sets-union-find">🌳 Disjoint-Sets: Union-Find</h1>
<p><img alt="Disjoint-Sets" src="https://i.postimg.cc/y6yb5BFM/temp-Imagef5e-V06.avif" /></p>
<p>A Disjoint Set (Union-Find) is a data structure that keeps track of elements partitioned into non-overlapping sets. It provides near-constant time operations to check if two elements are in the same set and to unite two sets, making it essential for algorithms like Kruskal's MST.</p>
<h3 id="core-characteristics_12">Core Characteristics</h3>
<ul>
<li>🌳  <strong>Tree-Based Structure</strong><ul>
<li>Each set is represented as a tree</li>
<li>Elements point to their parent elements</li>
<li>Root element represents the set identifier</li>
<li>Path compression for efficiency</li>
</ul>
</li>
<li>🔍  <strong>Find Operation</strong><ul>
<li>Identifies the set an element belongs to</li>
<li>Implements path compression</li>
<li>Returns the root element</li>
<li>Amortized O(1) time complexity</li>
</ul>
</li>
<li>🤝  <strong>Union Operation</strong><ul>
<li>Merges two different sets</li>
<li>Uses union by rank</li>
<li>Maintains tree balance</li>
<li>Prevents deep hierarchies</li>
</ul>
</li>
</ul>
<h3 id="implementation-details_12">Implementation Details</h3>
<h4 id="structure_10">Structure</h4>
<pre><code class="language-java">private static class DisjointSetNode&lt;T&gt; {
    private DisjointSetNode&lt;T&gt; parent;
    private T data;
    private int rank;

    public DisjointSetNode(T data) {
        this.parent = this;  // Node initially points to itself
        this.data = data;
        this.rank = 0;
    }
}
</code></pre>
<h4 id="base-structure">Base Structure</h4>
<pre><code class="language-java">public class DisjointSet&lt;T&gt; {
    private Map&lt;T, DisjointSetNode&lt;T&gt;&gt; disjointSet;

    public DisjointSet() {
        disjointSet = new HashMap&lt;&gt;();
    }
}
</code></pre>
<h3 id="core-operations_8">Core Operations</h3>
<h4 id="find-operation">Find Operation</h4>
<pre><code class="language-java">public T find(T data) {
    if (!disjointSet.containsKey(data)) {
        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));
    }
    return find(disjointSet.get(data)).getData();
}

private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; curr) {
    DisjointSetNode&lt;T&gt; parent = curr.getParent();

    if (parent == curr) {
        return curr;  // Found root
    }

    // Path compression: Make all nodes point to root
    parent = find(curr.getParent());
    curr.setParent(parent);
    return parent;
}
</code></pre>
<h3 id="performance-characteristics_2">📊 Performance Characteristics</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Amortized Time</th>
<th>Worst Case</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Make Set</td>
<td>O(1)</td>
<td>O(1)</td>
<td>Creates new set</td>
</tr>
<tr>
<td>Find</td>
<td>O(α(n))</td>
<td>O(log n)</td>
<td>With path compression</td>
</tr>
<tr>
<td>Union</td>
<td>O(α(n))</td>
<td>O(log n)</td>
<td>With union by rank</td>
</tr>
<tr>
<td>Space</td>
<td>O(n)</td>
<td>O(n)</td>
<td>n elements</td>
</tr>
</tbody>
</table>
<p>Note: α(n) is the inverse Ackermann function, which grows extremely slowly and is effectively constant for all practical values of n. </p>
<h3 id="best-practices_11">💡 Best Practices</h3>
<h4 id="1-path-compression">1. Path Compression</h4>
<pre><code class="language-java">// Always update parent pointers during find
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent())); // Compress path
    }
    return node.getParent();
}
</code></pre>
<h4 id="2-union-by-rank">2. Union by Rank</h4>
<pre><code class="language-java">// Always consider ranks when unioning
if (firstParent.getRank() &lt; secondParent.getRank()) {
    firstParent.setParent(secondParent);
} else {
    secondParent.setParent(firstParent);
    if (firstParent.getRank() == secondParent.getRank()) {
        firstParent.setRank(firstParent.getRank() + 1);
    }
}
</code></pre>
<h4 id="3-lazy-initialization">3. Lazy Initialization</h4>
<pre><code class="language-java">public T find(T data) {
    if (!disjointSet.containsKey(data)) {
        disjointSet.put(data, new DisjointSetNode&lt;&gt;(data));
    }
    // Continue with find operation
}
</code></pre>
<h3 id="common-pitfalls_12">⚠️ Common Pitfalls</h3>
<h4 id="1-missing-path-compression">1. Missing Path Compression</h4>
<pre><code class="language-java">// WRONG: No path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    while (node != node.getParent()) {
        node = node.getParent();
    }
    return node;
}

// CORRECT: With path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent()));
    }
    return node.getParent();
}
</code></pre>
<h4 id="2-incorrect-union-operation">2. Incorrect Union Operation</h4>
<pre><code class="language-java">// WRONG: No path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    while (node != node.getParent()) {
        node = node.getParent();
    }
    return node;
}

// CORRECT: With path compression
private DisjointSetNode&lt;T&gt; find(DisjointSetNode&lt;T&gt; node) {
    if (node != node.getParent()) {
        node.setParent(find(node.getParent()));
    }
    return node.getParent();
}
</code></pre>
<p>This implementation provides an efficient foundation for set operations used in graph algorithms, particularly Kruskal's Minimum Spanning Tree algorithm, with optimizations for both time and space complexity.</p>
<h3 id="references_11">References</h3>
<p><a href="https://youtu.be/ayW5B2W9hfo?si=-6kosBXm4AK0u9pC">Union Find Data Structure</a></p>
<h1 id="other-advanced-structures">📚 Other Advanced Structures</h1>
<h3 id="trie">🔎 Trie</h3>
<p><a href="https://youtube.com/playlist?list=PLEJXowNB4kPyi859E6qGUs7jlpQehJndl&amp;si=9xfexgOQ7DaSU_h_">Trie</a></p>
<h3 id="skip-lists">🔎 Skip Lists</h3>
<p><a href="https://youtu.be/hqHwQUdTgLM?si=oaf0LW2DRyVO4lP5">Skip List Introduction</a>
<a href="https://youtu.be/1G8h3u6Thzs?si=ykbCCfLzIFW4oSa_">Skip Lists Insertion and Deletion</a></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
