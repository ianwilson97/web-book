<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>ğŸš€ The Ultimate Python Technical Interview Guide - My Docs</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Introduction</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">1.Fundamentals</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../1.Fundamentals/a.%20programming_principles/" class="dropdown-item">ğŸ”® Programming Fundamentals</a>
</li>
                                    
<li>
    <a href="../../1.Fundamentals/b.%20data_structures/" class="dropdown-item">ğŸ”® Data Structures</a>
</li>
                                    
<li>
    <a href="../../1.Fundamentals/c.%20algorithms/" class="dropdown-item">ğŸ“˜ Introduction to Algorithms</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle active" aria-current="page" role="button" data-bs-toggle="dropdown"  aria-expanded="false">2.Interviews</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active" aria-current="page">ğŸš€ The Ultimate Python Technical Interview Guide</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../../1.Fundamentals/c.%20algorithms/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" class="nav-link disabled">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#the-ultimate-python-technical-interview-guide" class="nav-link">ğŸš€ The Ultimate Python Technical Interview Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#introduction" class="nav-link">ğŸ“˜ Introduction</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#guide-structure" class="nav-link">ğŸ—ºï¸ Guide Structure</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#before-we-begin-python-essentials" class="nav-link">ğŸ’» Before We Begin: Python Essentials</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#how-to-use-this-guide" class="nav-link">ğŸ¯ How to Use This Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#lets-get-started" class="nav-link">ğŸ® Let's Get Started!</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-mistakes-to-avoid" class="nav-link">ğŸš¨ Common Interview Mistakes to Avoid</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#success-tips" class="nav-link">ğŸŒŸ Success Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#algorithmic-complexity-big-o-guide" class="nav-link">ğŸ¯ Algorithmic Complexity &amp; Big-O Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#visual-complexity-chart" class="nav-link">ğŸ¨ Visual Complexity Chart</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#what-is-algorithmic-complexity" class="nav-link">ğŸ® What is Algorithmic Complexity?</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#understanding-big-o-notation" class="nav-link">ğŸš€ Understanding Big-O Notation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#big-o-cheat-sheet-for-common-data-structures" class="nav-link">ğŸ¯ Big-O Cheat Sheet for Common Data Structures</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pro-tips-for-optimization" class="nav-link">ğŸ® Pro Tips for Optimization</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#practice-problems" class="nav-link">ğŸ¯ Practice Problems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#bit-manipulation-sorting-algorithms" class="nav-link">ğŸ§® Bit Manipulation &amp; Sorting Algorithms</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#part-1-bit-manipulation" class="nav-link">Part 1: ğŸ”¢ Bit Manipulation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#part-2-sorting-algorithms" class="nav-link">Part 2: ğŸ”„ Sorting Algorithms</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#simple-sorts-on2" class="nav-link">Simple Sorts (O(nÂ²))</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#efficient-sorts-on-log-n" class="nav-link">Efficient Sorts (O(n log n))</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#special-purpose-sorts" class="nav-link">Special Purpose Sorts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#linked-lists-dummy-node-technique-guide" class="nav-link">ğŸ”— Linked Lists &amp; Dummy Node Technique Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#understanding-linked-lists" class="nav-link">ğŸ“˜ Understanding Linked Lists</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#core-implementation-options" class="nav-link">ğŸ“š Core Implementation Options</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pattern-templates" class="nav-link">ğŸ¯ Common Pattern Templates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#essential-operations-templates" class="nav-link">ğŸ› ï¸ Essential Operations Templates</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#the-dummy-node-technique" class="nav-link">ğŸ¯ The Dummy Node Technique</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#stack-queue-implementations-in-python" class="nav-link">ğŸ”„ Stack &amp; Queue Implementations in Python</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#stack-implementations" class="nav-link">ğŸ“š Stack Implementations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#queue-implementations" class="nav-link">ğŸ“ Queue Implementations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-implementation-patterns" class="nav-link">ğŸ¯ Common Implementation Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#key-operations-complexities" class="nav-link">ğŸ”‘ Key Operations &amp; Complexities</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#when-to-use-what" class="nav-link">ğŸ’¡When to Use What</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#implementation-comparison" class="nav-link">ğŸ¯ Implementation Comparison</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#practice-problem-tips" class="nav-link">ğŸ® Practice Problem Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#hash-tables-in-python-dictionaries" class="nav-link">ğŸ—ƒï¸ Hash Tables in Python (Dictionaries)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#basic-implementation" class="nav-link">ğŸ“š Basic Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-hash-table-patterns" class="nav-link">ğŸ¯ Common Hash Table Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#advanced-techniques" class="nav-link">ğŸ® Advanced Techniques</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-problem-patterns" class="nav-link">ğŸ“ Common Interview Problem Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#practice-problems_2" class="nav-link">ğŸ¯ Practice Problems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pitfalls-to-watch-for" class="nav-link">âš ï¸ Common Pitfalls to Watch For</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#heaps-for-technical-interviews" class="nav-link">ğŸŒ³ Heaps for Technical Interviews</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-concepts" class="nav-link">ğŸ“š Core Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#basic-operations-using-heapq" class="nav-link">ğŸ”§ Basic Operations Using heapq</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-heap-patterns" class="nav-link">ğŸ¯ Common Heap Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-problems" class="nav-link">ğŸ¯ Common Interview Problems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_1" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#recursion-guide-for-technical-interviews" class="nav-link">ğŸ”„ Recursion Guide for Technical Interviews</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-concepts_1" class="nav-link">ğŸ“š Core Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-recursion-patterns" class="nav-link">ğŸ¯ Common Recursion Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-problem-types" class="nav-link">ğŸ“ Common Interview Problem Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pitfalls-solutions" class="nav-link">âš ï¸ Common Pitfalls &amp; Solutions</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#timespace-complexity-analysis" class="nav-link">ğŸ¯ Time/Space Complexity Analysis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_2" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#backtracking-guide" class="nav-link">â™»ï¸ Backtracking Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-properties" class="nav-link">ğŸ“š Core Properties</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#implementation-patterns" class="nav-link">ğŸ¯ Implementation Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#decision-making-guide" class="nav-link">ğŸ¯ Decision Making Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#hybrid-approach-examples" class="nav-link">ğŸ® Hybrid Approach Examples</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-problem-types" class="nav-link">ğŸ® Common Problem Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#time-complexity-analysis" class="nav-link">ğŸ¯ Time Complexity Analysis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#optimization-techniques" class="nav-link">ğŸ’¡ Optimization Techniques</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_3" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#binary-trees-guide" class="nav-link">ğŸŒ³ Binary Trees Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-implementation" class="nav-link">ğŸ“š Core Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#core-traversal-patterns" class="nav-link">ğŸ¯ Core Traversal Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-problem-patterns" class="nav-link">ğŸ® Common Problem Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pattern-recognition-guide" class="nav-link">ğŸ¯ Pattern Recognition Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#problem-solving-strategy" class="nav-link">ğŸ’¡ Problem-Solving Strategy</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#tries-prefix-trees" class="nav-link">ğŸŒ² Tries (Prefix Trees)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-implementation_1" class="nav-link">ğŸ“š Core Implementation</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-patterns" class="nav-link">ğŸ¯ Common Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#timespace-complexity" class="nav-link">ğŸ¯ Time/Space Complexity</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#key-advantagesdisadvantages" class="nav-link">ğŸ”‘ Key Advantages/Disadvantages</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#when-to-use-tries" class="nav-link">ğŸ’¡ When to Use Tries</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pitfalls" class="nav-link">âš ï¸ Common Pitfalls</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#practice-problem-types" class="nav-link">ğŸ¯ Practice Problem Types</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#binary-search-guide" class="nav-link">ğŸ” Binary Search Guide</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-template" class="nav-link">ğŸ“š Core Template</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#three-key-components" class="nav-link">ğŸ¯ Three Key Components</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-problem-patterns_1" class="nav-link">ğŸ® Common Problem Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#pattern-recognition-guide_1" class="nav-link">ğŸ¯ Pattern Recognition Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pitfalls_1" class="nav-link">âš ï¸ Common Pitfalls</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#implementation-tips" class="nav-link">ğŸ’¡ Implementation Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#greedy-algorithms" class="nav-link">ğŸª™ Greedy Algorithms</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-properties_1" class="nav-link">ğŸ“š Core Properties</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#when-to-use-greedy-algorithms" class="nav-link">ğŸ¯ When to Use Greedy Algorithms</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-greedy-patterns" class="nav-link">ğŸ® Common Greedy Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#universal-greedy-patterns" class="nav-link">ğŸ”„ Universal Greedy Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#problem-solving-framework" class="nav-link">ğŸ¯ Problem-Solving Framework</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-pitfalls_2" class="nav-link">âš ï¸ Common Pitfalls</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-problems_1" class="nav-link">ğŸ“ Common Interview Problems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_4" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#time-complexity-analysis_1" class="nav-link">ğŸ¯ Time Complexity Analysis</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#dynamic-programming-from-fundamentals-to-mastery" class="nav-link">ğŸ¯ Dynamic Programming - From Fundamentals to Mastery</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#introduction-to-dynamic-programming" class="nav-link">ğŸ“š Introduction to Dynamic Programming</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#core-concepts-explained" class="nav-link">ğŸ¯ Core Concepts Explained</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#two-main-approaches-to-dp" class="nav-link">ğŸ® Two Main Approaches to DP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#problem-solving-framework_1" class="nav-link">ğŸ¯ Problem-Solving Framework</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-dp-patterns" class="nav-link">ğŸ¯ Common DP Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#advanced-optimization-techniques" class="nav-link">ğŸ’¡ Advanced Optimization Techniques</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#graphs-graph-theory" class="nav-link">ğŸ“Š Graphs &amp; Graph Theory</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-concepts_2" class="nav-link">ğŸ“š Core Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#graph-representations" class="nav-link">ğŸ¯ Graph Representations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#essential-graph-operations" class="nav-link">ğŸ® Essential Graph Operations</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-graph-algorithms-for-interviews" class="nav-link">ğŸ¯ Common Graph Algorithms for Interviews</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-problem-patterns" class="nav-link">ğŸ“ Interview Problem Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_5" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#minimum-spanning-trees-mst" class="nav-link">ğŸŒ³ Minimum Spanning Trees (MST)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#core-concepts_3" class="nav-link">ğŸ“š Core Concepts</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#key-algorithms" class="nav-link">ğŸ¯ Key Algorithms</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#algorithm-selection-guide" class="nav-link">ğŸ® Algorithm Selection Guide</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#common-interview-problems_2" class="nav-link">ğŸ“ Common Interview Problems</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#interview-tips_6" class="nav-link">ğŸ’¡ Interview Tips</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#technical-interview-patterns" class="nav-link">Technical Interview Patterns</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="the-ultimate-python-technical-interview-guide">ğŸš€ The Ultimate Python Technical Interview Guide</h1>
<p><img alt="Software Engineer Interview" src="https://i.postimg.cc/BnTvjL3t/temp-Imageb-Xdn-Pv.avif" /></p>
<h2 id="introduction">ğŸ“˜ Introduction</h2>
<p>Welcome to your comprehensive companion for mastering technical interviews! Whether you're aiming for FAANG companies or preparing for your first technical interview, this guide will help you tackle coding challenges with confidence.</p>
<h3 id="why-this-guide">ğŸ¯ Why This Guide?</h3>
<ul>
<li>ğŸ  <strong>Python-Focused</strong>: All solutions and examples in Python (the most popular interview language!)</li>
<li>ğŸ§   <strong>Pattern Recognition</strong>: Learn to spot and solve common problem patterns</li>
<li>âš¡  <strong>Optimization Skills</strong>: Master the art of writing efficient code</li>
<li>ğŸ“  <strong>Interview Strategy</strong>: Learn not just what to code, but how to approach problems</li>
<li>ğŸ’ª  <strong>Practical Examples</strong>: Real interview problems with detailed solutions</li>
</ul>
<h3 id="how-this-guide-is-different">ğŸ¨ How This Guide is Different</h3>
<p>We believe learning should be fun! You'll find:</p>
<ul>
<li>ğŸ® Interactive examples</li>
<li>ğŸ¯ Pattern-based learning</li>
<li>ğŸ§© Visual explanations</li>
<li>ğŸ’¡ "Aha!" moment highlights</li>
<li>ğŸš« Common pitfall warnings</li>
</ul>
<h2 id="guide-structure">ğŸ—ºï¸ Guide Structure</h2>
<h3 id="1-foundation-building">1ï¸âƒ£ Foundation Building</h3>
<ul>
<li>Big-O Notation and Complexity Analysis</li>
<li>Python-specific optimizations</li>
<li>Core data structures in Python</li>
<li>Essential algorithms and their implementations</li>
</ul>
<h3 id="2-pattern-recognition">2ï¸âƒ£ Pattern Recognition</h3>
<ul>
<li>Common interview patterns</li>
<li>When to use which approach</li>
<li>Pattern-specific optimizations</li>
<li>Real interview problem mappings</li>
</ul>
<h3 id="3-interview-strategy">3ï¸âƒ£ Interview Strategy</h3>
<ul>
<li>Problem-solving framework</li>
<li>Communication tips</li>
<li>Code organization</li>
<li>Testing approaches</li>
</ul>
<h3 id="good-references">Good References</h3>
<p><a href="https://github.com/ashishps1/awesome-leetcode-resources?tab=readme-ov-file">Technical Interview Github Repo</a></p>
<h2 id="before-we-begin-python-essentials">ğŸ’» Before We Begin: Python Essentials</h2>
<h3 id="key-python-tools-for-interviews">ğŸ”§ Key Python Tools for Interviews</h3>
<pre><code class="language-python"># Common imports you'll need
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop
from typing import List, Dict, Set
</code></pre>
<h3 id="python-specific-pro-tips">ğŸ› ï¸ Python-Specific Pro Tips</h3>
<pre><code class="language-python"># 1. List comprehension for cleaner code
squares = [x*x for x in range(10)]

# 2. Default dictionaries for counting
counter = defaultdict(int)

# 3. Built-in sort with custom key
items.sort(key=lambda x: x.value)

# 4. Multiple assignment
x, y = y, x  # Swap values
</code></pre>
<h2 id="how-to-use-this-guide">ğŸ¯ How to Use This Guide</h2>
<h3 id="learning-path">ğŸ“š Learning Path</h3>
<ol>
<li><strong>Build the Foundation</strong><ul>
<li>Master Python basics</li>
<li>Understand complexity analysis</li>
<li>Learn core data structures</li>
</ul>
</li>
<li><strong>Pattern Recognition</strong><ul>
<li>Study common patterns</li>
<li>Practice similar problems</li>
<li>Learn pattern variations</li>
</ul>
</li>
<li><strong>Problem Solving</strong><ul>
<li>Apply patterns to new problems</li>
<li>Practice optimization</li>
<li>Work on communication</li>
</ul>
</li>
</ol>
<h3 id="time-management">â° Time Management</h3>
<ul>
<li>ğŸŒ±  <strong>Beginner</strong>: 2-3 months of preparation</li>
<li>ğŸŒ¿  <strong>Intermediate</strong>: 1-2 months of focused practice</li>
<li>ğŸŒ³  <strong>Advanced</strong>: 2-3 weeks of revision</li>
</ul>
<h2 id="lets-get-started">ğŸ® Let's Get Started!</h2>
<h3 id="your-first-steps">ğŸ¯ Your First Steps</h3>
<ol>
<li>Review Python fundamentals</li>
<li>Start with easy problems</li>
<li>Focus on problem-solving process</li>
<li>Practice explaining your thought process</li>
</ol>
<h3 id="remember">ğŸ’¡ Remember</h3>
<ul>
<li>Understanding patterns &gt; Memorizing solutions</li>
<li>Practice regularly &gt; Cramming</li>
<li>Clear communication &gt; Perfect code</li>
<li>Learning from mistakes &gt; Getting it right first time</li>
</ul>
<h2 id="common-interview-mistakes-to-avoid">ğŸš¨ Common Interview Mistakes to Avoid</h2>
<ul>
<li>Jumping into coding without planning</li>
<li>Not clarifying requirements</li>
<li>Ignoring edge cases</li>
<li>Writing unclear/messy code</li>
<li>Not testing your solution</li>
</ul>
<h2 id="success-tips">ğŸŒŸ Success Tips</h2>
<ul>
<li>Think aloud while solving</li>
<li>Start with brute force, then optimize</li>
<li>Use meaningful variable names</li>
<li>Write clean, modular code</li>
<li>Test with edge cases</li>
</ul>
<p>Ready to begin your journey to interview success? Let's dive into our first topic: Algorithmic Complexity and Big-O Notation! ğŸš€</p>
<h1 id="algorithmic-complexity-big-o-guide">ğŸ¯ Algorithmic Complexity &amp; Big-O Guide</h1>
<h2 id="visual-complexity-chart">ğŸ¨ Visual Complexity Chart</h2>
<p>Excellent  O(1) â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–
Good      O(log n) â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚
Fair      O(n) â–â–â–â–‚â–‚â–‚â–ƒâ–ƒâ–ƒâ–„â–„â–„â–…â–…â–…â–†â–†â–†
Bad       O(nÂ²) â–â–‚â–ƒâ–„â–…â–†â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Horrible  O(2â¿) â–â–‚â–…â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</p>
<p><img alt="Big-O CheatSheet" src="https://i.postimg.cc/wjrdT9y3/temp-Image-Qsq7-Dm.avif" />
<a href="https://blog.algomaster.io/p/57bd4963-462f-4294-a972-4012691fc729">blog.algomaster.io</a></p>
<h2 id="what-is-algorithmic-complexity">ğŸ® What is Algorithmic Complexity?</h2>
<p>Think of algorithmic complexity as your code's "price tag" in terms of:</p>
<ul>
<li>â±ï¸ Time (how long it takes to run)</li>
<li>ğŸ’¾ Space (how much memory it needs)</li>
</ul>
<h3 id="why-should-you-care">ğŸ¯ Why Should You Care?</h3>
<pre><code class="language-python"># Example 1: O(n) - Linear Time
def find_max_linear(arr):  # ğŸ˜Š Good for small lists
    return max(arr)

# Example 2: O(nÂ²) - Quadratic Time
def find_max_nested(arr):  # ğŸ˜° Terrible for large lists
    max_val = arr[0]
    for i in arr:
        for j in arr:  # Unnecessary nested loop!
            if i &gt; max_val:
                max_val = i
    return max_val
</code></pre>
<h2 id="understanding-big-o-notation">ğŸš€ Understanding Big-O Notation</h2>
<h3 id="common-time-complexities-from-best-to-worst">ğŸ“Š Common Time Complexities (From Best to Worst)</h3>
<ol>
<li><strong>O(1) - Constant Time</strong>  ğŸŒŸ</li>
</ol>
<pre><code class="language-python">def get_first(arr):
    return arr[0] if arr else None
</code></pre>
<ul>
<li>Like finding a book when you know exactly where it is</li>
<li>
<p>Examples: Hash table access, array index access</p>
</li>
<li>
<p><strong>O(log n) - Logarithmic Time</strong> âœ¨</p>
</li>
</ul>
<pre><code class="language-python">def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left &lt;= right:
        mid = (left + right) // 2
        if arr[mid] == target: return mid
        if arr[mid] &lt; target: left = mid + 1
        else: right = mid - 1
    return -1
</code></pre>
<ul>
<li>Like finding a word in a dictionary</li>
<li>Examples: Binary search, balanced BST operations</li>
<li><strong>O(n) - Linear Time</strong> ğŸ‘</li>
</ul>
<pre><code class="language-python">def linear_search(arr, target):
    return any(x == target for x in arr)
</code></pre>
<ul>
<li>Like reading every page in a book</li>
<li>Examples: Array traversal, linear search</li>
<li><strong>O(n log n) - Log-Linear Time</strong> ğŸ†—</li>
</ul>
<pre><code class="language-python">def merge_sort(arr):
    if len(arr) &lt;= 1: return arr
    mid = len(arr) // 2
    return merge(merge_sort(arr[:mid]), 
                merge_sort(arr[mid:]))
</code></pre>
<ul>
<li>Like sorting a deck of cards efficiently</li>
<li>Examples: Merge sort, quick sort (average case)</li>
<li><strong>O(nÂ²) - Quadratic Time</strong> ğŸ˜°</li>
</ul>
<pre><code class="language-python">def bubble_sort(arr):
    for i in range(len(arr)):
        for j in range(len(arr) - 1):
            if arr[j] &gt; arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
</code></pre>
<ul>
<li>Like comparing every page with every other page</li>
<li>Examples: Nested loops, bubble sort</li>
<li><strong>O(2â¿) - Exponential Time</strong> ğŸ˜±</li>
</ul>
<pre><code class="language-python">def fibonacci_recursive(n):
    if n &lt;= 1: return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)
</code></pre>
<ul>
<li>Like trying every possible combination</li>
<li>Examples: Recursive Fibonacci, power set</li>
</ul>
<h3 id="common-space-complexities">ğŸ® Common Space Complexities</h3>
<ol>
<li><strong>O(1) - Constant Space</strong><ul>
<li>Fixed amount of extra space</li>
<li>Example: Simple variables, fixed-size arrays</li>
</ul>
</li>
<li><strong>O(n) - Linear Space</strong><ul>
<li>Space grows linearly with input</li>
<li>Example: Creating a new array of size n</li>
</ul>
</li>
<li><strong>O(nÂ²) - Quadratic Space</strong><ul>
<li>Space grows quadratically</li>
<li>Example: 2D array/matrix of size nÃ—n</li>
</ul>
</li>
</ol>
<h2 id="big-o-cheat-sheet-for-common-data-structures">ğŸ¯ Big-O Cheat Sheet for Common Data Structures</h2>
<h3 id="array-operations">Array Operations</h3>
<pre><code class="language-python"># Access: O(1)
arr[5]  # Direct access by index

# Search: O(n)
target in arr  # Linear search

# Insertion/Deletion at end: O(1)
arr.append(item)  # Add to end
arr.pop()  # Remove from end

# Insertion/Deletion at middle: O(n)
arr.insert(2, item)  # Need to shift elements
</code></pre>
<h3 id="dictionaryhash-table-operations">Dictionary/Hash Table Operations</h3>
<pre><code class="language-python"># Access/Insert/Delete: O(1) average
dict_example = {}
dict_example['key'] = 'value'  # O(1)
value = dict_example['key']    # O(1)
del dict_example['key']        # O(1)
</code></pre>
<h2 id="pro-tips-for-optimization">ğŸ® Pro Tips for Optimization</h2>
<ol>
<li><strong>Avoid Nested Loops When Possible</strong></li>
</ol>
<pre><code class="language-python"># Bad: O(nÂ²)
for i in range(n):
    for j in range(n):
        # do something

# Better: O(n)
seen = set()
for i in range(n):
    if i in seen:
        # do something
</code></pre>
<ol>
<li><strong>Use Built-in Data Structures Wisely</strong></li>
</ol>
<pre><code class="language-python"># Lists vs Sets for lookups
numbers = [1, 2, 3, 4, 5]
number_set = set(numbers)

# Bad: O(n)
5 in numbers

# Good: O(1)
5 in number_set
</code></pre>
<ol>
<li><strong>Cache Results When Possible</strong></li>
</ol>
<pre><code class="language-python">from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n &lt; 2: return n
    return fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<h2 id="practice-problems">ğŸ¯ Practice Problems</h2>
<ol>
<li><strong>Identify the Time Complexity</strong></li>
</ol>
<pre><code class="language-python">def mystery_function(n):
    result = 0
    for i in range(n):
        for j in range(i, n):
            result += 1
    return result

# What's the time complexity? 
# (Answer: O(nÂ²))
</code></pre>
<p>Remember: The best algorithm is often a balance between:</p>
<ul>
<li>â±ï¸ Time complexity</li>
<li>ğŸ’¾ Space complexity</li>
<li>ğŸ¯ Code readability</li>
<li>ğŸ”§ Maintainability</li>
</ul>
<h1 id="bit-manipulation-sorting-algorithms">ğŸ§® Bit Manipulation &amp; Sorting Algorithms</h1>
<h2 id="part-1-bit-manipulation">Part 1: ğŸ”¢ Bit Manipulation</h2>
<h3 id="why-bit-manipulation">ğŸ¯ Why Bit Manipulation?</h3>
<ul>
<li>âš¡ More efficient than arithmetic operations</li>
<li>ğŸš€ Essential for optimization problems</li>
<li>ğŸ’» Crucial for low-level programming</li>
<li>ğŸ“ Common in technical interviews</li>
</ul>
<h3 id="basic-operators">ğŸ› ï¸ Basic Operators</h3>
<pre><code class="language-python"># AND (&amp;): 1 if both bits are 1
print(5 &amp; 3)  # 5(101) &amp; 3(011) = 1(001)

# OR (|): 1 if either bit is 1
print(5 | 3)  # 5(101) | 3(011) = 7(111)

# XOR (^): 1 if bits are different
print(5 ^ 3)  # 5(101) ^ 3(011) = 6(110)

# NOT (~): Inverts all bits
print(~5)     # 5(101) -&gt; -(110)

# Left Shift (&lt;&lt;): Multiply by 2^n
print(5 &lt;&lt; 1) # 5(101) &lt;&lt; 1 = 10(1010)

# Right Shift (&gt;&gt;): Divide by 2^n
print(5 &gt;&gt; 1) # 5(101) &gt;&gt; 1 = 2(010)
</code></pre>
<h3 id="common-bit-manipulation-tricks">ğŸ® Common Bit Manipulation Tricks</h3>
<ol>
<li><strong>Check if Number is Even/Odd</strong></li>
</ol>
<pre><code class="language-python">def is_even(n: int) -&gt; bool:
    return not (n &amp; 1)  # Last bit is 0 for even numbers
</code></pre>
<ol>
<li><strong>Multiply/Divide by Powers of 2</strong></li>
</ol>
<pre><code class="language-python">def multiply_by_2(n: int) -&gt; int:
    return n &lt;&lt; 1  # Left shift = multiply by 2

def divide_by_2(n: int) -&gt; int:
    return n &gt;&gt; 1  # Right shift = divide by 2
</code></pre>
<ol>
<li><strong>Set/Clear/Toggle Bits</strong></li>
</ol>
<pre><code class="language-python">def set_bit(n: int, pos: int) -&gt; int:
    return n | (1 &lt;&lt; pos)

def clear_bit(n: int, pos: int) -&gt; int:
    return n &amp; ~(1 &lt;&lt; pos)

def toggle_bit(n: int, pos: int) -&gt; int:
    return n ^ (1 &lt;&lt; pos)
</code></pre>
<ol>
<li><strong>Check if Bit is Set</strong></li>
</ol>
<pre><code class="language-python">def is_bit_set(n: int, pos: int) -&gt; bool:
    return bool(n &amp; (1 &lt;&lt; pos))
</code></pre>
<h3 id="interview-tips-for-bit-manipulation">ğŸ¯ Interview Tips for Bit Manipulation</h3>
<ol>
<li>Always visualize bits on paper</li>
<li>Test with small numbers first</li>
<li>Consider edge cases (negatives, zero)</li>
<li>Explain your logic step by step</li>
</ol>
<h2 id="part-2-sorting-algorithms">Part 2: ğŸ”„ Sorting Algorithms</h2>
<h3 id="comparison-overview">ğŸ“Š Comparison Overview</h3>
<pre><code class="language-python">sorting_algos = {
    'Bubble Sort':    {'Time': 'O(nÂ²)', 'Space': 'O(1)', 'Stable': True},
    'Selection Sort': {'Time': 'O(nÂ²)', 'Space': 'O(1)', 'Stable': False},
    'Insertion Sort': {'Time': 'O(nÂ²)', 'Space': 'O(1)', 'Stable': True},
    'Merge Sort':     {'Time': 'O(n log n)', 'Space': 'O(n)', 'Stable': True},
    'Quick Sort':     {'Time': 'O(n log n)', 'Space': 'O(log n)', 'Stable': False},
    'Heap Sort':      {'Time': 'O(n log n)', 'Space': 'O(1)', 'Stable': False}
}
</code></pre>
<h3 id="simple-sorting-algorithms">ğŸ¯ Simple Sorting Algorithms</h3>
<ol>
<li><strong>Bubble Sort</strong>  (The Beginner's Sort)</li>
</ol>
<pre><code class="language-python">def bubble_sort(arr: list) -&gt; list:
    n = len(arr)
    for i in range(n):
        # Flag for optimization
        swapped = False

        # Last i elements are already sorted
        for j in range(0, n-i-1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True

        # If no swaps occurred, array is sorted
        if not swapped:
            break
    return arr

# When to use: Small arrays or nearly sorted data
# Pros: Simple to implement, in-place sorting
# Cons: Very inefficient for large datasets
</code></pre>
<ol>
<li><strong>Selection Sort</strong> (The Minimalist's Sort)</li>
</ol>
<pre><code class="language-python">def selection_sort(arr: list) -&gt; list:
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] &lt; arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# When to use: Small arrays with expensive writes
# Pros: Minimum number of swaps
# Cons: Always makes O(nÂ²) comparisons
</code></pre>
<ol>
<li><strong>Insertion Sort</strong> (The Adaptive Sort)</li>
</ol>
<pre><code class="language-python">def insertion_sort(arr: list) -&gt; list:
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j &gt;= 0 and arr[j] &gt; key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

# When to use: Small datasets or nearly sorted arrays
# Pros: Adaptive, stable, and great for small data
# Cons: Still O(nÂ²) in worst case
</code></pre>
<h3 id="advanced-sorting-algorithms">ğŸš€ Advanced Sorting Algorithms</h3>
<ol>
<li><strong>Merge Sort</strong> (The Reliable Sort)</li>
</ol>
<pre><code class="language-python">def merge_sort(arr: list) -&gt; list:
    if len(arr) &lt;= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left: list, right: list) -&gt; list:
    result = []
    i = j = 0

    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt;= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# When to use: Large datasets where stability matters
# Pros: Stable, predictable O(n log n)
# Cons: Requires O(n) extra space
</code></pre>
<ol>
<li><strong>Quick Sort</strong> (The Practical Sort)</li>
</ol>
<pre><code class="language-python">def quick_sort(arr: list) -&gt; list:
    if len(arr) &lt;= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]

    return quick_sort(left) + middle + quick_sort(right)

# When to use: General-purpose sorting
# Pros: Usually fastest in practice
# Cons: Unstable, bad worst-case O(nÂ²)
</code></pre>
<ol>
<li><strong>Heap Sort</strong> (The Memory-Efficient Sort)</li>
</ol>
<pre><code class="language-python">def heapify(arr: list, n: int, i: int):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left &lt; n and arr[left] &gt; arr[largest]:
        largest = left
    if right &lt; n and arr[right] &gt; arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr: list) -&gt; list:
    n = len(arr)

    # Build max heap
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # Extract elements from heap
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

    return arr

# When to use: When space is a premium
# Pros: In-place, O(n log n) guaranteed
# Cons: Unstable, poor cache performance
</code></pre>
<h3 id="special-purpose-sorting-algorithms">ğŸ¨ Special Purpose Sorting Algorithms</h3>
<ol>
<li><strong>Shell Sort</strong>  (The Gap Sort)</li>
</ol>
<pre><code class="language-python">def shell_sort(arr: list) -&gt; list:
    n = len(arr)
    gap = n // 2

    while gap &gt; 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i

            while j &gt;= gap and arr[j-gap] &gt; temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2

    return arr

# When to use: Medium-sized arrays
# Pros: Adaptive, handles partially sorted arrays well
# Cons: Complex gap sequence selection
</code></pre>
<ol>
<li><strong>Counting Sort</strong> (The Integer Sort)</li>
</ol>
<pre><code class="language-python">def counting_sort(arr: list) -&gt; list:
    if not arr:
        return arr

    # Find range of array elements
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    # Create counting array and output array
    count = [0] * range_val
    output = [0] * len(arr)

    # Store count of each element
    for num in arr:
        count[num - min_val] += 1

    # Modify count array to store actual positions
    for i in range(1, len(count)):
        count[i] += count[i - 1]

    # Build output array
    for num in reversed(arr):
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

# When to use: Integer arrays with known range
# Pros: O(n) for known range integers
# Cons: Requires extra space proportional to range
</code></pre>
<ol>
<li><strong>Radix Sort</strong> (The Digit Sort)</li>
</ol>
<pre><code class="language-python">def counting_sort_for_radix(arr: list, exp: int) -&gt; list:
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # Store count of occurrences
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    # Change count[i] to contain actual position
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Build output array
    i = n - 1
    while i &gt;= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # Copy output array to arr
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr: list) -&gt; list:
    if not arr:
        return arr

    # Find maximum number to know number of digits
    max_val = max(arr)

    # Do counting sort for every digit
    exp = 1
    while max_val // exp &gt; 0:
        counting_sort_for_radix(arr, exp)
        exp *= 10

    return arr

# When to use: Integer arrays with fixed number of digits
# Pros: Linear time possible for fixed-length integers
# Cons: Only works with integers, uses extra space
</code></pre>
<ol>
<li><strong>Bucket Sort</strong> (The Distribution Sort)</li>
</ol>
<pre><code class="language-python">def bucket_sort(arr: list, num_buckets: int = 10) -&gt; list:
    if not arr:
        return arr

    # Find range of values
    max_val, min_val = max(arr), min(arr)

    # Create buckets
    range_val = (max_val - min_val) / num_buckets
    buckets = [[] for _ in range(num_buckets)]

    # Put elements in buckets
    for num in arr:
        if num == max_val:
            bucket_idx = num_buckets - 1
        else:
            bucket_idx = int((num - min_val) / range_val)
        buckets[bucket_idx].append(num)

    # Sort individual buckets
    for bucket in buckets:
        bucket.sort()  # Using TimSort internally in Python

    # Concatenate all buckets into arr
    return [num for bucket in buckets for num in bucket]

# When to use: Uniformly distributed data over a range
# Pros: Linear time possible for uniform distribution
# Cons: Requires uniform distribution for efficiency
</code></pre>
<ol>
<li><strong>Tim Sort</strong> (Python's Built-in Sort)</li>
</ol>
<pre><code class="language-python"># Python's built-in sort uses TimSort
def tim_sort_example(arr: list) -&gt; list:
    return sorted(arr)  # Uses TimSort internally

# When to use: General purpose sorting
# Pros: Excellent performance on real-world data
# Cons: Complex implementation, requires extra space
</code></pre>
<h3 id="best-practices-for-each-algorithm">ğŸ¯ Best Practices for Each Algorithm</h3>
<h2 id="simple-sorts-on2">Simple Sorts (O(nÂ²))</h2>
<ul>
<li><strong>Bubble Sort</strong>: Nearly sorted data, teaching purposes</li>
<li><strong>Selection Sort</strong>: Small arrays, minimizing swaps</li>
<li><strong>Insertion Sort</strong>: Small arrays, online sorting</li>
</ul>
<h2 id="efficient-sorts-on-log-n">Efficient Sorts (O(n log n))</h2>
<ul>
<li><strong>Merge Sort</strong>: Stable sorting needed, linked lists</li>
<li><strong>Quick Sort</strong>: General purpose, arrays</li>
<li><strong>Heap Sort</strong>: Memory constrained, guaranteed O(n log n)</li>
</ul>
<h2 id="special-purpose-sorts">Special Purpose Sorts</h2>
<ul>
<li><strong>Shell Sort</strong>: Medium-sized arrays, partially sorted data</li>
<li><strong>Counting Sort</strong>: Small range integers</li>
<li><strong>Radix Sort</strong>: Fixed-length integers, like phone numbers</li>
<li><strong>Bucket Sort</strong>: Uniformly distributed floating-point numbers</li>
<li><strong>Tim Sort</strong>: When you need the best of both worlds (stable &amp; efficient)</li>
</ul>
<h3 id="choosing-the-right-sort">ğŸ® Choosing the Right Sort</h3>
<ol>
<li><strong>Consider Your Data</strong><ul>
<li>Size of dataset</li>
<li>Data type (integers, floating-point, strings)</li>
<li>Data distribution</li>
<li>Range of values</li>
</ul>
</li>
<li><strong>Consider Your Constraints</strong><ul>
<li>Memory limitations</li>
<li>Stability requirements</li>
<li>Whether data is streaming (online)</li>
<li>Performance requirements</li>
</ul>
</li>
<li><strong>General Guidelines</strong><ul>
<li>Small dataset (n &lt; 50): Insertion Sort</li>
<li>Memory constrained: Heap Sort</li>
<li>Stability required: Merge Sort</li>
<li>General purpose: Quick Sort or Tim Sort</li>
<li>Integer data: Counting Sort or Radix Sort</li>
</ul>
</li>
</ol>
<p>Remember: In Python, use the built-in  <code>sort()</code>  or  <code>sorted()</code>  for best performance! They use TimSort, which is optimized for real-world data patterns. ğŸš€</p>
<h1 id="linked-lists-dummy-node-technique-guide">ğŸ”— Linked Lists &amp; Dummy Node Technique Guide</h1>
<h2 id="understanding-linked-lists">ğŸ“˜ Understanding Linked Lists</h2>
<h3 id="what-is-a-linked-list">ğŸ¯ What is a Linked List?</h3>
<pre><code class="language-python">class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
</code></pre>
<h3 id="types-of-linked-lists">ğŸ“Š Types of Linked Lists</h3>
<ol>
<li><strong>Singly Linked List</strong></li>
</ol>
<pre><code class="language-python"># 1 -&gt; 2 -&gt; 3 -&gt; None
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
</code></pre>
<ol>
<li><strong>Doubly Linked List</strong></li>
</ol>
<pre><code class="language-python">class DoublyListNode:
    def __init__(self, val=0, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev
</code></pre>
<ol>
<li><strong>Circular Linked List</strong></li>
</ol>
<pre><code class="language-python"># 1 -&gt; 2 -&gt; 3 -&gt; 1 (cycles back)
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = head  # Creates cycle
</code></pre>
<h2 id="core-implementation-options">ğŸ“š Core Implementation Options</h2>
<h3 id="1-using-collectionsdeque">1ï¸âƒ£ Using collections.deque</h3>
<pre><code class="language-python">from collections import deque

# Creating linked lists
llist = deque()              # Empty list
llist = deque([1, 2, 3])     # From iterable
llist = deque('abc')         # From string

# Common Operations
llist.append(x)      # Add to right
llist.appendleft(x)  # Add to left
llist.pop()          # Remove from right
llist.popleft()      # Remove from left
</code></pre>
<h3 id="2-custom-linked-list-implementation">2ï¸âƒ£ Custom Linked List Implementation</h3>
<pre><code class="language-python">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

    def __repr__(self):
        return str(self.data)

class LinkedList:
    def __init__(self, nodes=None):
        self.head = None
        if nodes:
            node = Node(data=nodes.pop(0))
            self.head = node
            for elem in nodes:
                node.next = Node(data=elem)
                node = node.next

    def __repr__(self):
        nodes = []
        curr = self.head
        while curr:
            nodes.append(str(curr.data))
            curr = curr.next
        return &quot; -&gt; &quot;.join(nodes + [&quot;None&quot;])

    def __iter__(self):
        node = self.head
        while node:
            yield node
            node = node.next
</code></pre>
<h2 id="common-pattern-templates">ğŸ¯ Common Pattern Templates</h2>
<h3 id="1-two-pointer-technique-template">1ï¸âƒ£ Two-Pointer Technique Template</h3>
<pre><code class="language-python">def two_pointer_template(head):
    # Initialize pointers
    slow = fast = head

    # Move pointers
    while fast and fast.next:
        slow = slow.next           # Move one step
        fast = fast.next.next      # Move two steps

        # Optional: Detection logic here
        if slow == fast:
            return True  # Or other logic

    return False
</code></pre>
<h3 id="2-reverse-list-template">2ï¸âƒ£ Reverse List Template</h3>
<pre><code class="language-python">def reverse_template(head):
    prev = None
    current = head

    while current:
        # Store next
        next_node = current.next
        # Reverse pointer
        current.next = prev
        # Move prev and current
        prev = current
        current = next_node

    return prev  # New head
</code></pre>
<h3 id="3-merge-lists-template">3ï¸âƒ£ Merge Lists Template</h3>
<pre><code class="language-python">def merge_template(l1, l2):
    dummy = Node(0)
    current = dummy

    while l1 and l2:
        if l1.val &lt;= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    # Attach remaining nodes
    current.next = l1 or l2
    return dummy.next
</code></pre>
<h2 id="essential-operations-templates">ğŸ› ï¸ Essential Operations Templates</h2>
<h3 id="1-node-insertion">1ï¸âƒ£ Node Insertion</h3>
<pre><code class="language-python">def insert_operations():
    # Insert at beginning - O(1)
    def add_first(self, node):
        node.next = self.head
        self.head = node

    # Insert at end - O(n)
    def add_last(self, node):
        if not self.head:
            self.head = node
            return
        for current in self:
            pass
        current.next = node

    # Insert after node - O(n)
    def add_after(self, target_data, new_node):
        if not self.head:
            raise Exception(&quot;List is empty&quot;)

        for node in self:
            if node.data == target_data:
                new_node.next = node.next
                node.next = new_node
                return

        raise Exception(&quot;Node not found&quot;)
</code></pre>
<h3 id="2-node-deletion">2ï¸âƒ£ Node Deletion</h3>
<pre><code class="language-python">def removal_template(self, target):
    if not self.head:
        raise Exception(&quot;List is empty&quot;)

    # Handle head removal
    if self.head.data == target:
        self.head = self.head.next
        return

    # Handle other removals
    current = self.head
    while current.next:
        if current.next.data == target:
            current.next = current.next.next
            return
        current = current.next

    raise Exception(&quot;Node not found&quot;)
</code></pre>
<h2 id="the-dummy-node-technique">ğŸ¯ The Dummy Node Technique</h2>
<h3 id="why-use-dummy-nodes">ğŸ”‘ Why Use Dummy Nodes?</h3>
<ol>
<li>Simplifies edge cases</li>
<li>Avoids null pointer exceptions</li>
<li>Makes code cleaner and more uniform</li>
<li>Particularly useful for:<ul>
<li>List manipulation</li>
<li>Merging lists</li>
<li>Removing elements</li>
<li>Complex operations</li>
</ul>
</li>
</ol>
<h3 id="dummy-node-pattern-template">ğŸ“ Dummy Node Pattern Template</h3>
<pre><code class="language-python">def linked_list_operation(head: ListNode) -&gt; ListNode:
    # Create dummy node
    dummy = ListNode(0)
    dummy.next = head

    # Work with dummy node
    current = dummy
    while current.next:
        # Perform operations
        current = current.next

    # Return modified list
    return dummy.next
</code></pre>
<h3 id="advanced-techniques-with-dummy-nodes">ğŸ¯ Advanced Techniques with Dummy Nodes</h3>
<ol>
<li><strong>Multiple Dummy Nodes</strong></li>
</ol>
<pre><code class="language-python">def oddEvenList(head: ListNode) -&gt; ListNode:
    if not head:
        return None

    # Two dummy nodes for odd and even lists
    odd_dummy = ListNode(0)
    even_dummy = ListNode(0)
    odd = odd_dummy
    even = even_dummy

    is_odd = True
    current = head

    while current:
        if is_odd:
            odd.next = current
            odd = odd.next
        else:
            even.next = current
            even = even.next
        is_odd = not is_odd
        current = current.next

    # Connect odd and even lists
    odd.next = even_dummy.next
    even.next = None
    return odd_dummy.next
</code></pre>
<ol>
<li><strong>Dummy Node w/ Fast/Slower Pointers</strong></li>
</ol>
<pre><code class="language-python">def hasCycle(head: ListNode) -&gt; bool:
    dummy = ListNode(0)
    dummy.next = head
    slow = dummy
    fast = dummy

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False
</code></pre>
<h3 id="interview-tips">ğŸ¯ Interview Tips</h3>
<ol>
<li><strong>When to Use Dummy Nodes</strong><ul>
<li>List modification required</li>
<li>Head might change</li>
<li>Multiple pointer manipulation</li>
<li>Merging or splitting lists</li>
</ul>
</li>
<li><strong>Common Patterns</strong></li>
</ol>
<pre><code class="language-python"># Pattern 1: Basic Dummy Node
dummy = ListNode(0)
dummy.next = head
current = dummy

# Pattern 2: Multiple Pointers
dummy = ListNode(0)
slow = fast = dummy

# Pattern 3: Multiple Dummies
dummy1 = ListNode(0)
dummy2 = ListNode(0)
</code></pre>
<ol>
<li><strong>Edge Cases to Consider</strong><ul>
<li>Empty list</li>
<li>Single node</li>
<li>Two nodes</li>
<li>Cycles in list</li>
<li>Duplicate values</li>
</ul>
</li>
</ol>
<h3 id="practice-problems_1">ğŸ® Practice Problems</h3>
<ol>
<li>Reverse Linked List</li>
<li>Detect Cycle</li>
<li>Find Middle Node</li>
<li>Remove Duplicates</li>
<li>Merge K Sorted Lists</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always handle edge cases first</li>
<li>Consider using dummy nodes for cleaner code</li>
<li>Test with small examples</li>
<li>Draw the list operations on paper</li>
<li>Keep track of all pointers carefully</li>
</ul>
<h1 id="stack-queue-implementations-in-python">ğŸ”„ Stack &amp; Queue Implementations in Python</h1>
<h2 id="stack-implementations">ğŸ“š Stack Implementations</h2>
<h3 id="1-using-list-as-stack">1ï¸âƒ£ Using List as Stack</h3>
<pre><code class="language-python">class ListStack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        raise IndexError(&quot;Stack is empty&quot;)

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]
        raise IndexError(&quot;Stack is empty&quot;)

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)
</code></pre>
<h3 id="2-using-collectionsdeque-as-stack">2ï¸âƒ£ Using Collections.deque as Stack</h3>
<pre><code class="language-python">from collections import deque

class DequeStack:
    def __init__(self):
        self.stack = deque()

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        raise IndexError(&quot;Stack is empty&quot;)

    def peek(self):
        if not self.is_empty():
            return self.stack[-1]
        raise IndexError(&quot;Stack is empty&quot;)

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)
</code></pre>
<h3 id="common-stack-pattern-templates">Common Stack Pattern Templates</h3>
<ol>
<li><strong>Basic Stack Operations Pattern</strong></li>
</ol>
<pre><code class="language-python">def stack_pattern(data):
    stack = []  # or deque()

    for item in data:
        # Process current item
        while stack and some_condition(stack[-1], item):
            # Do something with stack.pop()
            pass
        stack.append(item)

    return result
</code></pre>
<ol>
<li><strong>Monotonic Stack Pattern</strong></li>
</ol>
<pre><code class="language-python">def monotonic_stack_pattern(arr):
    stack = []  # stores indices usually
    result = [0] * len(arr)  # or any default value

    for i in range(len(arr)):
        # For increasing stack (next smaller)
        while stack and arr[stack[-1]] &gt; arr[i]:
            popped = stack.pop()
            result[popped] = i - popped  # or any calculation
        stack.append(i)

    return result
</code></pre>
<h2 id="queue-implementations">ğŸ“ Queue Implementations</h2>
<h3 id="1-using-collectionsdeque-as-queue">1ï¸âƒ£ Using Collections.deque as Queue</h3>
<pre><code class="language-python">from collections import deque

class DequeQueue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.popleft()
        raise IndexError(&quot;Queue is empty&quot;)

    def front(self):
        if not self.is_empty():
            return self.queue[0]
        raise IndexError(&quot;Queue is empty&quot;)

    def rear(self):
        if not self.is_empty():
            return self.queue[-1]
        raise IndexError(&quot;Queue is empty&quot;)

    def is_empty(self):
        return len(self.queue) == 0

    def size(self):
        return len(self.queue)
</code></pre>
<h3 id="2-queue-implementation">2ï¸âƒ£ Queue Implementation</h3>
<pre><code class="language-python">from queue import Queue

# Thread-safe queue usage
queue = Queue()
queue.put(item)      # Enqueue
item = queue.get()   # Dequeue
size = queue.qsize() # Size
empty = queue.empty()
</code></pre>
<h2 id="common-implementation-patterns">ğŸ¯ Common Implementation Patterns</h2>
<h3 id="pattern-1-lifo-stack-pattern">Pattern 1: LIFO Stack Pattern</h3>
<pre><code class="language-python">def stack_pattern(data):
    stack = []  # or deque()

    for item in data:
        # Process current item
        while stack and condition(stack[-1], item):
            # Process stack.pop()
            pass
        stack.append(item)

    return result
</code></pre>
<h3 id="pattern-2-fifo-queue-pattern">Pattern 2: FIFO Queue Pattern</h3>
<pre><code class="language-python">def queue_pattern(start_node):
    queue = deque([start_node])
    seen = {start_node}

    while queue:
        current = queue.popleft()
        # Process current node

        for neighbor in get_neighbors(current):
            if neighbor not in seen:
                seen.add(neighbor)
                queue.append(neighbor)
</code></pre>
<h2 id="key-operations-complexities">ğŸ”‘ Key Operations &amp; Complexities</h2>
<h3 id="stack-operations">Stack Operations</h3>
<pre><code class="language-python">operations = {
    'push':    'O(1)',  # Add to top
    'pop':     'O(1)',  # Remove from top
    'peek':    'O(1)',  # View top element
    'isEmpty': 'O(1)',  # Check if empty
    'size':    'O(1)'   # Get number of elements
}
</code></pre>
<h3 id="queue-operations">Queue Operations</h3>
<pre><code class="language-python">operations = {
    'enqueue': 'O(1)',  # Add to back
    'dequeue': 'O(1)',  # Remove from front
    'front':   'O(1)',  # View front element
    'isEmpty': 'O(1)',  # Check if empty
    'size':    'O(1)'   # Get number of elements
}
</code></pre>
<h2 id="when-to-use-what">ğŸ’¡When to Use What</h2>
<h3 id="use-stack-when">Use Stack When:</h3>
<ul>
<li>Need LIFO (Last In, First Out) behavior</li>
<li>Tracking state changes (undo/redo)</li>
<li>Parse expressions (parentheses matching)</li>
<li>Function call management</li>
<li>DFS implementation</li>
</ul>
<h3 id="use-queue-when">Use Queue When:</h3>
<ul>
<li>Need FIFO (First In, First Out) behavior</li>
<li>Order must be preserved</li>
<li>BFS implementation</li>
<li>Task scheduling</li>
<li>Resource pooling</li>
</ul>
<h2 id="implementation-comparison">ğŸ¯ Implementation Comparison</h2>
<h3 id="stack-implementation-comparison">Stack Implementation Comparison</h3>
<pre><code># List as Stack
- Pros: Simple, built-in, good for small data
- Cons: Potential memory reallocation for large data
- Use when: Simple stack operations needed

# Deque as Stack
- Pros: Efficient memory usage, thread-safe
- Cons: Slightly more complex than list
- Use when: Large data or thread safety needed
</code></pre>
<h3 id="queue-implementation-comparison">Queue Implementation Comparison</h3>
<pre><code># Deque as Queue
- Pros: O(1) operations, efficient memory
- Cons: Not fixed size
- Use when: General queue operations needed

# Queue
- Pros: Memory efficient, fixed size
- Cons: More complex implementation
- Use when: Fixed size buffer needed
</code></pre>
<h2 id="practice-problem-tips">ğŸ® Practice Problem Tips</h2>
<ol>
<li>Always clarify:<ul>
<li>Is there a size limit?</li>
<li>What happens on empty pop/dequeue?</li>
<li>Should operations be thread-safe?</li>
<li>What type of elements to store?</li>
</ul>
</li>
<li>Consider:<ul>
<li>Time/Space complexity requirements</li>
<li>Concurrency needs</li>
<li>Error handling approach</li>
<li>Edge cases</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Use  <code>collections.deque</code>  for efficient implementation</li>
<li>Consider thread-safety needs before choosing implementation</li>
<li>Watch for operation order dependence</li>
<li>Handle edge cases explicitly</li>
</ul>
<h1 id="hash-tables-in-python-dictionaries">ğŸ—ƒï¸ Hash Tables in Python (Dictionaries)</h1>
<h2 id="basic-implementation">ğŸ“š Basic Implementation</h2>
<h3 id="1-dictionary-creation">1ï¸âƒ£ Dictionary Creation</h3>
<pre><code class="language-python"># Method 1: Using curly braces
hash_map = {
    'key1': 'value1',
    'key2': 'value2'
}

# Method 2: Using dict() constructor
hash_map = dict(
    key1='value1',
    key2='value2'
)

# Method 3: From list of tuples
hash_map = dict([
    ('key1', 'value1'),
    ('key2', 'value2')
])

# Method 4: Empty dictionary
hash_map = {}
</code></pre>
<h3 id="2-basic-operations">2ï¸âƒ£ Basic Operations</h3>
<pre><code class="language-python"># Access Operations - O(1) average case
hash_map['key'] = 'value'  # Insert/Update
value = hash_map['key']    # Access
del hash_map['key']        # Delete

# Safe Access
value = hash_map.get('key', default_value)  # Returns default_value if key not found

# Check Existence - O(1)
if 'key' in hash_map:
    # Key exists
    pass
</code></pre>
<h2 id="common-hash-table-patterns">ğŸ¯ Common Hash Table Patterns</h2>
<h3 id="1-counting-pattern">1ï¸âƒ£ Counting Pattern</h3>
<pre><code class="language-python">def counting_pattern(items):
    counter = {}

    # Count occurrences
    for item in items:
        counter[item] = counter.get(item, 0) + 1

    return counter

# Alternative using defaultdict
from collections import defaultdict

def counting_with_defaultdict(items):
    counter = defaultdict(int)
    for item in items:
        counter[item] += 1
    return counter
</code></pre>
<h3 id="2-grouping-pattern">2ï¸âƒ£ Grouping Pattern</h3>
<pre><code class="language-python">def grouping_pattern(items, key_func):
    groups = {}

    for item in items:
        key = key_func(item)
        if key not in groups:
            groups[key] = []
        groups[key].append(item)

    return groups

# Alternative using defaultdict
def grouping_with_defaultdict(items, key_func):
    groups = defaultdict(list)
    for item in items:
        groups[key_func(item)].append(item)
    return groups
</code></pre>
<h3 id="3-cachingmemoization-pattern">3ï¸âƒ£ Caching/Memoization Pattern</h3>
<pre><code class="language-python">def memoization_pattern():
    cache = {}

    def memoized_func(arg):
        if arg not in cache:
            cache[arg] = compute_value(arg)
        return cache[arg]

    return memoized_func

# Alternative using @lru_cache
from functools import lru_cache

@lru_cache(maxsize=None)
def cached_function(arg):
    return compute_value(arg)
</code></pre>
<h3 id="4-two-sum-pattern">4ï¸âƒ£ Two-Sum Pattern</h3>
<pre><code class="language-python">def two_sum_pattern(nums, target):
    seen = {}  # value -&gt; index

    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

    return []
</code></pre>
<h2 id="advanced-techniques">ğŸ® Advanced Techniques</h2>
<h3 id="1-multi-level-dictionary">1ï¸âƒ£ Multi-Level Dictionary</h3>
<pre><code class="language-python"># Creation
multi_level = {
    'level1': {
        'level2': {
            'level3': 'value'
        }
    }
}

# Safe Navigation
def safe_get(dictionary, *keys, default=None):
    current = dictionary
    for key in keys:
        if not isinstance(current, dict):
            return default
        current = current.get(key, default)
    return current
</code></pre>
<h3 id="2-dictionary-comprehension">2ï¸âƒ£ Dictionary Comprehension</h3>
<pre><code class="language-python"># Basic comprehension
squares = {x: x*x for x in range(5)}

# Conditional comprehension
even_squares = {x: x*x for x in range(5) if x % 2 == 0}

# Transforming dictionaries
transformed = {k: v*2 for k, v in original.items()}
</code></pre>
<h3 id="3-advanced-operations">3ï¸âƒ£ Advanced Operations</h3>
<pre><code class="language-python"># Merging dictionaries
dict3 = {**dict1, **dict2}  # Python 3.5+
dict3 = dict1 | dict2       # Python 3.9+

# Get multiple values safely
values = [hash_map.get(key) for key in keys]

# Delete multiple keys
for key in keys_to_delete:
    hash_map.pop(key, None)  # Won't raise KeyError
</code></pre>
<h2 id="common-interview-problem-patterns">ğŸ“ Common Interview Problem Patterns</h2>
<ol>
<li><strong>Frequency Counter Problems</strong><ul>
<li>Character frequency in strings</li>
<li>Word frequency in sentences</li>
<li>Element frequency in arrays</li>
</ul>
</li>
<li><strong>Two-Sum Type Problems</strong><ul>
<li>Finding pairs with target sum</li>
<li>Finding triplets</li>
<li>Subarray with given sum</li>
</ul>
</li>
<li><strong>Caching Problems</strong><ul>
<li>Implementing LRU cache</li>
<li>Memoization problems</li>
<li>Function results caching</li>
</ul>
</li>
<li><strong>String Problems</strong><ul>
<li>Anagram detection</li>
<li>First non-repeating character</li>
<li>String permutations</li>
</ul>
</li>
</ol>
<h2 id="practice-problems_2">ğŸ¯ Practice Problems</h2>
<ol>
<li><strong>Frequency Based</strong><ul>
<li>Find the first non-repeating character in a string</li>
<li>Find if two strings are anagrams</li>
<li>Most frequent element in an array</li>
</ul>
</li>
<li><strong>Lookup Based</strong><ul>
<li>Implement two sum</li>
<li>Group anagrams together</li>
<li>Find all pairs with given difference</li>
</ul>
</li>
<li><strong>Caching Based</strong><ul>
<li>Implement LRU cache</li>
<li>Design a file system cache</li>
<li>Implement memoization decorator</li>
</ul>
</li>
<li><strong>Advanced Problems</strong><ul>
<li>Design a time-based key-value store</li>
<li>Implement a data structure that supports insert, delete, getRandom in O(1)</li>
<li>Design a logger rate limiter</li>
</ul>
</li>
</ol>
<h2 id="common-pitfalls-to-watch-for">âš ï¸ Common Pitfalls to Watch For</h2>
<ol>
<li><strong>Mutability Issues</strong><ul>
<li>Using mutable objects as dictionary keys</li>
<li>Modifying dictionary while iterating</li>
</ul>
</li>
<li><strong>Performance Traps</strong><ul>
<li>Repeatedly accessing the same key</li>
<li>Not using .get() for default values</li>
<li>Unnecessary key existence checks</li>
</ul>
</li>
<li><strong>Memory Issues</strong><ul>
<li>Unbounded growth in caching problems</li>
<li>Not clearing references in long-running applications</li>
</ul>
</li>
<li><strong>Edge Cases</strong><ul>
<li>Empty dictionaries</li>
<li>Non-existent keys</li>
<li>None values vs missing keys</li>
</ul>
</li>
</ol>
<p>Remember: Hash tables provide O(1) average case operations but require good hash functions and collision handling strategies. In Python, this is handled automatically by the dictionary implementation.</p>
<h1 id="heaps-for-technical-interviews">ğŸŒ³ Heaps for Technical Interviews</h1>
<h2 id="core-concepts">ğŸ“š Core Concepts</h2>
<h3 id="what-is-a-heap">What is a Heap?</h3>
<pre><code class="language-python">&quot;&quot;&quot;
A heap is a complete binary tree that satisfies the heap property:
- Max Heap: Parent nodes are greater than or equal to children
- Min Heap: Parent nodes are less than or equal to children
- Python's heapq implements min heap
&quot;&quot;&quot;

# Key Properties:
properties = {
    &quot;Complete Binary Tree&quot;: &quot;All levels filled except possibly last level&quot;,
    &quot;Heap Property&quot;: &quot;Parent-child relationship maintained throughout&quot;,
    &quot;Root&quot;: &quot;Smallest element (min heap) or largest element (max heap)&quot;,
    &quot;Implementation&quot;: &quot;Usually backed by an array/list&quot;,
    &quot;Height&quot;: &quot;O(log n) where n is number of nodes&quot;
}
</code></pre>
<h3 id="parent-child-relationships-in-array-implementation">Parent-Child Relationships in Array Implementation</h3>
<pre><code class="language-python">def get_relationships(i: int) -&gt; dict:
    return {
        'parent': (i - 1) // 2,    # Parent index
        'left_child': 2 * i + 1,   # Left child index
        'right_child': 2 * i + 2,  # Right child index
    }    
</code></pre>
<h2 id="basic-operations-using-heapq">ğŸ”§ Basic Operations Using heapq</h2>
<h3 id="1-heap-creation">1. Heap Creation</h3>
<pre><code class="language-python">import heapq

# Method 1: Heapify existing list
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
heapq.heapify(numbers)  # O(n)

# Method 2: Create empty heap (just use list)
heap = []
</code></pre>
<h3 id="2-core-operations">2. Core Operations</h3>
<pre><code class="language-python">def heap_operations():
    heap = []

    # Push - O(log n)
    heapq.heappush(heap, 5)

    # Pop - O(log n)
    smallest = heapq.heappop(heap)

    # Peek - O(1)
    if heap:
        smallest = heap[0]

    # Push and Pop combined - O(log n)
    smallest = heapq.heappushpop(heap, 4)  # Push then pop
    smallest = heapq.heapreplace(heap, 4)  # Pop then push
</code></pre>
<h3 id="3-helper-functions">3. Helper Functions</h3>
<pre><code class="language-python">def heap_helpers(items):
    # Find n smallest elements - O(n log k)
    n_smallest = heapq.nsmallest(3, items)

    # Find n largest elements - O(n log k)
    n_largest = heapq.nlargest(3, items)

    # Merge sorted iterables - O(n log k)
    merged = heapq.merge([1,3,5], [2,4,6])
</code></pre>
<h2 id="common-heap-patterns">ğŸ¯ Common Heap Patterns</h2>
<h3 id="1-priority-queue-implementation">1. Priority Queue Implementation</h3>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Any

@dataclass(order=True)
class PrioritizedItem:
    priority: int
    item: Any = field(compare=False)

class PriorityQueue:
    def __init__(self):
        self._queue = []

    def push(self, item, priority):
        heapq.heappush(self._queue, PrioritizedItem(priority, item))

    def pop(self):
        return heapq.heappop(self._queue).item

    def peek(self):
        return self._queue[0].item if self._queue else None
</code></pre>
<h3 id="2-k-way-merge-pattern">2. K-Way Merge Pattern</h3>
<pre><code class="language-python">def k_way_merge(sorted_arrays):
    &quot;&quot;&quot;Merge k sorted arrays using heap.&quot;&quot;&quot;
    merged = []
    heap = []

    # Initialize heap with first element from each array
    for i, arr in enumerate(sorted_arrays):
        if arr:
            heapq.heappush(heap, (arr[0], i, 0))

    while heap:
        val, array_index, elem_index = heapq.heappop(heap)
        merged.append(val)

        if elem_index + 1 &lt; len(sorted_arrays[array_index]):
            next_val = sorted_arrays[array_index][elem_index + 1]
            heapq.heappush(heap, (next_val, array_index, elem_index + 1))

    return merged
</code></pre>
<h3 id="3-running-median-pattern">3. Running Median Pattern</h3>
<pre><code class="language-python">class MedianFinder:
    def __init__(self):
        self.small = []  # max heap (-ve numbers)
        self.large = []  # min heap

    def add_num(self, num: int) -&gt; None:
        # Add to appropriate heap
        if len(self.small) == len(self.large):
            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))
        else:
            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))

    def find_median(self) -&gt; float:
        if len(self.small) == len(self.large):
            return (-self.small[0] + self.large[0]) / 2.0
        return float(self.large[0])
</code></pre>
<h2 id="common-interview-problems">ğŸ¯ Common Interview Problems</h2>
<h3 id="problem-types">Problem Types</h3>
<ol>
<li>K-th Element Problems</li>
</ol>
<pre><code class="language-python">def find_kth_largest(nums: List[int], k: int) -&gt; int:
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
        if len(heap) &gt; k:
            heapq.heappop(heap)
    return heap[0]
</code></pre>
<ol>
<li>Merge Problems</li>
</ol>
<pre><code class="language-python">def merge_k_arrays(arrays: List[List[int]]) -&gt; List[int]:
    return list(heapq.merge(*arrays))
</code></pre>
<ol>
<li>Scheduling Problems</li>
</ol>
<pre><code class="language-python">def min_meeting_rooms(intervals: List[List[int]]) -&gt; int:
    heap = []  # Track end times
    for start, end in sorted(intervals):
        if heap and heap[0] &lt;= start:
            heapq.heapreplace(heap, end)
        else:
            heapq.heappush(heap, end)
    return len(heap)    
</code></pre>
<h3 id="edge-cases-to-consider">âš ï¸ Edge Cases to Consider</h3>
<pre><code class="language-python">def edge_cases_to_check():
    &quot;&quot;&quot;
    1. Empty heap operations
    2. Single element heap
    3. Duplicate elements
    4. Negative numbers
    5. Very large numbers
    6. Equal priorities in priority queue
    &quot;&quot;&quot;
    pass
</code></pre>
<h3 id="time-complexity-summary">ğŸ¯ Time Complexity Summary</h3>
<pre><code class="language-python">complexities = {
    &quot;heapify&quot;: &quot;O(n)&quot;,
    &quot;push&quot;: &quot;O(log n)&quot;,
    &quot;pop&quot;: &quot;O(log n)&quot;,
    &quot;peek&quot;: &quot;O(1)&quot;,
    &quot;heappushpop&quot;: &quot;O(log n)&quot;,
    &quot;nlargest/nsmallest&quot;: &quot;O(n log k)&quot;,  # where k is the count requested
    &quot;merge k sorted lists&quot;: &quot;O(n log k)&quot;  # where k is number of lists
}
</code></pre>
<h2 id="interview-tips_1">ğŸ’¡ Interview Tips</h2>
<ol>
<li>Use heap when:<ul>
<li>Need to find k largest/smallest elements</li>
<li>Need to continuously find min/max</li>
<li>Need to merge sorted sequences</li>
<li>Implementing priority queue</li>
</ul>
</li>
<li>Python Heap Notes:<ul>
<li>heapq implements min heap</li>
<li>For max heap, negate values</li>
<li>No decrease-key operation</li>
<li>Can't access arbitrary elements</li>
</ul>
</li>
<li>Solution Strategy:<ul>
<li>Identify if problem needs min or max heap</li>
<li>Consider if heap is overkill (sorted list might work)</li>
<li>Check if priority queue would be clearer</li>
<li>Think about space complexity tradeoffs</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always verify time/space complexity</li>
<li>Consider edge cases</li>
<li>Explain heap property while coding</li>
<li>Mention alternative approaches</li>
</ul>
<h1 id="recursion-guide-for-technical-interviews">ğŸ”„ Recursion Guide for Technical Interviews</h1>
<h2 id="core-concepts_1">ğŸ“š Core Concepts</h2>
<h3 id="what-is-recursion">What is Recursion?</h3>
<pre><code class="language-python">&quot;&quot;&quot;
Recursion is when a function calls itself either:
1. Directly: The function directly calls itself
2. Indirectly: Function A calls Function B which calls Function A

Key Components:
1. Base Case (stopping condition)
2. Recursive Case (moving towards base case)
&quot;&quot;&quot;
</code></pre>
<h3 id="key-elements-of-recursive-function">Key Elements of Recursive Function</h3>
<pre><code class="language-python">def recursive_function(input):
    # 1. Base Case
    if input &lt;= base_case:
        return base_value

    # 2. Recursive Case
    # - Must move towards base case
    # - Usually operates on smaller input
    return recursive_function(smaller_input)
</code></pre>
<h2 id="common-recursion-patterns">ğŸ¯ Common Recursion Patterns</h2>
<h3 id="1-linear-recursion-pattern">1. Linear Recursion Pattern</h3>
<pre><code class="language-python">def linear_recursion(n: int) -&gt; int:
    # Base case
    if n &lt;= 0:
        return base_value

    # Single recursive call
    return recursive_step(linear_recursion(n - 1))

# Example: Factorial
def factorial(n: int) -&gt; int:
    if n &lt;= 1:  # Base case
        return 1
    return n * factorial(n - 1)  # Recursive case
</code></pre>
<h3 id="2-binary-recursion-pattern">2. Binary Recursion Pattern</h3>
<pre><code class="language-python">def binary_recursion(data):
    # Base case
    if base_condition(data):
        return base_value

    # Two recursive calls
    left = binary_recursion(left_portion(data))
    right = binary_recursion(right_portion(data))
    return combine(left, right)

# Example: Binary Tree Traversal
def traverse(root):
    if not root:
        return
    traverse(root.left)
    traverse(root.right)
</code></pre>
<h3 id="3-tail-recursion-pattern">3. Tail Recursion Pattern</h3>
<pre><code class="language-python">def tail_recursion(n, accumulator=initial_value):
    # Base case
    if n &lt;= 0:
        return accumulator

    # Recursive call must be last operation
    return tail_recursion(n - 1, next_accumulator)

# Example: Tail Recursive Factorial
def factorial_tail(n: int, acc: int = 1) -&gt; int:
    if n &lt;= 1:
        return acc
    return factorial_tail(n - 1, n * acc)
</code></pre>
<h3 id="4-nested-recursion-pattern">4. Nested Recursion Pattern</h3>
<pre><code class="language-python">def nested_recursion(n):
    # Base case
    if n &lt;= 0:
        return base_value

    # Recursive call within recursive call
    return nested_recursion(nested_recursion(n - 1))
</code></pre>
<h2 id="common-interview-problem-types">ğŸ“ Common Interview Problem Types</h2>
<h3 id="1-treegraph-problems">1. Tree/Graph Problems</h3>
<pre><code class="language-python">def tree_traversal(root):
    # Base case
    if not root:
        return

    # Process current node
    process(root)

    # Recurse on children
    for child in root.children:
        tree_traversal(child)
</code></pre>
<h3 id="2-stringarray-problems">2. String/Array Problems</h3>
<pre><code class="language-python">def is_palindrome(s: str) -&gt; bool:
    # Base case: empty string or single char
    if len(s) &lt;= 1:
        return True

    # Check outermost chars and recurse on inner
    return s[0] == s[-1] and is_palindrome(s[1:-1])
</code></pre>
<h3 id="3-divide-and-conquer-problems">3. Divide and Conquer Problems</h3>
<pre><code class="language-python">def quick_sort(arr: list) -&gt; list:
    # Base case
    if len(arr) &lt;= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]

    # Recursive case
    return quick_sort(left) + middle + quick_sort(right)
</code></pre>
<h2 id="common-pitfalls-solutions">âš ï¸ Common Pitfalls &amp; Solutions</h2>
<h3 id="1-stack-overflow">1. Stack Overflow</h3>
<pre><code class="language-python">from sys import setrecursionlimit

def handle_deep_recursion(n: int):
    # Increase recursion limit if needed
    setrecursionlimit(10000)  # Default is 1000

    # Or better: Convert to iteration
    def iterative_version():
        stack = []
        while stack:
            # Process iteratively
            pass
</code></pre>
<h3 id="2-redundant-computations">2. Redundant Computations</h3>
<pre><code class="language-python">def fibonacci_with_memo(n: int, memo: dict = None) -&gt; int:
    if memo is None:
        memo = {}

    # Check memo before computing
    if n in memo:
        return memo[n]

    # Base cases
    if n &lt;= 1:
        return n

    # Store result in memo
    memo[n] = fibonacci_with_memo(n-1, memo) + fibonacci_with_memo(n-2, memo)
    return memo[n]
</code></pre>
<h3 id="3-not-moving-towards-base-case">3. Not Moving Towards Base Case</h3>
<pre><code class="language-python">def ensure_progress(n: int) -&gt; int:
    # Bad: Might never reach base case
    if n != 0:
        return ensure_progress(n)

    # Good: Always moves towards base case
    if n &lt;= 0:
        return 0
    return ensure_progress(n - 1)
</code></pre>
<h2 id="timespace-complexity-analysis">ğŸ¯ Time/Space Complexity Analysis</h2>
<h3 id="time-complexity-patterns">Time Complexity Patterns</h3>
<pre><code class="language-python">complexities = {
    &quot;Linear Recursion&quot;: &quot;O(n) - Each call reduces n by 1&quot;,
    &quot;Binary Recursion&quot;: &quot;O(2^n) - Each call spawns 2 more calls&quot;,
    &quot;Divide &amp; Conquer&quot;: &quot;O(n log n) - Divides problem in half each time&quot;,
    &quot;Tail Recursion&quot;: &quot;O(n) - Can be optimized by compiler&quot;,
}
</code></pre>
<h3 id="space-complexity-considerations">Space Complexity Considerations</h3>
<pre><code class="language-python">space_usage = {
    &quot;Call Stack&quot;: &quot;Each recursive call adds a frame&quot;,
    &quot;Linear Recursion&quot;: &quot;O(n) stack space&quot;,
    &quot;Tail Recursion&quot;: &quot;O(1) with optimization&quot;,
    &quot;Tree Recursion&quot;: &quot;O(h) where h is tree height&quot;
}
</code></pre>
<h2 id="interview-tips_2">ğŸ’¡ Interview Tips</h2>
<ol>
<li>Always start with:<ul>
<li>Base case identification</li>
<li>How to move towards base case</li>
<li>Whether recursion makes sense</li>
</ul>
</li>
<li>Consider converting to iteration if:<ul>
<li>Deep recursion possible</li>
<li>Space complexity is crucial</li>
<li>Performance is critical</li>
</ul>
</li>
<li>Optimize using:<ul>
<li>Memoization for overlapping subproblems</li>
<li>Tail recursion when possible</li>
<li>Helper functions for additional parameters</li>
</ul>
</li>
<li>Be prepared to explain:<ul>
<li>Why recursion is appropriate</li>
<li>Space/time complexity</li>
<li>How to handle edge cases</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Clarity over cleverness</li>
<li>Consider both recursive and iterative solutions</li>
<li>Watch for stack overflow in large inputs</li>
<li>Test with small examples first</li>
</ul>
<h1 id="backtracking-guide">â™»ï¸ Backtracking Guide</h1>
<h2 id="core-properties">ğŸ“š Core Properties</h2>
<h3 id="1-property-1-no-repetition-and-completion">1ï¸âƒ£ Property 1: No Repetition and Completion</h3>
<pre><code class="language-python">&quot;&quot;&quot;
Backtracking is a systematic method that:
1. Avoids repetitions
2. Doesn't miss any possible solutions
3. Builds solutions incrementally
4. Returns to previous states (&quot;backtracks&quot;)

Ideal for:
- Combinatorial problems (permutations, combinations)
- Enumeration problems
- Path finding in graphs
&quot;&quot;&quot;
</code></pre>
<h3 id="2-property-2-search-pruning">2ï¸âƒ£ Property 2: Search Pruning</h3>
<pre><code class="language-python">&quot;&quot;&quot;
During solution building:
1. Evaluates partial solutions
2. Prunes branches that can't lead to valid solutions
3. Skips invalid configurations
4. Abandons paths worse than known solutions

Ideal for:
- Constraint satisfaction problems (CSP)
- Optimization problems
- Game-playing scenarios
&quot;&quot;&quot;
</code></pre>
<h2 id="implementation-patterns">ğŸ¯ Implementation Patterns</h2>
<h3 id="1-two-pass-pattern">1. Two-Pass Pattern</h3>
<pre><code class="language-python">def backtrack_pattern(input_data):
    def dfs(curr_state):
        # Forward Pass: Build solution incrementally
        for choice in get_valid_choices(curr_state):
            # 1. Make choice
            apply_choice(curr_state, choice)

            # 2. Recurse
            dfs(curr_state)

            # Backward Pass: Reset state
            undo_choice(curr_state, choice)

    initial_state = create_initial_state()
    dfs(initial_state)
</code></pre>
<h3 id="best-used-when">Best Used When:</h3>
<ol>
<li><strong>State Modification Required</strong></li>
</ol>
<pre><code class="language-python"># Example: N-Queens Problem
def solve_n_queens(n):
    def dfs(board, row):
        # Forward: Place queen
        board[row][col] = 'Q'
        solve_further(board, row + 1)
        # Backward: Remove queen
        board[row][col] = '.'
</code></pre>
<ol>
<li><strong>Grid/Matrix Problems</strong></li>
</ol>
<pre><code class="language-python"># Example: Maze Solving
def solve_maze(maze):
    def dfs(x, y):
        # Forward: Mark path
        maze[x][y] = 'PATH'
        explore_neighbors(x, y)
        # Backward: Unmark if dead end
        maze[x][y] = 'EMPTY'
</code></pre>
<ol>
<li><strong>Graph Problems with State Changes</strong></li>
</ol>
<pre><code class="language-python"># Example: Graph Coloring
def color_graph(graph):
    def dfs(node, colors):
        # Forward: Color node
        node.color = next_color
        color_neighbors(node)
        # Backward: Reset if invalid
        node.color = None
</code></pre>
<h3 id="characteristics">Characteristics:</h3>
<ul>
<li>Need to maintain and restore state</li>
<li>Solutions built by modifying shared state</li>
<li>Requires explicit cleanup</li>
<li>Common in problems with global constraints</li>
</ul>
<h3 id="2-state-tracking-pattern">2. State Tracking Pattern</h3>
<pre><code class="language-python">def state_tracking_pattern():
    used = set()  # or list/array for tracking used elements
    curr = []     # current partial solution

    def dfs(state):
        if is_complete(state):
            record_solution(curr[:])
            return

        for choice in get_choices(state):
            if choice not in used:
                # Forward pass
                used.add(choice)
                curr.append(choice)

                dfs(next_state(state, choice))

                # Backward pass
                used.remove(choice)
                curr.pop()
</code></pre>
<h3 id="best-used-when_1">Best Used When:</h3>
<ol>
<li><strong>Building Combinations/Permutations</strong></li>
</ol>
<pre><code class="language-python"># Example: Generate Subsets
def subsets(nums):
    result = []
    curr = []
    def dfs(start):
        result.append(curr[:])
        for i in range(start, len(nums)):
            curr.append(nums[i])
            dfs(i + 1)
            curr.pop()
</code></pre>
<ol>
<li><strong>Building Sequences</strong></li>
</ol>
<pre><code class="language-python"># Example: Phone Number Letter Combinations
def letter_combinations(digits):
    curr = []
    def dfs(index):
        if len(curr) == len(digits):
            result.append(''.join(curr))
            return
        for letter in mapping[digits[index]]:
            curr.append(letter)
            dfs(index + 1)
            curr.pop()
</code></pre>
<ol>
<li><strong>Path Finding Without State Modification</strong></li>
</ol>
<pre><code class="language-python"># Example: All Paths from Source to Target
def all_paths(graph):
    curr_path = []
    def dfs(node):
        curr_path.append(node)
        dfs(next_node)
        curr_path.pop()
</code></pre>
<h3 id="characteristics_1">Characteristics:</h3>
<ul>
<li>Solutions built by tracking sequences</li>
<li>No need for explicit state restoration</li>
<li>Usually involves collecting multiple solutions</li>
<li>Common in combinatorial problems</li>
</ul>
<h2 id="decision-making-guide">ğŸ¯ Decision Making Guide</h2>
<h3 id="use-two-pass-pattern-when">Use Two-Pass Pattern When:</h3>
<ol>
<li>Working with:<ul>
<li>Board games (Chess, N-Queens)</li>
<li>Maze problems</li>
<li>Grid-based problems</li>
<li>Graph coloring</li>
<li>State modification required</li>
</ul>
</li>
<li>Need to:<ul>
<li>Modify and restore shared state</li>
<li>Handle complex constraints</li>
<li>Work with matrix/grid structures</li>
<li>Deal with global state</li>
</ul>
</li>
</ol>
<h3 id="use-state-tracking-pattern-when">Use State Tracking Pattern When:</h3>
<ol>
<li>Working with:<ul>
<li>Combinations/Permutations</li>
<li>String building problems</li>
<li>Subset generation</li>
<li>Path finding without modification</li>
<li>Sequence generation</li>
</ul>
</li>
<li>Need to:<ul>
<li>Build multiple solutions</li>
<li>Generate all possible arrangements</li>
<li>Work with independent states</li>
<li>Create combinations or selections</li>
</ul>
</li>
</ol>
<h2 id="hybrid-approach-examples">ğŸ® Hybrid Approach Examples</h2>
<p>Sometimes you might need to combine both patterns:</p>
<pre><code class="language-python">def hybrid_backtracking():
    curr_path = []  # State Tracking
    board = [[0] * N for _ in range(N)]  # Two-Pass State

    def dfs(row, col):
        # State Tracking: Build path
        curr_path.append((row, col))

        # Two-Pass: Modify board
        board[row][col] = 'VISITED'

        # Recurse
        explore_neighbors(row, col)

        # Two-Pass: Restore board
        board[row][col] = 'EMPTY'

        # State Tracking: Remove from path
        curr_path.pop()
</code></pre>
<h3 id="when-to-use-hybrid">When to Use Hybrid:</h3>
<ol>
<li>Complex game scenarios</li>
<li>Path finding with state constraints</li>
<li>Problems requiring both solution building and state modification</li>
<li>Problems with both global and local constraints</li>
</ol>
<p>Remember:</p>
<ul>
<li>Consider state management needs</li>
<li>Think about solution collection requirements</li>
<li>Evaluate constraint checking needs</li>
<li>Consider readability and maintainability</li>
</ul>
<h2 id="common-problem-types">ğŸ® Common Problem Types</h2>
<h3 id="1-permutation-problems">1. Permutation Problems</h3>
<pre><code class="language-python">def permute(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(curr: List[int], used: Set[int]):
        # Base case: complete permutation
        if len(curr) == len(nums):
            result.append(curr[:])
            return

        # Try each unused number
        for i in range(len(nums)):
            # Skip used numbers
            if i in used:
                continue

            # Forward pass
            used.add(i)
            curr.append(nums[i])

            backtrack(curr, used)

            # Backward pass
            used.remove(i)
            curr.pop()

    result = []
    backtrack([], set())
    return result
</code></pre>
<h3 id="2-unique-permutations-with-duplicates">2. Unique Permutations (With Duplicates)</h3>
<pre><code class="language-python">def permuteUnique(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(curr: List[int], counter: Dict[int, int]):
        if len(curr) == len(nums):
            result.append(curr[:])
            return

        # Use counter to handle duplicates
        for num in counter:
            if counter[num] &gt; 0:
                curr.append(num)
                counter[num] -= 1

                backtrack(curr, counter)

                curr.pop()
                counter[num] += 1

    result = []
    counter = Counter(nums)
    backtrack([], counter)
    return result
</code></pre>
<h3 id="3-constraint-satisfaction-problems">3. Constraint Satisfaction Problems</h3>
<pre><code class="language-python">def solve_csp(constraints):
    def is_valid_state(state):
        return all(constraint(state) for constraint in constraints)

    def backtrack(state):
        if is_complete(state):
            return is_valid_state(state)

        for value in get_possible_values(state):
            if is_valid_partial(state, value):
                apply_value(state, value)

                if backtrack(state):
                    return True

                undo_value(state, value)

        return False
</code></pre>
<h2 id="time-complexity-analysis">ğŸ¯ Time Complexity Analysis</h2>
<pre><code class="language-python">complexity_notes = {
    &quot;Permutations&quot;: {
        &quot;Time&quot;: &quot;O(n!)&quot;,
        &quot;Space&quot;: &quot;O(n) for recursion stack&quot;,
        &quot;Note&quot;: &quot;Visits each state exactly once&quot;
    },
    &quot;Combinations&quot;: {
        &quot;Time&quot;: &quot;O(2^n)&quot;,
        &quot;Space&quot;: &quot;O(n) for recursion stack&quot;,
        &quot;Note&quot;: &quot;Each element has two choices&quot;
    },
    &quot;CSP Problems&quot;: {
        &quot;Time&quot;: &quot;O(d^n) where d is domain size&quot;,
        &quot;Space&quot;: &quot;O(n) for recursion stack&quot;,
        &quot;Note&quot;: &quot;Pruning can significantly improve average case&quot;
    }
}
</code></pre>
<h2 id="optimization-techniques">ğŸ’¡ Optimization Techniques</h2>
<h3 id="1-early-pruning">1. Early Pruning</h3>
<pre><code class="language-python">def optimized_backtrack(state):
    # Check constraints early
    if not is_valid_partial(state):
        return False

    if is_complete(state):
        return True

    for choice in sorted_choices(state):  # Sort choices for better pruning
        if is_promising(state, choice):
            apply_choice(state, choice)
            if optimized_backtrack(state):
                return True
            undo_choice(state, choice)
</code></pre>
<h3 id="2-state-duplication">2. State Duplication</h3>
<pre><code class="language-python">def backtrack_with_dedup(nums: List[int]) -&gt; List[List[int]]:
    def backtrack(start: int, curr: List[int]):
        result.append(curr[:])

        used = set()  # Track used numbers at this level
        for i in range(start, len(nums)):
            if nums[i] in used:  # Skip duplicates at same level
                continue
            used.add(nums[i])

            curr.append(nums[i])
            backtrack(i + 1, curr)
            curr.pop()
</code></pre>
<h2 id="interview-tips_3">ğŸ’¡ Interview Tips</h2>
<ol>
<li>Implementation Strategy:<ul>
<li>Always use DFS for backtracking</li>
<li>Identify state representation clearly</li>
<li>Track partial solutions carefully</li>
</ul>
</li>
<li>Optimization Strategy:<ul>
<li>Look for early pruning opportunities</li>
<li>Consider sorting input for better pruning</li>
<li>Use sets/counters for duplicate handling</li>
</ul>
</li>
<li>Problem Solving Steps:<ul>
<li>Identify what makes a valid solution</li>
<li>Determine how to build solutions incrementally</li>
<li>Define clear base cases</li>
<li>Plan state tracking strategy</li>
</ul>
</li>
<li>Testing Strategy:<ul>
<li>Start with small inputs</li>
<li>Test with duplicates if relevant</li>
<li>Verify all solutions are found</li>
<li>Check for invalid inputs</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Backtracking = Choices + Consequences</li>
<li>Think in terms of state and state changes</li>
<li>Always handle cleanup in backward pass</li>
<li>Consider space complexity of solution storage</li>
</ul>
<h1 id="binary-trees-guide">ğŸŒ³ Binary Trees Guide</h1>
<h2 id="core-implementation">ğŸ“š Core Implementation</h2>
<h3 id="basic-tree-node">Basic Tree Node</h3>
<pre><code class="language-python">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
</code></pre>
<h3 id="common-tree-building-patterns">Common Tree Building Patterns</h3>
<pre><code class="language-python">def build_tree_examples():
    # Simple Tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)

    # From List
    def from_list(nums: List[int], index: int = 0) -&gt; TreeNode:
        if index &gt;= len(nums) or nums[index] is None:
            return None
        root = TreeNode(nums[index])
        root.left = from_list(nums, 2 * index + 1)
        root.right = from_list(nums, 2 * index + 2)
        return root
</code></pre>
<h2 id="core-traversal-patterns">ğŸ¯ Core Traversal Patterns</h2>
<h3 id="1-dfs-patterns">1. DFS Patterns</h3>
<pre><code class="language-python">class DFSPatterns:
    def inorder(self, root: TreeNode) -&gt; List[int]:
        # Left -&gt; Root -&gt; Right
        def dfs(node):
            if not node:
                return
            dfs(node.left)        # Process left
            result.append(node.val)# Process root
            dfs(node.right)       # Process right

        result = []
        dfs(root)
        return result

    def preorder(self, root: TreeNode) -&gt; List[int]:
        # Root -&gt; Left -&gt; Right
        def dfs(node):
            if not node:
                return
            result.append(node.val)# Process root
            dfs(node.left)        # Process left
            dfs(node.right)       # Process right

        result = []
        dfs(root)
        return result

    def postorder(self, root: TreeNode) -&gt; List[int]:
        # Left -&gt; Right -&gt; Root
        def dfs(node):
            if not node:
                return
            dfs(node.left)        # Process left
            dfs(node.right)       # Process right
            result.append(node.val)# Process root

        result = []
        dfs(root)
        return result
</code></pre>
<h3 id="2-bfs-pattern">2. BFS Pattern</h3>
<pre><code class="language-python">from collections import deque

def level_order(root: TreeNode) -&gt; List[List[int]]:
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level_size = len(queue)
        current_level = []

        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        result.append(current_level)

    return result
</code></pre>
<h2 id="common-problem-patterns">ğŸ® Common Problem Patterns</h2>
<h3 id="1-path-problems-pattern">1. Path Problems Pattern</h3>
<pre><code class="language-python">def path_pattern(root: TreeNode):
    def dfs(node, path, target):
        if not node:
            return

        # Add current node to path
        path.append(node.val)

        # Check if leaf node
        if not node.left and not node.right:
            process_path(path)  # Process complete path

        # Recurse on children
        dfs(node.left, path, target)
        dfs(node.right, path, target)

        # Backtrack
        path.pop()
</code></pre>
<h3 id="2-binary-search-tree-pattern">2. Binary Search Tree Pattern</h3>
<pre><code class="language-python">def bst_pattern(root: TreeNode):
    def validate_bst(node, min_val=float('-inf'), max_val=float('inf')):
        if not node:
            return True

        # Check BST property
        if node.val &lt;= min_val or node.val &gt;= max_val:
            return False

        # Recurse with updated bounds
        return (validate_bst(node.left, min_val, node.val) and 
                validate_bst(node.right, node.val, max_val))
</code></pre>
<h3 id="3-lowest-common-ancestor">3. Lowest Common Ancestor</h3>
<pre><code class="language-python">def lca_pattern(root: TreeNode, p: TreeNode, q: TreeNode):
    def find_lca(node):
        if not node or node == p or node == q:
            return node

        # Search in left and right subtrees
        left = find_lca(node.left)
        right = find_lca(node.right)

        # If found in both subtrees, current node is LCA
        if left and right:
            return node

        # Return non-null node
        return left or right
</code></pre>
<h3 id="4-view-problems-pattern">4. View Problems Pattern</h3>
<pre><code class="language-python">def tree_view_pattern(root: TreeNode):
    def right_view(root):
        result = []

        def dfs(node, level):
            if not node:
                return

            # First node of this level from right
            if len(result) == level:
                result.append(node.val)

            # Visit right first for right view
            dfs(node.right, level + 1)
            dfs(node.left, level + 1)

        dfs(root, 0)
        return result
</code></pre>
<h2 id="pattern-recognition-guide">ğŸ¯ Pattern Recognition Guide</h2>
<h3 id="when-to-use-each-pattern">When to Use Each Pattern:</h3>
<ol>
<li><strong>Use DFS When:</strong><ul>
<li>Need to process nodes in a specific order</li>
<li>Working with paths from root to leaf</li>
<li>Validating tree properties</li>
<li>Computing tree properties recursively</li>
</ul>
</li>
<li><strong>Use BFS When:</strong><ul>
<li>Need level-by-level processing</li>
<li>Finding shortest paths</li>
<li>Working with tree width</li>
<li>Level-based operations</li>
</ul>
</li>
<li><strong>Use Path Patterns When:</strong><ul>
<li>Need complete paths from root to leaf</li>
<li>Summing paths</li>
<li>Finding specific paths</li>
<li>Path validation</li>
</ul>
</li>
<li><strong>Use BST Patterns When:</strong><ul>
<li>Searching for values</li>
<li>Validating BST properties</li>
<li>Range-based operations</li>
<li>Maintaining sorted order</li>
</ul>
</li>
</ol>
<h2 id="problem-solving-strategy">ğŸ’¡ Problem-Solving Strategy</h2>
<ol>
<li><strong>Identify Pattern Type:</strong><ul>
<li>Is it path-based?</li>
<li>Is it level-based?</li>
<li>Does it involve BST properties?</li>
<li>Is order important?</li>
</ul>
</li>
<li><strong>Choose Traversal Method:</strong></li>
</ol>
<pre><code class="language-python">patterns = {
    &quot;Need Path&quot;: &quot;DFS with path tracking&quot;,
    &quot;Level Operations&quot;: &quot;BFS with queue&quot;,
    &quot;Specific Order&quot;: &quot;Choose appropriate DFS order&quot;,
    &quot;BST Operations&quot;: &quot;Use BST properties&quot;
}
</code></pre>
<ol>
<li><strong>Consider Edge Cases</strong></li>
</ol>
<pre><code class="language-python">edge_cases = [
    &quot;Empty tree&quot;,
    &quot;Single node&quot;,
    &quot;All nodes same value&quot;,
    &quot;Unbalanced tree&quot;,
    &quot;Complete binary tree&quot;
]
</code></pre>
<ol>
<li><strong>Time/Space Complexity</strong></li>
</ol>
<pre><code class="language-python">complexities = {
    &quot;DFS&quot;: &quot;Time: O(n), Space: O(h)&quot;,
    &quot;BFS&quot;: &quot;Time: O(n), Space: O(w)&quot;,
    &quot;Path&quot;: &quot;Time: O(n), Space: O(h)&quot;,
    &quot;BST&quot;: &quot;Time: O(h), Space: O(1) typical&quot;
}
# where n = nodes, h = height, w = max width
</code></pre>
<p>Remember:</p>
<ul>
<li>Start with traversal pattern identification</li>
<li>Consider whether order matters</li>
<li>Check if BST properties help</li>
<li>Handle edge cases explicitly</li>
</ul>
<h1 id="tries-prefix-trees">ğŸŒ² Tries (Prefix Trees)</h1>
<h2 id="core-implementation_1">ğŸ“š Core Implementation</h2>
<h3 id="basic-trie-node">Basic Trie Node</h3>
<pre><code class="language-python">class TrieNode:
    def __init__(self):
        self.children = {}  # or [None] * 26 for fixed alphabet
        self.is_end = False  # Marks end of word
</code></pre>
<h3 id="basic-trie-structure">Basic Trie Structure</h3>
<pre><code class="language-python">class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -&gt; None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word: str) -&gt; bool:
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

    def starts_with(self, prefix: str) -&gt; bool:
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
</code></pre>
<h2 id="common-patterns">ğŸ¯ Common Patterns</h2>
<h3 id="1-word-dictionary-pattern">1. Word Dictionary Pattern</h3>
<pre><code class="language-python">class WordDictionary:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -&gt; None:
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search_with_wildcard(self, word: str) -&gt; bool:
        def dfs(node, i):
            if i == len(word):
                return node.is_end

            if word[i] == '.':
                for child in node.children.values():
                    if child and dfs(child, i + 1):
                        return True
                return False

            if word[i] not in node.children:
                return False

            return dfs(node.children[word[i]], i + 1)

        return dfs(self.root, 0)
</code></pre>
<h3 id="2-prefix-matching-pattern">2. Prefix Matching Pattern</h3>
<pre><code class="language-python">def prefix_matching_pattern():
    class AutocompleteSystem:
        def __init__(self, words: List[str], times: List[int]):
            self.root = TrieNode()
            self.prefix = &quot;&quot;

            # Insert words with frequencies
            for word, count in zip(words, times):
                self._insert(word, count)

        def _insert(self, word: str, count: int) -&gt; None:
            node = self.root
            for char in word:
                if char not in node.children:
                    node.children[char] = TrieNode()
                node = node.children[char]
                node.counts[word] = count

        def input(self, c: str) -&gt; List[str]:
            if c == '#':
                self._insert(self.prefix, 1)
                self.prefix = &quot;&quot;
                return []

            self.prefix += c
            node = self.root

            # Find node for current prefix
            for char in self.prefix:
                if char not in node.children:
                    return []
                node = node.children[char]

            # Get top 3 suggestions
            return sorted(node.counts.items(), 
                        key=lambda x: (-x[1], x[0]))[:3]
</code></pre>
<h3 id="3-word-square-pattern">3. Word Square Pattern</h3>
<pre><code class="language-python">def word_square_pattern(words: List[str]) -&gt; List[List[str]]:
    trie = Trie()
    n = len(words[0])

    # Build prefix map
    prefix_map = defaultdict(list)
    for i, word in enumerate(words):
        for j in range(len(word) + 1):
            prefix_map[word[:j]].append(i)

    def get_words_with_prefix(prefix):
        return [words[i] for i in prefix_map[prefix]]

    def backtrack(square):
        if len(square) == n:
            result.append(square[:])
            return

        # Get prefix for next word
        pos = len(square)
        prefix = ''.join(word[pos] for word in square)

        # Try all words with this prefix
        for word in get_words_with_prefix(prefix):
            square.append(word)
            backtrack(square)
            square.pop()

    result = []
    backtrack([])
    return result
</code></pre>
<h2 id="timespace-complexity">ğŸ¯ Time/Space Complexity</h2>
<pre><code class="language-python">complexities = {
    &quot;Insert&quot;: {
        &quot;Time&quot;: &quot;O(m) where m is word length&quot;,
        &quot;Space&quot;: &quot;O(m)&quot;
    },
    &quot;Search&quot;: {
        &quot;Time&quot;: &quot;O(m)&quot;,
        &quot;Space&quot;: &quot;O(1)&quot;
    },
    &quot;StartsWith&quot;: {
        &quot;Time&quot;: &quot;O(m)&quot;,
        &quot;Space&quot;: &quot;O(1)&quot;
    },
    &quot;Space Usage&quot;: &quot;O(ALPHABET_SIZE * m * n) for n words&quot;
}
</code></pre>
<h2 id="key-advantagesdisadvantages">ğŸ”‘ Key Advantages/Disadvantages</h2>
<h3 id="advantages">Advantages:</h3>
<pre><code class="language-python">advantages = [
    &quot;Fast prefix lookups O(m)&quot;,
    &quot;Space-efficient for common prefixes&quot;,
    &quot;No need for hash function&quot;,
    &quot;No collisions to handle&quot;,
    &quot;Natural for autocomplete/spellcheck&quot;
]
</code></pre>
<h3 id="disadvantages">Disadvantages</h3>
<pre><code class="language-python">disadvantages = [
    &quot;Memory intensive (many null pointers)&quot;,
    &quot;Slower than hash table for exact lookups&quot;,
    &quot;Complex to implement/maintain&quot;,
    &quot;Not cache-friendly due to pointer chasing&quot;
]
</code></pre>
<h2 id="when-to-use-tries">ğŸ’¡ When to Use Tries</h2>
<pre><code class="language-python">use_cases = {
    &quot;Autocomplete&quot;: &quot;Search suggestions&quot;,
    &quot;Spell Checker&quot;: &quot;Word validation&quot;,
    &quot;IP Routing&quot;: &quot;Prefix matching&quot;,
    &quot;Word Games&quot;: &quot;Word validation/search&quot;,
    &quot;Contact List&quot;: &quot;Type-ahead search&quot;
}
</code></pre>
<h2 id="common-pitfalls">âš ï¸ Common Pitfalls</h2>
<ol>
<li><strong>Memory Management</strong></li>
</ol>
<pre><code class="language-python">def avoid_memory_issues():
    &quot;&quot;&quot;
    - Consider using array instead of map for fixed alphabet
    - Clean up unused nodes
    - Use compressed tries for long strings
    &quot;&quot;&quot;
    pass
</code></pre>
<ol>
<li><strong>Implementation Choices</strong></li>
</ol>
<pre><code class="language-python">def implementation_tips():
    &quot;&quot;&quot;
    - Choose appropriate children structure
      (array vs map based on alphabet size)
    - Decide on case sensitivity handling
    - Plan wildcard character handling
    &quot;&quot;&quot;
    pass
</code></pre>
<h2 id="practice-problem-types">ğŸ¯ Practice Problem Types</h2>
<ol>
<li><strong>Basic Operations</strong><ul>
<li>Implement insert/search/startsWith</li>
<li>Handle wildcards</li>
<li>Case-sensitive operations</li>
</ul>
</li>
<li><strong>Word Problems</strong><ul>
<li>Word search</li>
<li>Word squares</li>
<li>Word break</li>
<li>Replace words</li>
</ul>
</li>
<li><strong>Prefix Problems</strong><ul>
<li>Autocomplete</li>
<li>Longest common prefix</li>
<li>Unique prefixes</li>
</ul>
</li>
</ol>
<p>Remember:</p>
<ul>
<li>Consider memory-space tradeoffs</li>
<li>Handle edge cases (empty strings, special chars)</li>
<li>Think about prefix sharing opportunities</li>
<li>Consider case sensitivity requirements</li>
</ul>
<h1 id="binary-search-guide">ğŸ” Binary Search Guide</h1>
<h2 id="core-template">ğŸ“š Core Template</h2>
<h3 id="most-generalized-binary-search-template">Most Generalized Binary Search Template</h3>
<pre><code class="language-python">def binary_search(array) -&gt; int:
    def condition(value) -&gt; bool:
        # Customize condition here
        pass

    left, right = min(search_space), max(search_space)
    while left &lt; right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid
        else:
            left = mid + 1
    return left

# Key Points:
# 1. Initialize boundaries to include ALL possible answers
# 2. Condition function defines search criteria
# 3. Returns minimum k where condition(k) is True
</code></pre>
<h2 id="three-key-components">ğŸ¯ Three Key Components</h2>
<h3 id="1-boundary-initialization">1. Boundary Initialization</h3>
<pre><code class="language-python">def initialize_boundaries():
    &quot;&quot;&quot;
    Rules for setting left and right:
    1. Must include all possible answers
    2. Common patterns:
       - [0, len(array)]         # For index search
       - [min(array), max(array)] # For value search
       - [1, max_possible]       # For minimum/maximum problems
    &quot;&quot;&quot;
    # Example bounds for different scenarios
    bounds = {
        &quot;Index Search&quot;: (0, len(array)),
        &quot;Value Search&quot;: (min(array), max(array)),
        &quot;Minimum Search&quot;: (1, max_value),
        &quot;Maximum Search&quot;: (min_value, sum(array))
    }
</code></pre>
<h3 id="2-condition-function-design">2. Condition Function Design</h3>
<pre><code class="language-python">def design_condition():
    &quot;&quot;&quot;
    Patterns for condition functions:
    1. Direct Comparison: array[mid] &gt;= target
    2. Feasibility Check: can_achieve(mid)
    3. Counting: count_less_equal(mid) &gt;= k
    4. Validation: is_valid_solution(mid)
    &quot;&quot;&quot;
    # Example condition patterns
    conditions = {
        &quot;Finding Target&quot;: lambda mid: array[mid] &gt;= target,
        &quot;Feasibility&quot;: lambda mid: can_do_task_with_value(mid),
        &quot;Counting&quot;: lambda mid: count_elements_less_than(mid) &gt;= k,
        &quot;Validation&quot;: lambda mid: validates_constraint(mid)
    }
</code></pre>
<h3 id="3-return-value-selection">3. Return Value Selection</h3>
<pre><code class="language-python">def choose_return():
    &quot;&quot;&quot;
    Return value patterns:
    1. left: Minimum value satisfying condition
    2. left - 1: Maximum value not satisfying condition
    3. right: Alternative minimum value
    4. Special handling for not found cases
    &quot;&quot;&quot;
    return_patterns = {
        &quot;Minimum Satisfying&quot;: &quot;return left&quot;,
        &quot;Maximum Not Satisfying&quot;: &quot;return left - 1&quot;,
        &quot;Not Found&quot;: &quot;return -1 if not found&quot;
    }
</code></pre>
<h2 id="common-problem-patterns_1">ğŸ® Common Problem Patterns</h2>
<h3 id="1-classical-binary-search">1. Classical Binary Search</h3>
<pre><code class="language-python">def classical_search(nums: List[int], target: int) -&gt; int:
    left, right = 0, len(nums)

    while left &lt; right:
        mid = left + (right - left) // 2
        if nums[mid] &gt;= target:
            right = mid
        else:
            left = mid + 1

    return left if left &lt; len(nums) and nums[left] == target else -1
</code></pre>
<h3 id="2-minimum-value-search">2. Minimum Value Search</h3>
<pre><code class="language-python">def find_minimum(nums: List[int]) -&gt; int:
    def feasible(value) -&gt; bool:
        # Define feasibility condition
        total = 0
        for num in nums:
            if condition(num, value):
                total += 1
        return total &gt;= required

    left, right = min_possible, max_possible
    while left &lt; right:
        mid = left + (right - left) // 2
        if feasible(mid):
            right = mid
        else:
            left = mid + 1
    return left
</code></pre>
<h3 id="3-maximum-value-search">3. Maximum Value Search</h3>
<pre><code class="language-python">def find_maximum(nums: List[int]) -&gt; int:
    def feasible(value) -&gt; bool:
        # Define feasibility condition
        return can_achieve_with_value(value)

    left, right = min_possible, max_possible
    while left &lt; right:
        mid = left + (right - left + 1) // 2  # Note: Different mid calculation
        if feasible(mid):
            left = mid
        else:
            right = mid - 1
    return left
</code></pre>
<h2 id="pattern-recognition-guide_1">ğŸ¯ Pattern Recognition Guide</h2>
<h3 id="when-to-use-binary-search">When to Use Binary Search:</h3>
<pre><code class="language-python">binary_search_indicators = {
    &quot;Sorted Array&quot;: &quot;Direct binary search possible&quot;,
    &quot;Monotonic Condition&quot;: &quot;Can use binary search on answer space&quot;,
    &quot;Min/Max Optimization&quot;: &quot;Likely binary search on result&quot;,
    &quot;Feasibility Check&quot;: &quot;Can binary search with validation&quot;,
    &quot;Counting Problems&quot;: &quot;Binary search possible if monotonic&quot;
}
</code></pre>
<h3 id="problem-type-recognition">Problem Type Recognition</h3>
<pre><code class="language-python">def identify_pattern(problem):
    patterns = {
        &quot;Find Exact Value&quot;: &quot;Classical binary search&quot;,
        &quot;Find Minimum Satisfying&quot;: &quot;Minimum value pattern&quot;,
        &quot;Find Maximum Possible&quot;: &quot;Maximum value pattern&quot;,
        &quot;Optimization with Constraint&quot;: &quot;Feasibility pattern&quot;,
        &quot;Counting with Condition&quot;: &quot;Counting pattern&quot;
    }
</code></pre>
<h2 id="common-pitfalls_1">âš ï¸ Common Pitfalls</h2>
<ol>
<li><strong>Boundary Issues</strong></li>
</ol>
<pre><code class="language-python">def avoid_boundary_issues():
    &quot;&quot;&quot;
    Common pitfalls:
    1. Off-by-one errors in boundaries
    2. Not including all possible answers
    3. Infinite loops due to improper mid calculation
    4. Not handling edge cases
    &quot;&quot;&quot;
    pass
</code></pre>
<ol>
<li><strong>Condition Design</strong></li>
</ol>
<pre><code class="language-python">def condition_pitfalls():
    &quot;&quot;&quot;
    Watch out for:
    1. Non-monotonic conditions
    2. Incorrect comparison operators
    3. Missing edge cases in condition
    4. Overcomplicated condition logic
    &quot;&quot;&quot;
    pass
</code></pre>
<h2 id="implementation-tips">ğŸ’¡ Implementation Tips</h2>
<ol>
<li>Always use  <code>left + (right - left) // 2</code>  to avoid overflow</li>
<li>Consider whether to include end points</li>
<li>Test with small examples first</li>
<li>Verify monotonicity of condition</li>
<li>Handle edge cases explicitly</li>
</ol>
<p>Remember:</p>
<ul>
<li>Think in terms of answer space vs index space</li>
<li>Verify condition function monotonicity</li>
<li>Consider boundary cases carefully</li>
<li>Test with small inputs first</li>
</ul>
<h1 id="greedy-algorithms">ğŸª™ Greedy Algorithms</h1>
<h2 id="core-properties_1">ğŸ“š Core Properties</h2>
<h3 id="what-is-a-greedy-algorithm">What is a Greedy Algorithm?</h3>
<p>A greedy algorithm makes the locally optimal choice at each step, hoping to find a global optimum. While simple and intuitive, they don't always yield the optimal solution but often provide efficient solutions for optimization problems.</p>
<h3 id="key-properties">Key Properties</h3>
<pre><code class="language-python">properties = {
    &quot;Local Optimal Choice&quot;: &quot;Best choice at current step&quot;,
    &quot;Hope&quot;: &quot;Local optimum leads to global optimum&quot;,
    &quot;No Backtracking&quot;: &quot;Decisions are final&quot;,
    &quot;Simple Implementation&quot;: &quot;Usually straightforward code&quot;
}
</code></pre>
<h2 id="when-to-use-greedy-algorithms">ğŸ¯ When to Use Greedy Algorithms</h2>
<h3 id="criteria-for-greedy-approach">Criteria for Greedy Approach</h3>
<pre><code class="language-python">def is_greedy_applicable(problem):
    criteria = {
        &quot;Greedy Choice Property&quot;: &quot;&quot;&quot;Local optimal choices 
            lead to global optimal solution&quot;&quot;&quot;,
        &quot;Optimal Substructure&quot;: &quot;&quot;&quot;Optimal solution contains 
            optimal solutions to subproblems&quot;&quot;&quot;,
        &quot;No Future Impact&quot;: &quot;Current choice doesn't affect future choices&quot;,
        &quot;Simple Constraints&quot;: &quot;Problem has straightforward constraints&quot;
    }
    return all(criteria.values())
</code></pre>
<h2 id="common-greedy-patterns">ğŸ® Common Greedy Patterns</h2>
<h3 id="1-activity-selection-pattern">1. Activity Selection Pattern</h3>
<pre><code class="language-python">def activity_selection(start: List[int], finish: List[int]) -&gt; List[int]:
    # Sort activities by finish time
    activities = sorted(zip(start, finish), key=lambda x: x[1])
    selected = [activities[0]]
    last_finish = activities[0][1]

    for start_time, finish_time in activities[1:]:
        if start_time &gt;= last_finish:
            selected.append((start_time, finish_time))
            last_finish = finish_time

    return selected
</code></pre>
<h3 id="2-fractional-knapsack-problem">2. Fractional Knapsack Problem</h3>
<pre><code class="language-python">def fractional_knapsack(values: List[int], weights: List[int], 
                       capacity: int) -&gt; float:
    # Calculate value/weight ratio
    items = sorted(zip(values, weights), 
                  key=lambda x: x[0]/x[1], reverse=True)
    total_value = 0

    for value, weight in items:
        if capacity &gt;= weight:
            # Take whole item
            capacity -= weight
            total_value += value
        else:
            # Take fraction of item
            total_value += value * (capacity / weight)
            break

    return total_value
</code></pre>
<h3 id="3-meeting-rooms-pattern">3. Meeting Rooms Pattern</h3>
<pre><code class="language-python">def min_meeting_rooms(intervals: List[List[int]]) -&gt; int:
    if not intervals:
        return 0

    # Separate start and end times
    starts = sorted([i[0] for i in intervals])
    ends = sorted([i[1] for i in intervals])

    rooms = 0
    max_rooms = 0
    s = e = 0

    while s &lt; len(intervals):
        if starts[s] &lt; ends[e]:
            rooms += 1
            s += 1
        else:
            rooms -= 1
            e += 1
        max_rooms = max(max_rooms, rooms)

    return max_rooms
</code></pre>
<h3 id="4-coin-change-greedy-pattern">4. Coin Change (Greedy Pattern)</h3>
<pre><code class="language-python">def coin_change_greedy(amount: int, coins: List[int]) -&gt; int:
    coins.sort(reverse=True)  # Sort coins in descending order
    count = 0

    for coin in coins:
        while amount &gt;= coin:
            amount -= coin
            count += 1

    return count if amount == 0 else -1
</code></pre>
<h2 id="universal-greedy-patterns">ğŸ”„ Universal Greedy Patterns</h2>
<h3 id="1-sorting-first-pattern">1. Sorting-First Pattern</h3>
<pre><code class="language-python">def sorting_first_pattern(items, key_function=None):
    &quot;&quot;&quot;
    Universal pattern for problems requiring initial sorting.
    Common in: Activity selection, Job scheduling, Meeting rooms
    &quot;&quot;&quot;
    # 1. Sort based on key metric
    sorted_items = sorted(items, key=key_function) if key_function else sorted(items)

    result = []
    current = sorted_items[0]  # Track current selection

    # 2. Process items in sorted order
    for item in sorted_items[1:]:
        if satisfies_constraint(current, item):
            # 3. Make greedy choice
            result.append(current)
            current = item

    result.append(current)  # Don't forget last item
    return result

# Example Usage: Activity Selection
def activity_selection(activities):
    return sorting_first_pattern(
        activities,
        key_function=lambda x: x[1]  # Sort by finish time
    )

# Example Usage: Meeting Rooms
def meeting_rooms(meetings):
    return sorting_first_pattern(
        meetings,
        key_function=lambda x: x[0]  # Sort by start time
    )
</code></pre>
<h3 id="2-fraction-ratepattern">2. Fraction Rate/Pattern</h3>
<pre><code class="language-python">def fraction_pattern(items, constraint, get_value, get_weight):
    &quot;&quot;&quot;
    Universal pattern for fractional optimization problems.
    Common in: Knapsack, Task scheduling with efficiency
    &quot;&quot;&quot;
    # 1. Calculate rates and sort
    rates = [(get_value(item)/get_weight(item), item) 
             for item in items]
    rates.sort(reverse=True)

    result = []
    total_value = 0
    remaining = constraint

    # 2. Process items by rate
    for rate, item in rates:
        weight = get_weight(item)
        if remaining &gt;= weight:
            # Take whole item
            result.append((item, 1.0))
            total_value += get_value(item)
            remaining -= weight
        else:
            # Take fraction
            fraction = remaining / weight
            result.append((item, fraction))
            total_value += get_value(item) * fraction
            break

    return result, total_value

# Example Usage: Fractional Knapsack
def fractional_knapsack(items, capacity):
    return fraction_pattern(
        items,
        capacity,
        get_value=lambda x: x.value,
        get_weight=lambda x: x.weight
    )
</code></pre>
<h3 id="3-running-window-pattern">3. Running Window Pattern</h3>
<pre><code class="language-python">def running_window_pattern(items, constraint):
    &quot;&quot;&quot;
    Universal pattern for running window problems.
    Common in: Meeting rooms, Task scheduling, Resource allocation
    &quot;&quot;&quot;
    # 1. Separate start and end events
    events = []
    for start, end in items:
        events.append((start, 1))   # 1 for start
        events.append((end, -1))    # -1 for end

    # 2. Sort events
    events.sort()

    current = 0
    max_needed = 0

    # 3. Process events in order
    for time, change in events:
        current += change
        max_needed = max(max_needed, current)

        if max_needed &gt; constraint:
            return False

    return True

# Example Usage: Meeting Rooms
def can_schedule_meetings(meetings, available_rooms):
    return running_window_pattern(meetings, available_rooms)
</code></pre>
<h3 id="4-local-exchange-pattern">4. Local Exchange Pattern</h3>
<pre><code class="language-python">def local_exchange_pattern(items):
    &quot;&quot;&quot;
    Universal pattern for local optimization problems.
    Common in: Job scheduling, Task optimization
    &quot;&quot;&quot;
    result = list(items)  # Create mutable copy
    made_change = True

    while made_change:
        made_change = False
        for i in range(len(result) - 1):
            # Compare adjacent items
            if better_exchange(result[i], result[i + 1]):
                result[i], result[i + 1] = result[i + 1], result[i]
                made_change = True

    return result

# Example Usage: Job Sequencing
def job_sequencing(jobs):
    def better_exchange(job1, job2):
        return (job1.profit/job1.deadline &lt; 
                job2.profit/job2.deadline)

    return local_exchange_pattern(jobs)
</code></pre>
<h3 id="5-priority-queue-pattern">5. Priority Queue Pattern</h3>
<pre><code class="language-python">from heapq import heappush, heappop

def priority_queue_pattern(items, k):
    &quot;&quot;&quot;
    Universal pattern for k-selection problems.
    Common in: K closest points, Top K frequent elements
    &quot;&quot;&quot;
    heap = []

    for item in items:
        # Maintain heap of size k
        if len(heap) &lt; k:
            heappush(heap, item)
        else:
            if better_than_top(item, heap[0]):
                heappop(heap)
                heappush(heap, item)

    return sorted(heap)  # Return sorted result

# Example Usage: K Closest Points
def k_closest_points(points, k):
    return priority_queue_pattern(
        points,
        k=k
    )
</code></pre>
<h3 id="pattern-selection-guide">Pattern Selection Guide</h3>
<pre><code class="language-python">pattern_guide = {
    &quot;Sorting-First&quot;: {
        &quot;Use When&quot;: [
            &quot;Items need to be processed in specific order&quot;,
            &quot;Selection based on sorted property&quot;,
            &quot;No overlapping allowed&quot;
        ],
        &quot;Examples&quot;: [
            &quot;Activity selection&quot;,
            &quot;Meeting rooms&quot;,
            &quot;Task scheduling&quot;
        ]
    },
    &quot;Fraction/Rate&quot;: {
        &quot;Use When&quot;: [
            &quot;Divisible items&quot;,
            &quot;Optimization based on rates&quot;,
            &quot;Knapsack-like problems&quot;
        ],
        &quot;Examples&quot;: [
            &quot;Fractional knapsack&quot;,
            &quot;Resource allocation&quot;,
            &quot;Time management&quot;
        ]
    },
    &quot;Running Window&quot;: {
        &quot;Use When&quot;: [
            &quot;Time/Space intervals&quot;,
            &quot;Resource constraints&quot;,
            &quot;Overlapping intervals&quot;
        ],
        &quot;Examples&quot;: [
            &quot;Meeting rooms&quot;,
            &quot;CPU scheduling&quot;,
            &quot;Resource booking&quot;
        ]
    },
    &quot;Local Exchange&quot;: {
        &quot;Use When&quot;: [
            &quot;Local optimization possible&quot;,
            &quot;Pairwise comparisons sufficient&quot;,
            &quot;Order matters&quot;
        ],
        &quot;Examples&quot;: [
            &quot;Job sequencing&quot;,
            &quot;Task ordering&quot;,
            &quot;Optimization problems&quot;
        ]
    },
    &quot;Priority Queue&quot;: {
        &quot;Use When&quot;: [
            &quot;K-selection problems&quot;,
            &quot;Running minimum/maximum&quot;,
            &quot;Stream processing&quot;
        ],
        &quot;Examples&quot;: [
            &quot;K closest points&quot;,
            &quot;Top K elements&quot;,
            &quot;Running median&quot;
        ]
    }
}
</code></pre>
<h2 id="problem-solving-framework">ğŸ¯ Problem-Solving Framework</h2>
<h3 id="1-verify-greedy-approach">1. Verify Greedy Approach</h3>
<pre><code class="language-python">def verify_greedy_approach():
    checks = {
        &quot;Local Choice&quot;: &quot;Can we make locally optimal choice?&quot;,
        &quot;Subproblem&quot;: &quot;Does it lead to simpler subproblem?&quot;,
        &quot;Optimality&quot;: &quot;Do local choices lead to global optimum?&quot;,
        &quot;Constraints&quot;: &quot;Are constraints simple and local?&quot;
    }
</code></pre>
<h3 id="2-design-steps">2. Design Steps</h3>
<ol>
<li><strong>Sort if Needed</strong><ul>
<li>Often first step is sorting by key metric</li>
<li>Examples: finish time, value/weight ratio</li>
</ul>
</li>
<li><strong>Define Greedy Choice</strong><ul>
<li>What makes a choice locally optimal?</li>
<li>How to select next element?</li>
</ul>
</li>
<li><strong>Implement Selection Process</strong><ul>
<li>Process elements in sorted order</li>
<li>Apply greedy choice at each step</li>
</ul>
</li>
<li><strong>Track Progress/Result</strong><ul>
<li>Maintain running solution</li>
<li>Update constraints</li>
</ul>
</li>
</ol>
<h2 id="common-pitfalls_2">âš ï¸ Common Pitfalls</h2>
<h3 id="1-verification-issues">1. Verification Issues</h3>
<pre><code class="language-python">pitfalls = {
    &quot;Optimality&quot;: &quot;Not verifying if greedy leads to optimal&quot;,
    &quot;Constraints&quot;: &quot;Missing important constraints&quot;,
    &quot;Sorting&quot;: &quot;Wrong sorting criteria&quot;,
    &quot;Edge Cases&quot;: &quot;Not handling edge cases&quot;
}
</code></pre>
<h3 id="2-implementation-issues">2. Implementation Issues</h3>
<pre><code class="language-python">implementation_issues = {
    &quot;Initialization&quot;: &quot;Incorrect initial values&quot;,
    &quot;Updates&quot;: &quot;Wrong progress tracking&quot;,
    &quot;Termination&quot;: &quot;Incorrect stopping condition&quot;,
    &quot;Optimization&quot;: &quot;Missing optimization opportunities&quot;
}
</code></pre>
<h2 id="common-interview-problems_1">ğŸ“ Common Interview Problems</h2>
<h3 id="1-scheduling-problems">1. Scheduling Problems</h3>
<ul>
<li>Activity Selection</li>
<li>Meeting Rooms</li>
<li>Task Scheduling</li>
</ul>
<h3 id="2-optimization-problems">2. Optimization Problems</h3>
<ul>
<li>Fractional Knapsack</li>
<li>Minimum Coins</li>
<li>Huffman Coding</li>
</ul>
<h3 id="3-connection-problems">3. Connection Problems</h3>
<ul>
<li>Minimum Spanning Tree</li>
<li>Job Sequencing</li>
<li>Shortest Path (Dijkstra's)</li>
</ul>
<h2 id="interview-tips_4">ğŸ’¡ Interview Tips</h2>
<ol>
<li><strong>Approach</strong><ul>
<li>Start with greedy hypothesis</li>
<li>Prove/disprove with examples</li>
<li>Consider sorting first</li>
<li>Track progress clearly</li>
</ul>
</li>
<li><strong>Verification</strong><ul>
<li>Use small examples</li>
<li>Find counter-examples</li>
<li>Explain why greedy works</li>
</ul>
</li>
<li><strong>Implementation</strong><ul>
<li>Keep code clean and simple</li>
<li>Handle edge cases</li>
<li>Consider optimization</li>
<li>Test with various inputs</li>
</ul>
</li>
</ol>
<h2 id="time-complexity-analysis_1">ğŸ¯ Time Complexity Analysis</h2>
<pre><code class="language-python">complexities = {
    &quot;Sorting Based&quot;: &quot;O(n log n) typical&quot;,
    &quot;Linear Scan&quot;: &quot;O(n) without sorting&quot;,
    &quot;Priority Queue&quot;: &quot;O(n log k) for k elements&quot;,
    &quot;Space&quot;: &quot;Usually O(1) or O(n)&quot;
}
</code></pre>
<p>Remember:</p>
<ul>
<li>Greedy algorithms are simple but not always optimal</li>
<li>Verify greedy choice property</li>
<li>Consider sorting as first step</li>
<li>Handle edge cases carefully</li>
</ul>
<h1 id="dynamic-programming-from-fundamentals-to-mastery">ğŸ¯ Dynamic Programming - From Fundamentals to Mastery</h1>
<h2 id="introduction-to-dynamic-programming">ğŸ“š Introduction to Dynamic Programming</h2>
<h3 id="what-is-dynamic-programming">What is Dynamic Programming?</h3>
<p>Dynamic Programming (DP) is both a mathematical optimization method and a programming method that:</p>
<ol>
<li>Breaks down complex problems into simpler subproblems</li>
<li>Stores solutions to these subproblems to avoid recalculating them</li>
<li>Uses stored solutions to build up to the final solution</li>
</ol>
<p>Think of it as "careful brute force" - instead of recalculating values we've seen before, we save them for later use.</p>
<h3 id="when-to-use-dynamic-programming">When to Use Dynamic Programming</h3>
<pre><code class="language-python">criteria_for_dp = {
    &quot;1. Optimal Substructure&quot;: &quot;&quot;&quot;
        Can the problem be broken down into smaller problems?
        Example: Fibonacci numbers - F(n) depends on F(n-1) and F(n-2)
        &quot;&quot;&quot;,
    &quot;2. Overlapping Subproblems&quot;: &quot;&quot;&quot;
        Do we calculate the same things repeatedly?
        Example: In Fibonacci, F(5) and F(4) both need F(3)
        &quot;&quot;&quot;,
    &quot;3. No Greedy Choice&quot;: &quot;&quot;&quot;
        Does making the locally optimal choice not always lead to global optimal?
        Example: Coin change problem with coins [1, 15, 25]
        &quot;&quot;&quot;
}
</code></pre>
<h2 id="core-concepts-explained">ğŸ¯ Core Concepts Explained</h2>
<h3 id="1-subproblems-and-optimal-substructure">1. Subproblems and Optimal Substructure</h3>
<pre><code class="language-python">def understand_subproblems():
    &quot;&quot;&quot;
    Example: Finding F(4) in Fibonacci sequence

    F(4) = F(3) + F(2)     # Main problem
    F(3) = F(2) + F(1)     # Subproblem
    F(2) = F(1) + F(0)     # Smaller subproblem

    Properties:
    1. Each subproblem is smaller version of main problem
    2. Solution to main problem depends on subproblems
    3. Base cases stop the recursion
    &quot;&quot;&quot;
    pass
</code></pre>
<h3 id="2-overlapping-subproblems">2. Overlapping Subproblems</h3>
<pre><code class="language-python">def show_overlapping_example(n: int):
    &quot;&quot;&quot;
    Without DP (lots of repeated calculations):
    F(5)
    â”œâ”€â”€ F(4)
    â”‚   â”œâ”€â”€ F(3)
    â”‚   â”‚   â”œâ”€â”€ F(2)  # Calculated multiple times
    â”‚   â”‚   â””â”€â”€ F(1)
    â”‚   â””â”€â”€ F(2)      # Calculated again
    â””â”€â”€ F(3)
        â”œâ”€â”€ F(2)      # Calculated yet again
        â””â”€â”€ F(1)

    With DP (calculate once, reuse result):
    memo = {
        0: 0,
        1: 1,
        2: F(2),  # Calculate once, reuse many times
        3: F(3),
        ...
    }
    &quot;&quot;&quot;
    pass
</code></pre>
<h2 id="two-main-approaches-to-dp">ğŸ® Two Main Approaches to DP</h2>
<h3 id="1-top-down-memoization">1. Top-Down (Memoization)</h3>
<pre><code class="language-python">def explain_memoization():
    &quot;&quot;&quot;
    Top-Down Process:
    1. Start with original problem (top)
    2. Break into subproblems recursively
    3. Store results in memo table
    4. Return memoized results if subproblem seen before

    Advantages:
    - More intuitive (follows natural thinking)
    - Only solves needed subproblems
    - Easier to debug

    Disadvantages:
    - Recursion overhead
    - Stack space usage
    &quot;&quot;&quot;
    # Example implementation
    def fib_memo(n: int, memo: dict = None) -&gt; int:
        if memo is None:
            memo = {}

        # Base cases
        if n &lt;= 1:
            return n

        # Check memo before computing
        if n in memo:
            return memo[n]

        # Store result in memo
        memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
        return memo[n]
</code></pre>
<h3 id="2-bottom-up-tabulation">2. Bottom-Up (Tabulation)</h3>
<pre><code class="language-python">def explain_tabulation():
    &quot;&quot;&quot;
    Bottom-Up Process:
    1. Start with base cases (bottom)
    2. Build larger solutions from smaller ones
    3. Store results in table
    4. Use table to build final solution

    Advantages:
    - More space efficient
    - No recursion overhead
    - Better cache performance

    Disadvantages:
    - May solve unnecessary subproblems
    - Sometimes less intuitive
    &quot;&quot;&quot;
    # Example implementation
    def fib_table(n: int) -&gt; int:
        if n &lt;= 1:
            return n

        # Initialize table with base cases
        dp = [0] * (n + 1)
        dp[1] = 1

        # Build up the solution
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

        return dp[n]
</code></pre>
<h2 id="problem-solving-framework_1">ğŸ¯ Problem-Solving Framework</h2>
<h3 id="step-1-identify-dp-characteristics">Step 1: Identify DP Characteristics</h3>
<pre><code class="language-python">def identify_dp_potential(problem):
    &quot;&quot;&quot;
    Ask these questions:
    1. Can I break this into smaller similar subproblems?
    2. Does solving subproblems help solve the original problem?
    3. Am I calculating same things repeatedly?
    4. Can I store and reuse these calculations?
    &quot;&quot;&quot;
    checklist = {
        &quot;Optimal Substructure&quot;: False,
        &quot;Overlapping Subproblems&quot;: False,
        &quot;Need for Optimization&quot;: False
    }
    return all(checklist.values())
</code></pre>
<h3 id="step-2-define-the-subproblem">Step 2: Define the Subproblem</h3>
<pre><code class="language-python">def define_subproblem():
    &quot;&quot;&quot;
    1. State Definition:
    - What variables define a subproblem?
    - What information needed to solve it?

    2. State Transition:
    - How do I move from one state to another?
    - What choices do I have at each state?

    Example (Knapsack):
    - State: dp[i][w] = max value using items[0..i] with weight limit w
    - Transition: Choose whether to include item i or not
    &quot;&quot;&quot;
    pass
</code></pre>
<h3 id="step-3-write-the-recurrence-relation">Step 3: Write the Recurrence Relation</h3>
<pre><code class="language-python">def create_recurrence():
    &quot;&quot;&quot;
    1. Base Cases:
    - Smallest possible subproblem
    - Starting point for computation

    2. Recurrence Formula:
    - How larger problems relate to smaller ones
    - Mathematical relationship between states

    Example (Knapsack):
    dp[i][w] = max(
        dp[i-1][w],                    # Don't take item
        dp[i-1][w-weight[i]] + val[i]  # Take item
    )
    &quot;&quot;&quot;
    pass
</code></pre>
<h3 id="step-4-implement-solution">Step 4: Implement Solution</h3>
<pre><code class="language-python">def implement_solution():
    &quot;&quot;&quot;
    Choose Implementation Style:
    1. Top-Down if:
    - Natural recursive solution
    - Not all subproblems needed
    - Need to debug/understand easily

    2. Bottom-Up if:
    - Need to optimize space
    - All subproblems needed
    - Want to avoid recursion
    &quot;&quot;&quot;
    pass
</code></pre>
<h2 id="common-dp-patterns">ğŸ¯ Common DP Patterns</h2>
<h3 id="1-linear-sequence">1. Linear Sequence</h3>
<p>Used when each state depends on previous states.</p>
<pre><code class="language-python">def linear_dp_example():
    # Example: House Robber Problem
    def rob(nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])

        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2] + nums[i])

        return dp[-1]
</code></pre>
<h3 id="2-matrix-chain">2. Matrix Chain</h3>
<p>Used for optimization problems involving sequences.</p>
<pre><code class="language-python">def matrix_chain_example():
    # Example: Matrix Chain Multiplication
    def matrix_mult_cost(dimensions: List[int]) -&gt; int:
        n = len(dimensions) - 1
        dp = [[0] * n for _ in range(n)]

        for length in range(2, n + 1):
            for i in range(n - length + 1):
                j = i + length - 1
                dp[i][j] = float('inf')
                for k in range(i, j):
                    cost = (dp[i][k] + dp[k+1][j] + 
                           dimensions[i] * dimensions[k+1] * dimensions[j+1])
                    dp[i][j] = min(dp[i][j], cost)

        return dp[0][n-1]
</code></pre>
<h3 id="3-interval-problems">3. Interval Problems</h3>
<p>Used when dealing with ranges or intervals.</p>
<pre><code class="language-python">def interval_dp_example():
    # Example: Palindrome Partitioning
    def min_cuts(s: str) -&gt; int:
        n = len(s)
        # is_palindrome[i][j] tells if s[i:j+1] is palindrome
        is_palindrome = [[False] * n for _ in range(n)]

        # Single letters are palindromes
        for i in range(n):
            is_palindrome[i][i] = True

        # Check for palindromes of length 2 and more
        for length in range(2, n + 1):
            for start in range(n - length + 1):
                end = start + length - 1
                if length == 2:
                    is_palindrome[start][end] = (s[start] == s[end])
                else:
                    is_palindrome[start][end] = (
                        s[start] == s[end] and 
                        is_palindrome[start+1][end-1]
                    )

        # dp[i] = minimum cuts needed for s[0:i+1]
        dp = [0] * n
        for i in range(n):
            if is_palindrome[0][i]:
                dp[i] = 0
            else:
                dp[i] = i
                for j in range(i):
                    if is_palindrome[j+1][i]:
                        dp[i] = min(dp[i], dp[j] + 1)

        return dp[n-1]
</code></pre>
<h2 id="advanced-optimization-techniques">ğŸ’¡ Advanced Optimization Techniques</h2>
<h3 id="1-space-optimization">1. Space Optimization</h3>
<pre><code class="language-python">def space_optimization_example():
    &quot;&quot;&quot;
    Common Techniques:
    1. Rolling Array
    - Keep only last k states
    - Use mod operator for indexing

    2. State Compression
    - Use bits to represent states
    - Reduce dimension of dp table

    Example: Fibonacci with O(1) space
    &quot;&quot;&quot;
    def fib_optimized(n: int) -&gt; int:
        if n &lt;= 1:
            return n
        a, b = 0, 1
        for _ in range(2, n + 1):
            a, b = b, a + b
        return b
</code></pre>
<h3 id="2-state-reduction">2. State Reduction</h3>
<pre><code class="language-python">def state_reduction_example():
    &quot;&quot;&quot;
    Techniques:
    1. Eliminate Redundant States
    - Identify states that can be derived
    - Combine overlapping states

    2. Change State Representation
    - More efficient encoding
    - Different perspective on problem

    Example: Reducing 2D DP to 1D
    &quot;&quot;&quot;
    # Original 2D Knapsack
    def knapsack_2d(weights: List[int], values: List[int], capacity: int) -&gt; int:
        n = len(weights)
        dp = [[0] * (capacity + 1) for _ in range(n + 1)]

        for i in range(1, n + 1):
            for w in range(capacity + 1):
                if weights[i-1] &lt;= w:
                    dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], 
                                 dp[i-1][w])
                else:
                    dp[i][w] = dp[i-1][w]
        return dp[n][capacity]

    # Optimized 1D Knapsack
    def knapsack_1d(weights: List[int], values: List[int], capacity: int) -&gt; int:
        dp = [0] * (capacity + 1)

        for i in range(len(weights)):
            for w in range(capacity, weights[i]-1, -1):
                dp[w] = max(dp[w], dp[w-weights[i]] + values[i])
        return dp[capacity]
</code></pre>
<p>Remember:</p>
<ul>
<li>Always start with a clear understanding of subproblems</li>
<li>Draw out the recurrence relation</li>
<li>Consider both top-down and bottom-up approaches</li>
<li>Look for optimization opportunities</li>
<li>Test with small cases first</li>
</ul>
<h3 id="reference">Reference</h3>
<p><a href="https://youtu.be/aPQY__2H3tE?si=kF10ZwFUbYQa1s0B">Dynamic Programming</a></p>
<h1 id="graphs-graph-theory">ğŸ“Š Graphs &amp; Graph Theory</h1>
<h2 id="core-concepts_2">ğŸ“š Core Concepts</h2>
<h3 id="what-is-a-graph">What is a Graph?</h3>
<p>A graph is a data structure consisting of:</p>
<ul>
<li><strong>Vertices (Nodes)</strong>: Points in the graph</li>
<li><strong>Edges</strong>: Connections between vertices</li>
<li><strong>Optional Properties</strong>: Weights, directions, labels</li>
</ul>
<p>Types of Graphs:</p>
<pre><code class="language-python">graph_types = {
    &quot;Undirected&quot;: &quot;Edges have no direction (Facebook friendships)&quot;,
    &quot;Directed&quot;: &quot;Edges have direction (Twitter follows)&quot;,
    &quot;Weighted&quot;: &quot;Edges have weights (Road distances)&quot;,
    &quot;Connected&quot;: &quot;Path exists between any two vertices&quot;,
    &quot;Cyclic&quot;: &quot;Contains at least one cycle&quot;,
    &quot;Acyclic&quot;: &quot;Contains no cycles (trees are acyclic)&quot;
}
</code></pre>
<h2 id="graph-representations">ğŸ¯ Graph Representations</h2>
<h3 id="1-adjacency-list-most-common-in-interviews">1. Adjacency List (Most Common in Interviews)</h3>
<pre><code class="language-python">class Graph:
    def __init__(self):
        self.graph = {}

    def add_vertex(self, vertex):
        if vertex not in self.graph:
            self.graph[vertex] = set()

    def add_edge(self, v1, v2):
        if v1 not in self.graph:
            self.add_vertex(v1)
        if v2 not in self.graph:
            self.add_vertex(v2)
        self.graph[v1].add(v2)
        self.graph[v2].add(v1)  # Remove for directed graph
</code></pre>
<h3 id="2-adjacency-matrix">2. Adjacency Matrix</h3>
<pre><code class="language-python">class GraphMatrix:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0] * vertices for _ in range(vertices)]

    def add_edge(self, v1, v2, weight=1):
        self.graph[v1][v2] = weight
        self.graph[v2][v1] = weight  # Remove for directed graph
</code></pre>
<h2 id="essential-graph-operations">ğŸ® Essential Graph Operations</h2>
<h3 id="1-graph-traversal">1. Graph Traversal</h3>
<h3 id="bfs-breadth-first-search">BFS (Breadth-First Search)</h3>
<pre><code class="language-python">from collections import deque

def bfs(graph, start):
    &quot;&quot;&quot;
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Finding shortest paths
    - Level-by-level traversal
    - Finding nodes at distance k
    &quot;&quot;&quot;
    visited = set([start])
    queue = deque([start])

    while queue:
        vertex = queue.popleft()

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return visited
</code></pre>
<h3 id="dfs-depth-first-search">DFS (Depth-First Search)</h3>
<pre><code class="language-python">def dfs(graph, start, visited=None):
    &quot;&quot;&quot;
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Finding paths/cycles
    - Exhaustively exploring paths
    - Topological sorting
    &quot;&quot;&quot;
    if visited is None:
        visited = set()

    visited.add(start)

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

# Iterative DFS (often preferred in interviews)
def dfs_iterative(graph, start):
    visited = set()
    stack = [start]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(neighbor for neighbor in graph[node] 
                        if neighbor not in visited)
    return visited
</code></pre>
<h3 id="2-path-finding">2. Path Finding</h3>
<h3 id="find-path-between-two-vertices">Find Path Between Two Vertices</h3>
<pre><code class="language-python">def find_path(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]

    if start == end:
        return path

    for neighbor in graph[start]:
        if neighbor not in path:
            new_path = find_path(graph, neighbor, end, path)
            if new_path:
                return new_path
    return None
</code></pre>
<h3 id="find-all-paths">Find All Paths</h3>
<pre><code class="language-python">def find_all_paths(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]

    if start == end:
        return [path]

    paths = []
    for neighbor in graph[start]:
        if neighbor not in path:
            new_paths = find_all_paths(graph, neighbor, end, path)
            paths.extend(new_paths)
    return paths
</code></pre>
<h2 id="common-graph-algorithms-for-interviews">ğŸ¯ Common Graph Algorithms for Interviews</h2>
<h3 id="1-detect-cycle">1. Detect Cycle</h3>
<pre><code class="language-python">def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def dfs_cycle(vertex):
        visited.add(vertex)
        rec_stack.add(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                if dfs_cycle(neighbor):
                    return True
            elif neighbor in rec_stack:
                return True

        rec_stack.remove(vertex)
        return False

    for vertex in graph:
        if vertex not in visited:
            if dfs_cycle(vertex):
                return True
    return False
</code></pre>
<h3 id="2-topological-sort">2. Topological Sort</h3>
<pre><code class="language-python">def topological_sort(graph):
    &quot;&quot;&quot;
    For directed acyclic graphs (DAGs)
    Time: O(V + E)
    Space: O(V)
    Use when:
    - Scheduling with dependencies
    - Build systems
    - Course prerequisites
    &quot;&quot;&quot;
    def dfs(node):
        if node in visited:
            return
        visited.add(node)

        for neighbor in graph[node]:
            dfs(neighbor)
        result.append(node)

    visited = set()
    result = []

    for node in graph:
        dfs(node)

    return result[::-1]  # Reverse for correct order

# Alternative: Kahn's Algorithm (BFS-based)
def topological_sort_kahn(graph):
    in_degree = {node: 0 for node in graph}
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] += 1

    queue = deque([node for node, degree in in_degree.items() if degree == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)

        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return result if len(result) == len(graph) else []  # Check for cycles
</code></pre>
<h3 id="3-connected-components">3. Connected Components</h3>
<pre><code class="language-python">def find_connected_components(graph):
    def dfs_component(vertex, component):
        visited.add(vertex)
        component.append(vertex)

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                dfs_component(neighbor, component)

    visited = set()
    components = []

    for vertex in graph:
        if vertex not in visited:
            current_component = []
            dfs_component(vertex, current_component)
            components.append(current_component)

    return components
</code></pre>
<h3 id="4-shortest-path-algorithms">4. Shortest Path Algorithms</h3>
<h4 id="dijkstras-algorithm">Dijkstra's Algorithm</h4>
<pre><code class="language-python">import heapq

def dijkstra(graph, start):
    &quot;&quot;&quot;
    For weighted graphs with non-negative edges
    Time: O((V + E) log V)
    Space: O(V)
    Use when:
    - Finding shortest paths
    - Network routing
    - GPS navigation
    &quot;&quot;&quot;
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    pq = [(0, start)]

    while pq:
        current_distance, current = heapq.heappop(pq)

        if current_distance &gt; distances[current]:
            continue

        for neighbor, weight in graph[current].items():
            distance = current_distance + weight

            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))

    return distances
</code></pre>
<h3 id="5-union-find-disjoint-set">5. Union Find (Disjoint Set)</h3>
<pre><code class="language-python">class UnionFind:
    &quot;&quot;&quot;
    Time: O(Î±(n)) per operation (practically O(1))
    Space: O(n)
    Use when:
    - Finding connected components
    - Cycle detection
    - Minimum spanning trees
    &quot;&quot;&quot;
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False

        # Union by rank
        if self.rank[px] &lt; self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] &gt; self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        return True
</code></pre>
<h2 id="interview-problem-patterns">ğŸ“ Interview Problem Patterns</h2>
<h3 id="1-graph-traversal-problems">1. Graph Traversal Problems</h3>
<ul>
<li>Visiting all nodes/edges</li>
<li>Finding connected components</li>
<li>Level-order traversal</li>
</ul>
<pre><code class="language-python">traversal_tips = {
    &quot;BFS&quot;: &quot;Use when:- Finding shortest path- Level by level traversal- Minimum steps&quot;,
    &quot;DFS&quot;: &quot;Use when:- Exploring paths- Finding cycles- Topological sorting&quot;,
    &quot;Edge Cases&quot;: &quot;- Empty graph- Single node- Disconnected components&quot;
}
</code></pre>
<h3 id="2-path-finding-problems">2. Path Finding Problems</h3>
<ul>
<li>Shortest path</li>
<li>All possible paths</li>
<li>Path with constraints</li>
</ul>
<pre><code class="language-python">def shortest_path(graph, start, end):
    queue = deque([(start, [start])])
    visited = {start}

    while queue:
        vertex, path = queue.popleft()
        if vertex == end:
            return path

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    return None
</code></pre>
<h2 id="interview-tips_5">ğŸ’¡ Interview Tips</h2>
<ol>
<li><strong>Representation Choice</strong></li>
</ol>
<pre><code class="language-python">choosing_representation = {
    &quot;Adjacency List&quot;: &quot;- Sparse graphs- Memory efficient- Quick neighbor lookup&quot;,
    &quot;Adjacency Matrix&quot;: &quot;- Dense graphs- Quick edge weight lookup- Simple implementation&quot;
}
</code></pre>
<ol>
<li><strong>Algorithm Selection</strong></li>
</ol>
<pre><code class="language-python">algorithm_selection = {
    &quot;BFS&quot;: &quot;Shortest path in unweighted graph&quot;,
    &quot;DFS&quot;: &quot;Path finding, cycle detection&quot;,
    &quot;Dijkstra&quot;: &quot;Shortest path in weighted graph&quot;,
    &quot;Union Find&quot;: &quot;Connected components, cycle detection in undirected graph&quot;
}
</code></pre>
<pre><code class="language-python">selection_guide = {
    &quot;Shortest Path (Unweighted)&quot;: &quot;Use BFS&quot;,
    &quot;Shortest Path (Weighted, Non-negative)&quot;: &quot;Use Dijkstra&quot;,
    &quot;Shortest Path (Weighted, Can be negative)&quot;: &quot;Use Bellman-Ford&quot;,
    &quot;Cycle Detection&quot;: &quot;Use DFS with recursion stack&quot;,
    &quot;Component Finding&quot;: &quot;Use Union Find or DFS&quot;,
    &quot;Dependency Ordering&quot;: &quot;Use Topological Sort&quot;,
    &quot;Two-Coloring Problems&quot;: &quot;Use Bipartite Check&quot;
}
</code></pre>
<ol>
<li><strong>Edge Cases to Consider</strong></li>
</ol>
<pre><code class="language-python">edge_cases = [
    &quot;Empty graph&quot;,
    &quot;Single node&quot;,
    &quot;Disconnected components&quot;,
    &quot;Cycles&quot;,
    &quot;Self-loops&quot;,
    &quot;Bidirectional edges&quot;,
    &quot;No path exists&quot;
]
</code></pre>
<ol>
<li>
<p><strong>Optimization Tips</strong>:</p>
</li>
<li>
<p>Use adjacency list for sparse graphs</p>
</li>
<li>Use adjacency matrix for dense graphs</li>
<li>Consider using iterative DFS instead of recursive for large graphs</li>
<li>Use Union Find for dynamic connectivity problems</li>
<li>Cache results in graph traversal when possible</li>
</ol>
<p>Remember:</p>
<ul>
<li>Always clarify the graph properties (directed/undirected, weighted/unweighted)</li>
<li>Consider time/space complexity tradeoffs</li>
<li>Draw examples when solving</li>
<li>Test with small cases first</li>
<li>Consider using helper functions for complex logic</li>
</ul>
<h1 id="minimum-spanning-trees-mst">ğŸŒ³ Minimum Spanning Trees (MST)</h1>
<h2 id="core-concepts_3">ğŸ“š Core Concepts</h2>
<h3 id="what-is-a-minimum-spanning-tree">What is a Minimum Spanning Tree?</h3>
<pre><code class="language-python">&quot;&quot;&quot;
A Minimum Spanning Tree (MST) is a subset of edges in a connected, 
undirected, weighted graph that:
1. Connects all vertices
2. Contains no cycles
3. Has minimum total edge weight among all possible spanning trees

Properties:
- Contains exactly V-1 edges (where V is number of vertices)
- May not be unique (graph can have multiple MSTs)
- Always unique if all edge weights are different
&quot;&quot;&quot;
</code></pre>
<h2 id="key-algorithms">ğŸ¯ Key Algorithms</h2>
<h3 id="1-kruskals-algorithm">1. Kruskal's Algorithm</h3>
<pre><code class="language-python">class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.rank = [0] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        # Union by rank
        if self.rank[px] &lt; self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] &gt; self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1
        return True

def kruskal_mst(graph, V):
    &quot;&quot;&quot;
    Time: O(E log E) where E is number of edges
    Space: O(V) where V is number of vertices

    Use when:
    - Graph is sparse (E &lt;&lt; VÂ²)
    - Graph might not be connected
    - Edge weights are primary consideration
    &quot;&quot;&quot;
    edges = []  # (weight, u, v)
    for u in range(V):
        for v, w in graph[u]:
            edges.append((w, u, v))

    edges.sort()  # Sort by weight
    uf = UnionFind(V)
    mst = []
    mst_weight = 0

    for weight, u, v in edges:
        if uf.union(u, v):  # If no cycle is created
            mst.append((u, v))
            mst_weight += weight
            if len(mst) == V - 1:
                break

    return mst, mst_weight
</code></pre>
<h3 id="2-prims-algorithm">2. Prim's Algorithm</h3>
<pre><code class="language-python">from heapq import heappush, heappop

def prim_mst(graph, V):
    &quot;&quot;&quot;
    Time: O(E log V) with min-heap
    Space: O(V)

    Use when:
    - Graph is dense (E â‰ˆ VÂ²)
    - Graph is guaranteed to be connected
    - Starting vertex is known/important
    &quot;&quot;&quot;
    visited = [False] * V
    min_heap = [(0, 0, -1)]  # (weight, vertex, parent)
    mst = []
    mst_weight = 0

    while min_heap:
        weight, vertex, parent = heappop(min_heap)

        if visited[vertex]:
            continue

        visited[vertex] = True
        if parent != -1:
            mst.append((parent, vertex))
            mst_weight += weight

        for next_vertex, edge_weight in graph[vertex]:
            if not visited[next_vertex]:
                heappush(min_heap, (edge_weight, next_vertex, vertex))

    return mst, mst_weight
</code></pre>
<h2 id="algorithm-selection-guide">ğŸ® Algorithm Selection Guide</h2>
<h3 id="when-to-use-each-algorithm">When to Use Each Algorithm</h3>
<pre><code class="language-python">def choose_mst_algorithm(graph_properties):
    selection_guide = {
        &quot;Kruskal&quot;: {
            &quot;Best for&quot;: [
                &quot;Sparse graphs (E &lt;&lt; VÂ²)&quot;,
                &quot;When graph might be disconnected&quot;,
                &quot;When edge weights are the focus&quot;
            ],
            &quot;Advantages&quot;: [
                &quot;Works with disconnected graphs&quot;,
                &quot;Tends to be simpler to implement&quot;,
                &quot;Good for sparse graphs&quot;
            ]
        },
        &quot;Prim&quot;: {
            &quot;Best for&quot;: [
                &quot;Dense graphs (E â‰ˆ VÂ²)&quot;,
                &quot;When starting vertex matters&quot;,
                &quot;When graph is connected&quot;
            ],
            &quot;Advantages&quot;: [
                &quot;Better for dense graphs&quot;,
                &quot;Can find partial MSTs&quot;,
                &quot;More efficient with priority queue&quot;
            ]
        }
    }
</code></pre>
<h2 id="common-interview-problems_2">ğŸ“ Common Interview Problems</h2>
<h3 id="1-connecting-cities-with-minimum-cost">1. Connecting Cities with Minimum Cost</h3>
<pre><code class="language-python">def min_cost_connect_cities(connections, N):
    &quot;&quot;&quot;
    Given a list of connections [city1, city2, cost],
    find minimum cost to connect all cities
    &quot;&quot;&quot;
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(x, y):
        px, py = find(x), find(y)
        if px == py:
            return False
        parent[px] = py
        return True

    parent = list(range(N + 1))
    connections.sort(key=lambda x: x[2])  # Sort by cost

    total_cost = 0
    edges_used = 0

    for city1, city2, cost in connections:
        if union(city1, city2):
            total_cost += cost
            edges_used += 1

    return total_cost if edges_used == N - 1 else -1
</code></pre>
<h3 id="2-network-optimization">2. Network Optimization</h3>
<pre><code class="language-python">def optimize_network(nodes, connections):
    &quot;&quot;&quot;
    Optimize network connections while maintaining
    minimum latency between all nodes
    &quot;&quot;&quot;
    def mst_with_constraints(edges):
        uf = UnionFind(len(nodes))
        mst = []
        total_latency = 0

        for u, v, latency in sorted(edges, key=lambda x: (x[2], x[0])):
            if uf.union(u, v):
                mst.append((u, v))
                total_latency += latency

        return mst, total_latency if len(mst) == len(nodes) - 1 else float('inf')
</code></pre>
<h2 id="interview-tips_6">ğŸ’¡ Interview Tips</h2>
<h3 id="1-problem-recognition">1. Problem Recognition</h3>
<pre><code class="language-python">mst_indicators = {
    &quot;Minimum cost/distance/weight&quot;: &quot;Total weight needs to be minimized&quot;,
    &quot;Connect all points&quot;: &quot;Need spanning tree property&quot;,
    &quot;No cycles allowed&quot;: &quot;Tree structure required&quot;,
    &quot;Optimize network&quot;: &quot;Network optimization problems&quot;,
    &quot;Reduce redundancy&quot;: &quot;Remove unnecessary edges&quot;
}
</code></pre>
<h3 id="2-implementation-strategy">2. Implementation Strategy</h3>
<pre><code class="language-python">implementation_tips = {
    &quot;1. Graph Representation&quot;: [
        &quot;Adjacency list for sparse graphs&quot;,
        &quot;Adjacency matrix for dense graphs&quot;,
        &quot;Edge list for Kruskal's&quot;
    ],
    &quot;2. Edge Cases&quot;: [
        &quot;Empty graph&quot;,
        &quot;Single node&quot;,
        &quot;Disconnected components&quot;,
        &quot;Equal edge weights&quot;
    ],
    &quot;3. Optimization&quot;: [
        &quot;Use Union-Find for cycle detection&quot;,
        &quot;Priority queue for Prim's&quot;,
        &quot;Sort edges once for Kruskal's&quot;
    ]
}
</code></pre>
<h3 id="3-common-mistakes-to-avoid">3. Common Mistakes to Avoid</h3>
<pre><code class="language-python">common_mistakes = {
    &quot;Algorithm Selection&quot;: &quot;Not considering graph density&quot;,
    &quot;Cycle Detection&quot;: &quot;Forgetting to check for cycles&quot;,
    &quot;Edge Processing&quot;: &quot;Not handling duplicate edges&quot;,
    &quot;Disconnected Graphs&quot;: &quot;Assuming graph is connected&quot;,
    &quot;Edge Weights&quot;: &quot;Not handling negative weights&quot;
}
</code></pre>
<p>Remember:</p>
<ul>
<li>Always verify if graph is connected when using Prim's</li>
<li>Consider edge cases (empty graph, single node)</li>
<li>Watch for negative edge weights</li>
<li>Check if all vertices are included in final MST</li>
<li>Consider trade-offs between algorithms based on graph properties</li>
</ul>
<h1 id="technical-interview-patterns">Technical Interview Patterns</h1>
<p><a href="https://blog.algomaster.io/p/15-leetcode-patterns">Common Technical Interview Patterns</a></p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
